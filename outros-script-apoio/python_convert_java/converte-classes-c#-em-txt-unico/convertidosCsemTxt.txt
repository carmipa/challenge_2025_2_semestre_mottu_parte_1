// Script: converte-arquivos-csharp-em-txt-unico (v1.1.1)
// Data de criação do arquivo de saída: 2025-06-02 20:52:17

// Estrutura de diretórios do projeto (pastas + arquivos .cs):
gsApi/
    Program.cs
    WeatherForecast.cs
    Controllers/
        WeatherForecastController.cs
    Properties/
    Swagger/
        ExternalDocsDocumentFilter .cs
    bin/
        Debug/
            net8.0/
                cs/
                de/
                es/
                fr/
                it/
                ja/
                ko/
                pl/
                pt-BR/
                ru/
                runtimes/
                    linux/
                        lib/
                            net8.0/
                    osx/
                        lib/
                            net8.0/
                    win/
                        lib/
                            net8.0/
                tr/
                zh-Hans/
                zh-Hant/
        Release/
            net8.0/
    controller/
        AlertsController .cs
        ClientesController.cs
        ContatosController .cs
        EnderecosController .cs
        EonetController.cs
        StatsController.cs
    data/
        AppDbContext .cs
    dto/
        request/
            AlertableEventDto.cs
            ClienteRequestDto.cs
            ContatoRequestDto.cs
            EnderecoGeoRequestDto.cs
            EnderecoRequestDto.cs
            EonetRequestDto.cs
            UserAlertRequestDto.cs
        response/
            CategoryCountDto.cs
            ClienteResponseDto.cs
            ContatoResponseDto.cs
            EnderecoResponseDto.cs
            EonetResponseDto.cs
            GeoCoordinatesDto .cs
            GoogleGeocodingApiResponseDto .cs
            GoogleGeocodingGeometryDto.cs
            GoogleGeocodingLocationDto.cs
            GoogleGeocodingResultDto.cs
            NasaEonetApiResponseDto.cs
            NasaEonetCategoryDto.cs
            NasaEonetEventDto .cs
            NasaEonetGeometryDto.cs
            NasaEonetSourceDto.cs
            NominatimResponseDto.cs
            TimeCountDto.cs
            ViaCepResponseDto.cs
    exceptions/
        RecursoNaoEncontradoException .cs
        ServicoIndisponivelException .cs
        ValidacaoException .cs
    middleware/
        TratadorGlobalExcecoesMiddleware.cs
    model/
        Cliente.cs
        Contato.cs
        Endereco.cs
        EonetEvent.cs
    obj/
        Debug/
            net8.0/
                .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
                gsApi.AssemblyInfo.cs
                gsApi.GlobalUsings.g.cs
                gsApi.MvcApplicationPartsAssemblyInfo.cs
                EndpointInfo/
                ref/
                refint/
                staticwebassets/
        Release/
            net8.0/
                .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
                gsApi.AssemblyInfo.cs
                gsApi.GlobalUsings.g.cs
                ref/
                refint/
    service/
        GeoCodingClient .cs
        IEmailNotificationService.cs
        IGeoCodingClient.cs
        INasaEonetClient.cs
        IViaCepClient.cs
        NasaEonetClient.cs
        SmtpSettings.cs
        ViaCepClient .cs

// Arquivos encontrados (Namespace.Tipo => caminho relativo):
// gsApi.Controllers.WeatherForecastController => Controllers\WeatherForecastController.cs
// Program => Program.cs
// gsApi.Swagger.ExternalDocsDocumentFilter => Swagger\ExternalDocsDocumentFilter .cs
// gsApi.WeatherForecast => WeatherForecast.cs
// gsApi.controller.AlertsController => controller\AlertsController .cs
// gsApi.controller.ClientesController => controller\ClientesController.cs
// gsApi.controller.ContatosController => controller\ContatosController .cs
// gsApi.controller.EnderecosController => controller\EnderecosController .cs
// gsApi.controller.EonetController => controller\EonetController.cs
// gsApi.controller.StatsController => controller\StatsController.cs
// gsApi.data.AppDbContext => data\AppDbContext .cs
// gsApi.dto.request.AlertableEventDto => dto\request\AlertableEventDto.cs
// gsApi.dto.request.ClienteRequestDto => dto\request\ClienteRequestDto.cs
// gsApi.DTOs.Request.ContatoRequestDto => dto\request\ContatoRequestDto.cs
// gsApi.DTOs.Request.EnderecoGeoRequestDto => dto\request\EnderecoGeoRequestDto.cs
// gsApi.DTOs.Request.EnderecoRequestDto => dto\request\EnderecoRequestDto.cs
// gsApi.DTOs.Request.EonetRequestDto => dto\request\EonetRequestDto.cs
// gsApi.dto.request.UserAlertRequestDto => dto\request\UserAlertRequestDto.cs
// gsApi.model.DTOs.Response.CategoryCountDto => dto\response\CategoryCountDto.cs
// gsApi.dto.response.ClienteResponseDto => dto\response\ClienteResponseDto.cs
// gsApi.dto.response.ContatoResponseDto => dto\response\ContatoResponseDto.cs
// gsApi.dto.response.EnderecoResponseDto => dto\response\EnderecoResponseDto.cs
// gsApi.dto.response.EonetResponseDto => dto\response\EonetResponseDto.cs
// gsApi.DTOs.Response.GeoCoordinatesDto => dto\response\GeoCoordinatesDto .cs
// gsApi.dto.response.GoogleGeocodingApiResponseDto => dto\response\GoogleGeocodingApiResponseDto .cs
// gsApi.dto.response.GoogleGeocodingGeometryDto => dto\response\GoogleGeocodingGeometryDto.cs
// gsApi.dto.response.GoogleGeocodingLocationDto => dto\response\GoogleGeocodingLocationDto.cs
// gsApi.dto.response.GoogleGeocodingResultDto => dto\response\GoogleGeocodingResultDto.cs
// gsApi.dto.response.NasaEonetApiResponseDto => dto\response\NasaEonetApiResponseDto.cs
// gsApi.dto.response.NasaEonetCategoryDto => dto\response\NasaEonetCategoryDto.cs
// gsApi.DTOs.Response.NasaEonetEventDto => dto\response\NasaEonetEventDto .cs
// gsApi.dto.response.NasaEonetGeometryDto => dto\response\NasaEonetGeometryDto.cs
// gsApi.dto.response.NasaEonetSourceDto => dto\response\NasaEonetSourceDto.cs
// gsApi.dto.response.NominatimResponseDto => dto\response\NominatimResponseDto.cs
// gsApi.DTOs.Response.TimeCountDto => dto\response\TimeCountDto.cs
// gsApi.DTOs.Response.ViaCepResponseDto => dto\response\ViaCepResponseDto.cs
// gsApi.exceptions.RecursoNaoEncontradoException => exceptions\RecursoNaoEncontradoException .cs
// gsApi.Exceptions.ServicoIndisponivelException => exceptions\ServicoIndisponivelException .cs
// gsApi.Exceptions.ValidacaoException => exceptions\ValidacaoException .cs
// gsApi.middleware.TratadorGlobalExcecoesMiddleware => middleware\TratadorGlobalExcecoesMiddleware.cs
// gsApi.model.Cliente => model\Cliente.cs
// gsApi.model.Contato => model\Contato.cs
// gsApi.model.Endereco => model\Endereco.cs
// gsApi.model.EonetEvent => model\EonetEvent.cs
// .NETCoreApp,Version=v8.0.AssemblyAttributes => obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// gsApi.AssemblyInfo => obj\Debug\net8.0\gsApi.AssemblyInfo.cs
// gsApi.GlobalUsings.g => obj\Debug\net8.0\gsApi.GlobalUsings.g.cs
// gsApi.MvcApplicationPartsAssemblyInfo => obj\Debug\net8.0\gsApi.MvcApplicationPartsAssemblyInfo.cs
// .NETCoreApp,Version=v8.0.AssemblyAttributes => obj\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// gsApi.AssemblyInfo => obj\Release\net8.0\gsApi.AssemblyInfo.cs
// gsApi.GlobalUsings.g => obj\Release\net8.0\gsApi.GlobalUsings.g.cs
// gsApi.services.GeoCodingClient => service\GeoCodingClient .cs
// gsApi.services.IEmailNotificationService => service\IEmailNotificationService.cs
// gsApi.services.IGeoCodingClient => service\IGeoCodingClient.cs
// gsApi.services.INasaEonetClient => service\INasaEonetClient.cs
// gsApi.services.IViaCepClient => service\IViaCepClient.cs
// gsApi.services.NasaEonetClient => service\NasaEonetClient.cs
// gsApi.services.SmtpSettings => service\SmtpSettings.cs
// gsApi.services.ViaCepClient => service\ViaCepClient .cs




//----------------------------------------------------------------------------------------------------
// Caminho: Controllers\WeatherForecastController.cs
// Namespace: gsApi.Controllers
// Tipo: WeatherForecastController
//----------------------------------------------------------------------------------------------------

using Microsoft.AspNetCore.Mvc;

namespace gsApi.Controllers
{
    [ApiController]
    [Route("[controller]")]
    public class WeatherForecastController : ControllerBase
    {
        private static readonly string[] Summaries = new[]
        {
            "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
        };

        private readonly ILogger<WeatherForecastController> _logger;

        public WeatherForecastController(ILogger<WeatherForecastController> logger)
        {
            _logger = logger;
        }

        [HttpGet(Name = "GetWeatherForecast")]
        public IEnumerable<WeatherForecast> Get()
        {
            return Enumerable.Range(1, 5).Select(index => new WeatherForecast
            {
                Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
                TemperatureC = Random.Shared.Next(-20, 55),
                Summary = Summaries[Random.Shared.Next(Summaries.Length)]
            })
            .ToArray();
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: Program.cs
// Namespace: (namespace padrão)
// Tipo: Program
//----------------------------------------------------------------------------------------------------

// File: gsApi/Program.cs
using gsApi.data;
using gsApi.middleware;
using gsApi.Swagger;
using gsApi.services;
using Microsoft.AspNetCore.Builder;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.OpenApi.Models;
using System;
using System.IO;
using System.Reflection;

var startupLogPath = Path.Combine(AppContext.BaseDirectory, "gsApi_startup_trace.log");
Action<string> earlyManualLog = (message) =>
{
    try { File.AppendAllText(startupLogPath, $"[{DateTime.UtcNow:o}] {message}{Environment.NewLine}"); }
    catch (Exception ex) { Console.WriteLine($"Falha ao escrever no log manual inicial: {ex.Message}"); }
};
ILogger? appLogger = null;

try
{
    earlyManualLog("INICIANDO SEQUNCIA DE STARTUP DA APLICAO GSAPI...");
    var builder = WebApplication.CreateBuilder(args);
    earlyManualLog($"WebApplication.CreateBuilder concludo. Argumentos: {string.Join(" ", args)}");

    // Configurao de Logging Inicial
    builder.Logging.ClearProviders();
    builder.Logging.AddConsole();
    builder.Logging.AddDebug();
    // Configura o logging a partir do appsettings.json para o builder tambm
    builder.Logging.AddConfiguration(builder.Configuration.GetSection("Logging"));
    earlyManualLog("Provedores de logging (Console, Debug) configurados no builder.Logging.");

    // Logger para estgios iniciais (antes de app.Services estar disponvel)
    using var tempLoggerFactory = LoggerFactory.Create(logBuilder =>
    {
        logBuilder.AddConfiguration(builder.Configuration.GetSection("Logging"));
        logBuilder.AddConsole();
        logBuilder.AddDebug();
    });
    var earlyStageLogger = tempLoggerFactory.CreateLogger("StartupConfig");
    earlyStageLogger.LogInformation("Logger de estgio inicial ('StartupConfig') criado.");
    earlyStageLogger.LogInformation($"Nvel de Log Default: {builder.Configuration.GetValue<string>("Logging:LogLevel:Default", "N/A")}");
    earlyStageLogger.LogInformation($"Nvel de Log Microsoft.AspNetCore: {builder.Configuration.GetValue<string>("Logging:LogLevel:Microsoft.AspNetCore", "N/A")}");
    earlyStageLogger.LogInformation($"Nvel de Log Microsoft.EntityFrameworkCore.Database.Command: {builder.Configuration.GetValue<string>("Logging:LogLevel:Microsoft.EntityFrameworkCore.Database.Command", "N/A")}");

    earlyStageLogger.LogInformation("Iniciando configurao de servios (builder.Services)...");

    // --- INCIO DA CONFIGURAO DE CORS ---
    var MyAllowSpecificOrigins = "_myAllowSpecificOriginsGsApi";
    earlyStageLogger.LogInformation("Definindo poltica CORS com nome: {PolicyName}", MyAllowSpecificOrigins);

    builder.Services.AddCors(options =>
    {
        options.AddPolicy(name: MyAllowSpecificOrigins,
                          policy =>
                          {
                              policy.WithOrigins("http://localhost:3001", "http://localhost:3000") // Adicionei localhost:3000 tambm, caso seu frontend mude de porta
                                    .AllowAnyHeader()
                                    .AllowAnyMethod();
                          });
    });
    earlyStageLogger.LogInformation("Servio AddCors() configurado para a poltica '{PolicyName}' permitindo origens como http://localhost:3001.", MyAllowSpecificOrigins);
    // --- FIM DA CONFIGURAO DE CORS ---

    builder.Services.AddControllers();
    earlyStageLogger.LogInformation("Servio AddControllers() adicionado.");
    builder.Services.AddEndpointsApiExplorer();
    earlyStageLogger.LogInformation("Servio AddEndpointsApiExplorer() adicionado.");

    var connectionString = builder.Configuration.GetConnectionString("OracleDb");
    string displayConnectionString = string.IsNullOrEmpty(connectionString) ?
                                     "NO ENCONTRADA" :
                                     (connectionString.ToLowerInvariant().Contains("password=") || connectionString.ToLowerInvariant().Contains("pwd=") ?
                                     "***SENHA OCULTADA NA STRING DE CONEXO***" :
                                     connectionString);
    earlyStageLogger.LogInformation("String de conexo 'OracleDb' lida: '{ConnString}'", displayConnectionString);

    if (string.IsNullOrEmpty(connectionString))
    {
        var errorMsg = "FATAL: String de conexo 'OracleDb' no encontrada ou vazia no appsettings.json.";
        earlyStageLogger.LogCritical(errorMsg); earlyManualLog(errorMsg);
        throw new InvalidOperationException(errorMsg);
    }

    builder.Services.AddDbContext<AppDbContext>(options =>
    {
        earlyStageLogger.LogInformation("Configurando AppDbContext com provedor Oracle...");
        options.UseOracle(connectionString, oracleOptions =>
        {
            oracleOptions.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery);
            earlyStageLogger.LogInformation("QuerySplittingBehavior.SplitQuery configurado para Oracle.");
        })
        .LogTo(logMessage => earlyStageLogger.LogInformation(logMessage),
               new[] {
                   DbLoggerCategory.Database.Command.Name, DbLoggerCategory.Query.Name,
                   DbLoggerCategory.Database.Connection.Name, DbLoggerCategory.Model.Validation.Name,
                   DbLoggerCategory.ChangeTracking.Name, DbLoggerCategory.Infrastructure.Name
               },
               LogLevel.Information, DbContextLoggerOptions.DefaultWithUtcTime);

        if (builder.Environment.IsDevelopment())
        {
            options.EnableSensitiveDataLogging();
            options.EnableDetailedErrors();
            earlyStageLogger.LogInformation("EnableSensitiveDataLogging e EnableDetailedErrors HABILITADOS para AppDbContext (Dev).");
        }
        earlyStageLogger.LogInformation("AppDbContext configurado.");
    });

    // Registro dos Clientes HTTP e Servios
    builder.Services.AddHttpClient<IViaCepClient, ViaCepClient>(client =>
    {
        var viaCepBaseUrl = builder.Configuration["ExternalServices:ViaCep:BaseUrl"];
        if (string.IsNullOrEmpty(viaCepBaseUrl))
        {
            earlyStageLogger.LogCritical("URL base para ViaCEP no configurada em ExternalServices:ViaCep:BaseUrl. O servio ViaCepClient no funcionar corretamente.");
            throw new InvalidOperationException("URL base para ViaCEP no configurada em ExternalServices:ViaCep:BaseUrl.");
        }
        client.BaseAddress = new Uri(viaCepBaseUrl);
        earlyStageLogger.LogInformation("HttpClient para ViaCepClient configurado com BaseUrl: {ViaCepBaseUrl}", viaCepBaseUrl);
    });

    builder.Services.AddHttpClient<IGeoCodingClient, GeoCodingClient>(); // ApiKey e ApiUrl so lidos dentro do client via IConfiguration

    builder.Services.AddHttpClient<INasaEonetClient, NasaEonetClient>(client =>
    {
        var eonetBaseUrl = builder.Configuration["ExternalServices:NasaEonet:BaseUrl"];
        if (string.IsNullOrEmpty(eonetBaseUrl))
        {
            earlyStageLogger.LogCritical("URL base para NASA EONET no configurada em ExternalServices:NasaEonet:BaseUrl.");
            throw new InvalidOperationException("URL base para NASA EONET no configurada em ExternalServices:NasaEonet:BaseUrl.");
        }
        client.BaseAddress = new Uri(eonetBaseUrl);
        client.DefaultRequestHeaders.Add("User-Agent", "gsApi/1.0 (FIAP Global Solution)");
        earlyStageLogger.LogInformation("HttpClient para NasaEonetClient configurado com BaseUrl: {NasaEonetBaseUrl}", eonetBaseUrl);
    });
    builder.Services.AddTransient<IEmailNotificationService, EmailNotificationService>();
    earlyStageLogger.LogInformation("Servios de cliente HTTP (ViaCep, GeoCoding, NasaEonet) e EmailNotificationService registrados.");

    builder.Services.AddSwaggerGen(c =>
    {
        var description = "API RESTful desenvolvida como parte da Global Solution FIAP 2025/1 " +
                          "(2 Ano - Anlise e Desenvolvimento de Sistemas, Turmas de Fevereiro) para o desafio 'Eventos Extremos'. " +
                          "O projeto 'GS Alerta Desastres', da Equipe MetaMind, prope uma soluo tecnolgica para monitorar " +
                          "eventos de desastres naturais em tempo real (utilizando dados da API EONET da NASA), fornecer informaes " +
                          "cruciais e permitir o disparo de alertas para usurios cadastrados, visando ajudar pessoas e prevenir problemas " +
                          "maiores em cenrios impactados por eventos extremos da natureza. Esta API .NET, criada para a disciplina " +
                          "'Advanced Business Development with .NET', tem como objetivo atender aos requisitos de uma API REST robusta " +
                          "para tratar de problemas crticos e auxiliar as pessoas em perodos de extrema urgncia, incluindo persistncia " +
                          "de dados, relacionamentos, documentao Swagger." + // Removido "e uso de migrations" conforme contexto
                          "\n\n**Equipe MetaMind:**" +
                          "\n- Paulo Andr Carminati (RM: 557881) - GitHub: [carmipa](https://github.com/carmipa)" +
                          "\n- Arthur Bispo de Lima (RM: 557568) - GitHub: [ArthurBispo00](https://github.com/ArthurBispo00)" +
                          "\n- Joo Paulo Moreira (RM: 557808) - GitHub: [joao1015](https://github.com/joao1015)" +
                          "\n" +
                          "\n- Repsritrio do projto - GitHub: [GS_FIAP_2025_1SM](https://github.com/carmipa/GS_FIAP_2025_1SM)" +
                          "\n" +
                          "\n- Repsritrio dda matria - GitHub: [Advanced_Business_Development_with.NET](https://github.com/carmipa/GS_FIAP_2025_1SM/tree/main/Advanced_Business_Development_with.NET)" +
                          "\n" +
                          "\n- Vdeo de Apresentao: [YOUTUBE](https://www.youtube.com/watch?v=M-Ia0UnPZjI&t=52s)" +
                          "\n" +
                          "\n- Diagramas de relacionamento: [GitHub](https://github.com/carmipa/GS_FIAP_2025_1SM/tree/main/Advanced_Business_Development_with.NET/DIAGRAMAS)";


        c.SwaggerDoc("v1", new OpenApiInfo
        {
            Title = "GS Alerta Desastres - API (.NET) - Desafio Eventos Extremos",
            Version = "v1.0.0",
            Description = description,
            Contact = new OpenApiContact { Name = "Equipe MetaMind", Email = "equipe.metamind.fiap@example.com", Url = new Uri("https://github.com/carmipa/GS_FIAP_2025_1SM") },
            License = new OpenApiLicense { Name = "MIT License", Url = new Uri("https://github.com/carmipa/GS_FIAP_2025_1SM/blob/main/LICENSE") }
        });
        c.DocumentFilter<ExternalDocsDocumentFilter>();

        var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
        var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
        if (File.Exists(xmlPath))
        {
            c.IncludeXmlComments(xmlPath);
            earlyStageLogger.LogInformation($"Comentrios XML para Swagger includos do arquivo: {xmlPath}");
        }
        else
        {
            earlyStageLogger.LogWarning($"Arquivo XML de comentrios Swagger no encontrado: {xmlPath}. Verifique se <GenerateDocumentationFile>true</GenerateDocumentationFile> est no .csproj e se o projeto foi compilado.");
        }
    });
    earlyStageLogger.LogInformation("Configurao de SwaggerGen concluda.");
    earlyStageLogger.LogInformation("Configurao de todos os servios finalizada.");

    var app = builder.Build();
    appLogger = app.Services.GetRequiredService<ILogger<Program>>();
    appLogger.LogInformation("Aplicao construda. Configurando pipeline HTTP...");

    app.UseMiddleware<TratadorGlobalExcecoesMiddleware>();
    appLogger.LogInformation("Middleware 'TratadorGlobalExcecoesMiddleware' adicionado.");

    if (app.Environment.IsDevelopment())
    {
        app.UseSwagger();
        app.UseSwaggerUI(o =>
        {
            o.SwaggerEndpoint("/swagger/v1/swagger.json", "GS Alerta API V1");
            // o.RoutePrefix = string.Empty; // Para Swagger UI na raiz, se desejado
            appLogger.LogInformation("Swagger UI habilitado em Desenvolvimento.");
        });
    }
    else
    {
        app.UseHsts(); // Use HSTS em produo
        appLogger.LogInformation("HSTS habilitado para ambiente no-Desenvolvimento.");
    }

    app.UseHttpsRedirection();
    appLogger.LogInformation("HTTPS Redirection habilitado.");

    app.UseRouting(); // Adicionar UseRouting antes de UseCors e UseAuthorization
    appLogger.LogInformation("Routing middleware habilitado.");

    app.UseCors(MyAllowSpecificOrigins);
    appLogger.LogInformation("Middleware UseCors() com a poltica '{PolicyName}' adicionado ao pipeline.", MyAllowSpecificOrigins);

    app.UseAuthorization();
    appLogger.LogInformation("Authorization middleware habilitado.");

    app.MapControllers();
    appLogger.LogInformation("Controllers mapeados.");

    appLogger.LogInformation("Pipeline HTTP configurado. Iniciando aplicao...");
    earlyManualLog("TENTANDO EXECUTAR APP.RUN()...");
    app.Run();
}
catch (Exception ex)
{
    var fatalMsg = $"EXCEO FATAL NA INICIALIZAO: {ex.ToString()}";
    Console.ForegroundColor = ConsoleColor.Red; Console.Error.WriteLine(fatalMsg); Console.ResetColor();
    earlyManualLog(fatalMsg);
    if (appLogger != null) { appLogger.LogCritical(ex, "Falha CRTICA na inicializao."); }
    else { LoggerFactory.Create(lb => lb.AddConsole().AddDebug()).CreateLogger("StartupCrash").LogCritical(ex, "Falha CRTICA na inicializao (appLogger nulo)."); }
    // Environment.Exit(1); // Fora a sada em caso de falha crtica no startup
    throw; // Relana a exceo para que o host do processo falhe como esperado
}
finally
{
    earlyManualLog("SEQUNCIA DE STARTUP FINALIZADA.");
}



//----------------------------------------------------------------------------------------------------
// Caminho: Swagger\ExternalDocsDocumentFilter .cs
// Namespace: gsApi.Swagger
// Tipo: ExternalDocsDocumentFilter
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/Swagger/ExternalDocsDocumentFilter.cs
using Microsoft.OpenApi.Models;
using Swashbuckle.AspNetCore.SwaggerGen;
using System;

namespace gsApi.Swagger // Namespace padronizado
{
    /// <summary>
    /// DocumentFilter que adiciona o bloco "externalDocs" de nível raiz 
    /// ao JSON final do OpenAPI.
    /// </summary>
    public class ExternalDocsDocumentFilter : IDocumentFilter
    {
        public void Apply(OpenApiDocument swaggerDoc, DocumentFilterContext context)
        {
            swaggerDoc.ExternalDocs = new OpenApiExternalDocs
            {
                Description = "Saiba mais sobre a Global Solution FIAP",
                Url = new Uri("https://www.fiap.com.br/graduacao/global-solution/")
            };
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: WeatherForecast.cs
// Namespace: gsApi
// Tipo: WeatherForecast
//----------------------------------------------------------------------------------------------------

namespace gsApi
{
    public class WeatherForecast
    {
        public DateOnly Date { get; set; }

        public int TemperatureC { get; set; }

        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);

        public string? Summary { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: controller\AlertsController .cs
// Namespace: gsApi.controller
// Tipo: AlertsController
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/controller/AlertsController.cs
using gsApi.data;             // Namespace para AppDbContext
using gsApi.dto.request;      // Namespace para UserAlertRequestDto, AlertableEventDto
using gsApi.DTOs.Request;
// using gsApi.dto.response; // Não usado diretamente para o corpo da resposta aqui
using gsApi.exceptions;       // Namespace para RecursoNaoEncontradoException
using gsApi.model;            // Namespace para Cliente, Contato
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
// using gsApi.services;    // Namespace para IEmailNotificationService (futuro)
using System;
using System.Linq;
using System.Threading.Tasks;

namespace gsApi.controller
{
    /// <summary>
    /// Gerencia o disparo de alertas específicos para usuários.
    /// </summary>
    [ApiController]
    [Route("api/alerts")]
    [Produces("application/json")]
    [Consumes("application/json")]
    public class AlertsController : ControllerBase
    {
        private readonly ILogger<AlertsController> _logger;
        private readonly AppDbContext _context;
        // private readonly IEmailNotificationService _emailService; // Descomente quando o serviço de email for injetado

        public AlertsController(ILogger<AlertsController> logger, AppDbContext context /*, IEmailNotificationService emailService */)
        {
            _logger = logger;
            _context = context;
            // _emailService = emailService; // Descomente
        }

        /// <summary>
        /// Dispara um alerta para um usuário específico sobre um evento.
        /// </summary>
        /// <remarks>
        /// Este endpoint recebe o ID de um usuário e os detalhes de um evento. 
        /// Ele tentará encontrar o e-mail principal do usuário e, em uma implementação futura completa, 
        /// enviaria uma notificação por e-mail.
        /// </remarks>
        /// <param name="requestDto">Objeto contendo o `UserId` e `EventDetails` para o alerta.</param>
        /// <response code="200">Solicitação de alerta processada com sucesso. A mensagem indicará se o e-mail seria enviado (simulação) ou se não foi encontrado um e-mail válido.</response>
        /// <response code="400">Se os dados da requisição forem inválidos (ex: campos obrigatórios faltando no DTO).</response>
        /// <response code="404">Se o usuário com o ID especificado não for encontrado no sistema.</response>
        /// <response code="500">Se ocorrer um erro interno inesperado no servidor durante o processamento.</response>
        [HttpPost("trigger-user-specific-alert")]
        [ProducesResponseType(typeof(string), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> TriggerAlertForUser([FromBody] UserAlertRequestDto requestDto)
        {
            _logger.LogInformation(
                "Endpoint POST /api/alerts/trigger-user-specific-alert chamado para UserID: {UserId} sobre evento: {EventTitle}",
                requestDto.UserId, requestDto.EventDetails?.Title);

            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }

            var usuario = await _context.Clientes
                                      .Include(c => c.Contatos)
                                      .FirstOrDefaultAsync(c => c.IdCliente == requestDto.UserId);

            if (usuario == null)
            {
                _logger.LogWarning("Usuário com ID: {UserId} não encontrado para envio de alerta.", requestDto.UserId);
                // Em uma implementação com camada de serviço, o serviço lançaria RecursoNaoEncontradoException.
                // O middleware TratadorGlobalExcecoesMiddleware cuidaria de formatar a resposta 404.
                return NotFound(new ProblemDetails
                {
                    Status = StatusCodes.Status404NotFound,
                    Title = "Recurso não encontrado.",
                    Detail = $"Usuário com ID: {requestDto.UserId} não encontrado."
                });
            }

            var contatoPrincipal = usuario.Contatos?.FirstOrDefault(c => !string.IsNullOrEmpty(c.Email));

            if (contatoPrincipal == null || string.IsNullOrEmpty(contatoPrincipal.Email))
            {
                _logger.LogWarning("Usuário ID: {UserId} ({UserName}) não possui um e-mail de contato válido cadastrado. Alerta não pode ser enviado por e-mail.",
                    usuario.IdCliente, usuario.Nome);
                return Ok($"Solicitação de alerta para usuário ID {usuario.IdCliente} ({usuario.Nome}) processada, mas nenhum e-mail de contato válido foi encontrado para envio da notificação.");
            }

            string recipientEmail = contatoPrincipal.Email;
            string userName = usuario.Nome; // Ou usuario.Nome + " " + usuario.Sobrenome;
            AlertableEventDto eventDetails = requestDto.EventDetails;

            _logger.LogInformation("Preparando para notificar usuário {UserName} (Email: {RecipientEmail}) sobre o evento: {EventTitle}",
                userName, recipientEmail, eventDetails.Title);

            // TODO: Implementar a chamada real ao IEmailNotificationService aqui
            // try
            // {
            //     await _emailService.SendEventAlertEmailAsync(recipientEmail, userName, eventDetails);
            //     _logger.LogInformation("Notificação de alerta (simulação) encaminhada para {RecipientEmail} sobre o evento {EventId}", recipientEmail, eventDetails.EventId);
            //     return Ok($"Alerta para o evento '{eventDetails.Title}' encaminhado para {userName} ({recipientEmail}).");
            // }
            // catch (Exception ex)
            // {
            //     _logger.LogError(ex, "Falha ao tentar enviar notificação por e-mail para {RecipientEmail} sobre o evento {EventId}.", recipientEmail, eventDetails.EventId);
            //     // Não relançar a exceção necessariamente para não quebrar o fluxo principal,
            //     // mas retornar um erro 500 para indicar que a notificação falhou.
            //     throw new ServicoIndisponivelException("Falha ao processar o envio da notificação por e-mail.", ex);
            // }

            // Resposta de simulação enquanto o serviço de e-mail não está implementado:
            return Ok($"Solicitação de alerta para usuário ID {requestDto.UserId} ({userName}) processada. O envio de e-mail para {recipientEmail} sobre o evento '{eventDetails.Title}' seria realizado aqui.");
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: controller\ClientesController.cs
// Namespace: gsApi.controller
// Tipo: ClientesController
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/controller/ClientesController.cs
using gsApi.data;
using gsApi.dto.request;
using gsApi.dto.response; // Padronizado
using gsApi.DTOs.Response;
using gsApi.model;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;

namespace gsApi.controller
{
    /// <summary>
    /// Gerencia as operações relacionadas a Clientes (Usuários do sistema).
    /// Permite criar, listar, buscar, atualizar e deletar clientes,
    /// bem como gerenciar seus contatos e endereços associados.
    /// </summary>
    [ApiController]
    [Route("api/clientes")]
    [Produces("application/json")]
    [Consumes("application/json")]
    public class ClientesController : ControllerBase
    {
        private readonly ILogger<ClientesController> _logger;
        private readonly AppDbContext _context;

        /// <summary>
        /// Construtor do ClientesController.
        /// </summary>
        /// <param name="logger">Instância do logger para este controller.</param>
        /// <param name="context">Instância do AppDbContext para acesso ao banco de dados.</param>
        public ClientesController(ILogger<ClientesController> logger, AppDbContext context)
        {
            _logger = logger;
            _context = context;
        }

        // Método auxiliar centralizado para mapear Cliente para ClienteResponseDto
        private ClienteResponseDto MapClienteToResponseDto(Cliente cliente)
        {
            if (cliente == null)
            {
                _logger.LogError("Tentativa de mapear um objeto Cliente nulo para ClienteResponseDto.");
                // Em um cenário real, isso não deveria acontecer se o cliente foi buscado corretamente.
                // Lançar exceção ou retornar um DTO com erro pode ser considerado.
                // Por simplicidade, vamos assumir que o chamador garantiu que cliente não é nulo.
                // No entanto, para segurança, vamos lançar ArgumentNullException.
                throw new ArgumentNullException(nameof(cliente), "Objeto Cliente fornecido para mapeamento é nulo.");
            }

            return new ClienteResponseDto
            {
                IdCliente = cliente.IdCliente,
                Nome = cliente.Nome,
                Sobrenome = cliente.Sobrenome,
                DataNascimento = cliente.DataNascimento,
                Documento = cliente.Documento,
                Contatos = cliente.Contatos?.Select(con => new ContatoResponseDto
                {
                    IdContato = con.IdContato,
                    Ddd = con.Ddd,
                    Telefone = con.Telefone,
                    Celular = con.Celular,
                    Whatsapp = con.Whatsapp,
                    Email = con.Email,
                    TipoContato = con.TipoContato
                }).ToList() ?? new List<ContatoResponseDto>(),
                Enderecos = cliente.Enderecos?.Select(end => new EnderecoResponseDto
                {
                    IdEndereco = end.IdEndereco,
                    Cep = end.Cep,
                    Numero = end.Numero,
                    Logradouro = end.Logradouro,
                    Bairro = end.Bairro,
                    Localidade = end.Localidade,
                    Uf = end.Uf,
                    Complemento = end.Complemento, // Complemento é 'required string' no modelo Endereco
                    Latitude = end.Latitude,
                    Longitude = end.Longitude
                }).ToList() ?? new List<EnderecoResponseDto>()
            };
        }

        /// <summary>
        /// Lista todos os clientes de forma paginada e ordenada.
        /// </summary>
        /// <param name="pageNumber">Número da página desejada (padrão: 1).</param>
        /// <param name="pageSize">Quantidade de clientes por página (padrão: 10).</param>
        /// <param name="sortBy">Campo pelo qual os clientes serão ordenados (padrão: "nome"). Outras opções: "documento", "idCliente".</param>
        /// <returns>Uma lista paginada de clientes.</returns>
        /// <response code="200">Retorna a lista paginada de clientes.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor durante a consulta.</response>
        [HttpGet]
        [ProducesResponseType(typeof(PaginatedResponse<ClienteResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> ListarTodosClientes(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 10,
            [FromQuery] string sortBy = "nome")
        {
            _logger.LogInformation("Endpoint GET /api/clientes chamado com pageNumber: {PageNumber}, pageSize: {PageSize}, sortBy: {SortBy}", pageNumber, pageSize, sortBy);

            IQueryable<Cliente> query = _context.Clientes
                                              .Include(c => c.Contatos)
                                              .Include(c => c.Enderecos)
                                              .AsNoTracking();

            switch (sortBy.ToLowerInvariant())
            {
                case "documento":
                    query = query.OrderBy(c => c.Documento);
                    break;
                case "idcliente":
                    query = query.OrderBy(c => c.IdCliente);
                    break;
                case "nome":
                default:
                    query = query.OrderBy(c => c.Nome).ThenBy(c => c.Sobrenome);
                    break;
            }

            var totalCount = await query.CountAsync();
            var clientes = await query.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToListAsync();
            var clientesDto = clientes.Select(MapClienteToResponseDto).ToList();

            var pagedResponse = new PaginatedResponse<ClienteResponseDto>(
                clientesDto,
                totalCount,
                pageNumber,
                pageSize
            );
            return Ok(pagedResponse);
        }

        /// <summary>
        /// Busca um cliente específico pelo seu ID.
        /// </summary>
        /// <param name="id">O ID do cliente a ser buscado.</param>
        /// <returns>O cliente encontrado.</returns>
        /// <response code="200">Retorna o cliente encontrado.</response>
        /// <response code="404">Se o cliente com o ID especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpGet("{id}")]
        [ProducesResponseType(typeof(ClienteResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> BuscarClientePorId(long id)
        {
            _logger.LogInformation("Endpoint GET /api/clientes/{Id} chamado.", id);
            var cliente = await _context.Clientes
                                      .Include(c => c.Contatos)
                                      .Include(c => c.Enderecos)
                                      .AsNoTracking()
                                      .FirstOrDefaultAsync(c => c.IdCliente == id);

            if (cliente == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Cliente com ID {id} não encontrado." });
            }
            return Ok(MapClienteToResponseDto(cliente));
        }

        /// <summary>
        /// Busca as coordenadas principais (latitude e longitude) de um cliente.
        /// </summary>
        /// <param name="id">O ID do cliente.</param>
        /// <returns>As coordenadas do endereço principal do cliente.</returns>
        /// <response code="200">Retorna as coordenadas encontradas.</response>
        /// <response code="404">Se o cliente ou um endereço com coordenadas válidas não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpGet("{id}/coordenadas-principais")]
        [ProducesResponseType(typeof(GeoCoordinatesDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetCoordenadasPrincipaisDoCliente(long id)
        {
            _logger.LogInformation("Buscando coordenadas principais para Cliente ID: {Id}", id);

            var cliente = await _context.Clientes
                                      .Include(c => c.Enderecos)
                                      .AsNoTracking()
                                      .FirstOrDefaultAsync(c => c.IdCliente == id);

            if (cliente == null)
            {
                _logger.LogWarning("Cliente com ID {Id} não encontrado ao buscar coordenadas.", id);
                return NotFound(new ProblemDetails
                {
                    Status = StatusCodes.Status404NotFound,
                    Title = "Usuário não encontrado",
                    Detail = $"Nenhum cliente encontrado com o ID: {id}."
                });
            }

            var enderecoPrincipal = cliente.Enderecos?.FirstOrDefault(e => e.Latitude != 0 || e.Longitude != 0);

            if (enderecoPrincipal == null)
            {
                _logger.LogWarning("Cliente ID {Id} encontrado, mas não possui endereço com coordenadas válidas.", id);
                return NotFound(new ProblemDetails
                {
                    Status = StatusCodes.Status404NotFound,
                    Title = "Coordenadas não encontradas",
                    Detail = $"O cliente com ID {id} não possui um endereço com coordenadas válidas cadastradas."
                });
            }

            var coordenadasDto = new GeoCoordinatesDto
            {
                Latitude = enderecoPrincipal.Latitude,
                Longitude = enderecoPrincipal.Longitude,
                MatchedAddress = $"{enderecoPrincipal.Logradouro}, {enderecoPrincipal.Numero} - {enderecoPrincipal.Bairro}, {enderecoPrincipal.Localidade} - {enderecoPrincipal.Uf}"
            };

            return Ok(coordenadasDto);
        }


        /// <summary>
        /// Busca um cliente pelo seu Documento (CPF/CNPJ).
        /// </summary>
        /// <param name="documento">O número do documento do cliente (CPF ou CNPJ).</param>
        /// <returns>O cliente encontrado.</returns>
        /// <response code="200">Retorna o cliente encontrado.</response>
        /// <response code="404">Se o cliente com o documento especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpGet("documento/{documento}")]
        [ProducesResponseType(typeof(ClienteResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> BuscarClientePorDocumento(string documento)
        {
            _logger.LogInformation("Endpoint GET /api/clientes/documento/{Documento} chamado.", documento);
            var cliente = await _context.Clientes
                                      .Include(c => c.Contatos)
                                      .Include(c => c.Enderecos)
                                      .AsNoTracking()
                                      .FirstOrDefaultAsync(c => c.Documento == documento);

            if (cliente == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Cliente com documento {documento} não encontrado." });
            }
            return Ok(MapClienteToResponseDto(cliente));
        }

        /// <summary>
        /// Cria um novo cliente.
        /// </summary>
        /// <param name="clienteRequestDto">Os dados do cliente a ser criado. Contatos e Endereços podem ser associados via seus IDs.</param>
        /// <returns>O cliente recém-criado.</returns>
        /// <response code="201">Retorna o cliente recém-criado com a localização do recurso.</response>
        /// <response code="400">Se os dados da requisição forem inválidos (ex: documento duplicado, IDs de contato/endereço inválidos).</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpPost]
        [ProducesResponseType(typeof(ClienteResponseDto), StatusCodes.Status201Created)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> CriarCliente([FromBody] ClienteRequestDto clienteRequestDto)
        {
            _logger.LogInformation("Endpoint POST /api/clientes chamado para criar cliente com documento: {Documento}", clienteRequestDto.Documento);
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }

            var existingClienteComDocumento = await _context.Clientes
                                                        .AsNoTracking()
                                                        .FirstOrDefaultAsync(c => c.Documento == clienteRequestDto.Documento);
            if (existingClienteComDocumento != null)
            {
                return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Documento já cadastrado", Detail = $"Já existe um cliente cadastrado com o documento: {clienteRequestDto.Documento}" });
            }

            var novoCliente = new Cliente
            {
                Nome = clienteRequestDto.Nome,
                Sobrenome = clienteRequestDto.Sobrenome,
                DataNascimento = clienteRequestDto.DataNascimento,
                Documento = clienteRequestDto.Documento
                // Contatos e Enderecos são inicializados como new List<T>() no modelo.
            };

            if (clienteRequestDto.ContatosIds != null && clienteRequestDto.ContatosIds.Any())
            {
                var contatosParaAdicionar = await _context.Contatos.Where(con => clienteRequestDto.ContatosIds.Contains(con.IdContato)).ToListAsync();
                if (contatosParaAdicionar.Count != clienteRequestDto.ContatosIds.Distinct().Count())
                {
                    return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Dados inválidos", Detail = "Um ou mais IDs de Contato fornecidos não são válidos ou estão duplicados." });
                }
                novoCliente.Contatos = contatosParaAdicionar;
            }

            if (clienteRequestDto.EnderecosIds != null && clienteRequestDto.EnderecosIds.Any())
            {
                var enderecosParaAdicionar = await _context.Enderecos.Where(end => clienteRequestDto.EnderecosIds.Contains(end.IdEndereco)).ToListAsync();
                if (enderecosParaAdicionar.Count != clienteRequestDto.EnderecosIds.Distinct().Count())
                {
                    return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Dados inválidos", Detail = "Um ou mais IDs de Endereço fornecidos não são válidos ou estão duplicados." });
                }
                novoCliente.Enderecos = enderecosParaAdicionar;
            }

            _context.Clientes.Add(novoCliente);
            await _context.SaveChangesAsync();

            // Recarregar o cliente com os includes para garantir que os DTOs de resposta sejam populados corretamente
            var clienteSalvoComIncludes = await _context.Clientes
                                                  .Include(c => c.Contatos)
                                                  .Include(c => c.Enderecos)
                                                  .FirstAsync(c => c.IdCliente == novoCliente.IdCliente);

            var clienteSalvoDto = MapClienteToResponseDto(clienteSalvoComIncludes);
            return CreatedAtAction(nameof(BuscarClientePorId), new { id = clienteSalvoDto.IdCliente }, clienteSalvoDto);
        }

        /// <summary>
        /// Atualiza um cliente existente.
        /// </summary>
        /// <param name="id">O ID do cliente a ser atualizado.</param>
        /// <param name="clienteRequestDto">Os novos dados para o cliente. Contatos e Endereços podem ser associados/desassociados via seus IDs.</param>
        /// <returns>O cliente atualizado.</returns>
        /// <response code="200">Retorna o cliente atualizado.</response>
        /// <response code="400">Se os dados da requisição forem inválidos (ex: documento duplicado para outro cliente, IDs de contato/endereço inválidos).</response>
        /// <response code="404">Se o cliente com o ID especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpPut("{id}")]
        [ProducesResponseType(typeof(ClienteResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> AtualizarCliente(long id, [FromBody] ClienteRequestDto clienteRequestDto)
        {
            _logger.LogInformation("Endpoint PUT /api/clientes/{Id} chamado.", id);
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }

            var clienteExistente = await _context.Clientes
                                             .Include(c => c.Contatos)
                                             .Include(c => c.Enderecos)
                                             .FirstOrDefaultAsync(c => c.IdCliente == id);

            if (clienteExistente == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Cliente com ID {id} não encontrado." });
            }

            if (clienteExistente.Documento != clienteRequestDto.Documento)
            {
                var outroClienteComMesmoDocumento = await _context.Clientes
                                                                .AsNoTracking()
                                                                .FirstOrDefaultAsync(c => c.Documento == clienteRequestDto.Documento && c.IdCliente != id);
                if (outroClienteComMesmoDocumento != null)
                {
                    return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Documento já cadastrado", Detail = $"Já existe outro cliente cadastrado com o documento: {clienteRequestDto.Documento}" });
                }
            }

            clienteExistente.Nome = clienteRequestDto.Nome;
            clienteExistente.Sobrenome = clienteRequestDto.Sobrenome;
            clienteExistente.DataNascimento = clienteRequestDto.DataNascimento;
            clienteExistente.Documento = clienteRequestDto.Documento;

            // Atualizar Contatos
            clienteExistente.Contatos.Clear(); // Remove associações antigas
            if (clienteRequestDto.ContatosIds != null && clienteRequestDto.ContatosIds.Any())
            {
                var contatosParaAtualizar = await _context.Contatos.Where(con => clienteRequestDto.ContatosIds.Contains(con.IdContato)).ToListAsync();
                if (contatosParaAtualizar.Count != clienteRequestDto.ContatosIds.Distinct().Count())
                {
                    return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Dados inválidos", Detail = "Um ou mais IDs de Contato fornecidos para atualização não são válidos ou estão duplicados." });
                }
                foreach (var contato in contatosParaAtualizar)
                {
                    clienteExistente.Contatos.Add(contato);
                }
            }

            // Atualizar Endereços
            clienteExistente.Enderecos.Clear(); // Remove associações antigas
            if (clienteRequestDto.EnderecosIds != null && clienteRequestDto.EnderecosIds.Any())
            {
                var enderecosParaAtualizar = await _context.Enderecos.Where(end => clienteRequestDto.EnderecosIds.Contains(end.IdEndereco)).ToListAsync();
                if (enderecosParaAtualizar.Count != clienteRequestDto.EnderecosIds.Distinct().Count())
                {
                    return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Dados inválidos", Detail = "Um ou mais IDs de Endereço fornecidos para atualização não são válidos ou estão duplicados." });
                }
                foreach (var endereco in enderecosParaAtualizar)
                {
                    clienteExistente.Enderecos.Add(endereco);
                }
            }

            await _context.SaveChangesAsync();
            return Ok(MapClienteToResponseDto(clienteExistente));
        }

        /// <summary>
        /// Deleta um cliente pelo seu ID, incluindo a remoção de suas associações 
        /// com contatos e endereços nas tabelas de junção.
        /// </summary>
        /// <param name="id">O ID do cliente a ser deletado.</param>
        /// <response code="204">Cliente e suas associações diretas (em tabelas de junção) deletados com sucesso.</response>
        /// <response code="404">Se o cliente com o ID especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor durante o processo de deleção.</response>
        [HttpDelete("{id}")]
        [ProducesResponseType(StatusCodes.Status204NoContent)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> DeletarCliente(long id)
        {
            _logger.LogInformation("Endpoint DELETE /api/clientes/{Id} chamado para deletar cliente e suas associações.", id);

            // Passo 1: Carregar o cliente E suas coleções de Contatos e Enderecos.
            // Isso é crucial para que o EF Core saiba quais registros nas tabelas de junção precisam ser removidos.
            var cliente = await _context.Clientes
                                      .Include(c => c.Contatos)    // Carrega os contatos associados
                                      .Include(c => c.Enderecos)  // Carrega os endereços associados
                                      .FirstOrDefaultAsync(c => c.IdCliente == id);

            if (cliente == null)
            {
                _logger.LogWarning("Cliente com ID {Id} não encontrado para deleção.", id);
                return NotFound(new ProblemDetails { Status = 404, Title = "Recurso não encontrado", Detail = $"Cliente com ID {id} não encontrado." });
            }

            try
            {
                // Passo 2: Limpar as coleções (desassociar)
                // Isso sinaliza ao EF Core para remover as entradas correspondentes das tabelas de junção.
                // Os objetos Contato e Endereco em si NÃO são deletados, apenas a associação com este Cliente.
                cliente.Contatos.Clear();
                cliente.Enderecos.Clear();

                // Passo 3: Salvar as mudanças da desassociação (opcional, mas pode ser feito separadamente para clareza)
                // Se você não salvar aqui, o EF Core tentará fazer tudo em uma transação no próximo SaveChangesAsync.
                // await _context.SaveChangesAsync(); // Descomente se quiser salvar a desassociação separadamente.

                // Passo 4: Remover a entidade Cliente principal
                _context.Clientes.Remove(cliente);

                // Passo 5: Salvar as mudanças finais (remoção do cliente e das entradas nas tabelas de junção)
                await _context.SaveChangesAsync();

                _logger.LogInformation("Cliente com ID {Id} e suas associações foram removidos com sucesso.", id);
                return NoContent();
            }
            catch (DbUpdateException ex) // Captura exceções de atualização do banco
            {
                // Log detalhado do erro, incluindo a inner exception que geralmente tem a mensagem do Oracle
                _logger.LogError(ex, "Erro de atualização do banco ao deletar cliente ID {Id}. Detalhes: {ErrorMessage}", id, ex.InnerException?.Message ?? ex.Message);

                // Retorna um erro 500 genérico, pois o TratadorGlobalExcecoesMiddleware também pegaria,
                // mas aqui podemos ser um pouco mais específicos se quisermos.
                return StatusCode(StatusCodes.Status500InternalServerError, new ProblemDetails
                {
                    Title = "Erro ao deletar cliente",
                    Detail = "Ocorreu um erro ao tentar deletar o cliente e/ou suas associações. " +
                             "Verifique se ele não possui outras dependências não resolvidas no banco de dados. " +
                             "Detalhe do erro original: " + (ex.InnerException?.Message ?? ex.Message)
                });
            }
        }

        /// <summary>
        /// Pesquisa clientes por nome, sobrenome ou documento.
        /// </summary>
        /// <param name="termo">Termo para buscar no nome, sobrenome ou documento do cliente.</param>
        /// <param name="pageNumber">Número da página (padrão: 1).</param>
        /// <param name="pageSize">Quantidade de clientes por página (padrão: 10).</param>
        /// <param name="sortBy">Campo pelo qual os clientes serão ordenados (padrão: "nome").</param>
        /// <returns>Uma lista paginada de clientes que correspondem ao termo de pesquisa.</returns>
        /// <response code="200">Retorna a lista paginada de clientes encontrados.</response>
        /// <response code="400">Se o termo de pesquisa for nulo ou vazio.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpGet("pesquisar")]
        [ProducesResponseType(typeof(PaginatedResponse<ClienteResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> PesquisarClientes(
            [FromQuery, Required(ErrorMessage = "O termo de pesquisa é obrigatório.")] string termo,
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 10,
            [FromQuery] string sortBy = "nome")
        {
            _logger.LogInformation("Endpoint GET /api/clientes/pesquisar chamado com termo: {Termo}, pageNumber: {PageNumber}, pageSize: {PageSize}, sortBy: {SortBy}", termo, pageNumber, pageSize, sortBy);

            if (string.IsNullOrWhiteSpace(termo)) // Validação extra, embora [Required] já atue.
            {
                return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Termo de pesquisa inválido", Detail = "O termo de pesquisa não pode ser vazio." });
            }

            IQueryable<Cliente> query = _context.Clientes
                                .Include(c => c.Contatos)
                                .Include(c => c.Enderecos)
                                .Where(c => EF.Functions.Like(c.Nome, $"%{termo}%") ||
                                            EF.Functions.Like(c.Sobrenome, $"%{termo}%") ||
                                            EF.Functions.Like(c.Documento, $"%{termo}%"))
                                .AsNoTracking();

            switch (sortBy.ToLowerInvariant())
            {
                case "documento":
                    query = query.OrderBy(c => c.Documento);
                    break;
                case "idcliente":
                    query = query.OrderBy(c => c.IdCliente);
                    break;
                case "nome":
                default:
                    query = query.OrderBy(c => c.Nome).ThenBy(c => c.Sobrenome);
                    break;
            }

            var totalCount = await query.CountAsync();
            var clientes = await query.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToListAsync();
            var clientesDto = clientes.Select(MapClienteToResponseDto).ToList();

            var pagedResponse = new PaginatedResponse<ClienteResponseDto>(
                clientesDto,
                totalCount,
                pageNumber,
                pageSize
            );
            return Ok(pagedResponse);
        }
    }

    // DTO auxiliar para respostas paginadas (pode ser movido para um arquivo separado em dto/response)
    public class PaginatedResponse<T>
    {
        public List<T> Content { get; set; }
        public long TotalElements { get; set; }
        public int PageNumber { get; set; }
        public int PageSize { get; set; }
        public int TotalPages { get; set; }

        public PaginatedResponse(List<T> content, long totalElements, int pageNumber, int pageSize)
        {
            Content = content;
            TotalElements = totalElements;
            PageNumber = pageNumber;
            PageSize = pageSize;
            TotalPages = (int)Math.Ceiling(totalElements / (double)pageSize);
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: controller\ContatosController .cs
// Namespace: gsApi.controller
// Tipo: ContatosController
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/controller/ContatosController.cs
using gsApi.data;
using gsApi.dto.request;
using gsApi.dto.response;
using gsApi.DTOs.Request;
using gsApi.model;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;

namespace gsApi.controller
{
    /// <summary>
    /// Gerencia as operações CRUD para Contatos de usuários.
    /// Permite criar, listar, buscar, atualizar e deletar contatos.
    /// </summary>
    [ApiController]
    [Route("api/contatos")]
    [Produces("application/json")]
    [Consumes("application/json")]
    public class ContatosController : ControllerBase
    {
        private readonly ILogger<ContatosController> _logger;
        private readonly AppDbContext _context;

        /// <summary>
        /// Construtor do ContatosController.
        /// </summary>
        /// <param name="logger">Instância do logger para este controller.</param>
        /// <param name="context">Instância do AppDbContext para acesso ao banco de dados.</param>
        public ContatosController(ILogger<ContatosController> logger, AppDbContext context)
        {
            _logger = logger;
            _context = context;
        }

        // Método auxiliar para mapear Contato para ContatoResponseDto
        private ContatoResponseDto MapContatoToResponseDto(Contato contato)
        {
            return new ContatoResponseDto
            {
                IdContato = contato.IdContato,
                Ddd = contato.Ddd,
                Telefone = contato.Telefone,
                Celular = contato.Celular,
                Whatsapp = contato.Whatsapp,
                Email = contato.Email,
                TipoContato = contato.TipoContato
            };
        }

        /// <summary>
        /// Lista todos os contatos de forma paginada e ordenada.
        /// </summary>
        /// <param name="pageNumber">Número da página desejada (padrão: 1).</param>
        /// <param name="pageSize">Quantidade de contatos por página (padrão: 10).</param>
        /// <param name="sortBy">Campo pelo qual os contatos serão ordenados (padrão: "email"). Outra opção: "idContato".</param>
        /// <returns>Uma lista paginada de contatos.</returns>
        /// <response code="200">Retorna a lista paginada de contatos.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor durante a consulta.</response>
        [HttpGet]
        [ProducesResponseType(typeof(PaginatedResponse<ContatoResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> ListarTodosContatos(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 10,
            [FromQuery] string sortBy = "email")
        {
            _logger.LogInformation("Endpoint GET /api/contatos chamado com pageNumber: {PageNumber}, pageSize: {PageSize}, sortBy: {SortBy}", pageNumber, pageSize, sortBy);

            IQueryable<Contato> query = _context.Contatos.AsNoTracking();

            switch (sortBy.ToLowerInvariant())
            {
                case "idcontato":
                    query = query.OrderBy(c => c.IdContato);
                    break;
                case "email":
                default:
                    query = query.OrderBy(c => c.Email);
                    break;
            }

            var totalCount = await query.CountAsync();
            var items = await query
                              .Skip((pageNumber - 1) * pageSize)
                              .Take(pageSize)
                              .ToListAsync();

            var contatosDto = items.Select(MapContatoToResponseDto).ToList();

            var pagedResponse = new PaginatedResponse<ContatoResponseDto>(
                contatosDto,
                totalCount,
                pageNumber,
                pageSize
            );
            return Ok(pagedResponse);
        }

        /// <summary>
        /// Busca um contato específico pelo seu ID.
        /// </summary>
        /// <param name="id">O ID do contato a ser buscado.</param>
        /// <returns>O contato encontrado.</returns>
        /// <response code="200">Retorna o contato encontrado.</response>
        /// <response code="404">Se o contato com o ID especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpGet("{id}")]
        [ProducesResponseType(typeof(ContatoResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> BuscarContatoPorId(long id)
        {
            _logger.LogInformation("Endpoint GET /api/contatos/{Id} chamado.", id);
            var contato = await _context.Contatos.AsNoTracking().FirstOrDefaultAsync(c => c.IdContato == id);

            if (contato == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Contato com ID {id} não encontrado." });
            }
            return Ok(MapContatoToResponseDto(contato));
        }

        /// <summary>
        /// Busca um contato pelo seu endereço de e-mail.
        /// </summary>
        /// <param name="email">O endereço de e-mail do contato a ser buscado.</param>
        /// <returns>O contato encontrado.</returns>
        /// <response code="200">Retorna o contato encontrado.</response>
        /// <response code="404">Se o contato com o e-mail especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpGet("email/{email}")]
        [ProducesResponseType(typeof(ContatoResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> BuscarContatoPorEmail(string email)
        {
            _logger.LogInformation("Endpoint GET /api/contatos/email/{Email} chamado.", email);
            var contato = await _context.Contatos.AsNoTracking().FirstOrDefaultAsync(c => c.Email == email);

            if (contato == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Contato com email {email} não encontrado." });
            }
            return Ok(MapContatoToResponseDto(contato));
        }

        /// <summary>
        /// Cria um novo contato.
        /// </summary>
        /// <param name="contatoRequestDto">Os dados do contato a ser criado.</param>
        /// <returns>O contato recém-criado.</returns>
        /// <response code="201">Retorna o contato recém-criado com a localização do recurso.</response>
        /// <response code="400">Se os dados da requisição forem inválidos (ex: e-mail duplicado).</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpPost]
        [ProducesResponseType(typeof(ContatoResponseDto), StatusCodes.Status201Created)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)] // Para erros de validação do DTO
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)] // Para erro de e-mail duplicado
        public async Task<IActionResult> CriarContato([FromBody] ContatoRequestDto contatoRequestDto)
        {
            _logger.LogInformation("Endpoint POST /api/contatos chamado para criar contato com email: {Email}", contatoRequestDto.Email);
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }

            var existingContactComEmail = await _context.Contatos
                                                .AsNoTracking()
                                                .FirstOrDefaultAsync(c => c.Email == contatoRequestDto.Email);
            if (existingContactComEmail != null)
            {
                _logger.LogWarning("Tentativa de criar contato com e-mail já existente: {Email}", contatoRequestDto.Email);
                return BadRequest(new ProblemDetails
                {
                    Status = StatusCodes.Status400BadRequest,
                    Title = "E-mail já cadastrado",
                    Detail = $"Já existe um contato cadastrado com o e-mail: {contatoRequestDto.Email}"
                });
            }

            var novoContato = new Contato
            {
                Ddd = contatoRequestDto.Ddd,
                Telefone = contatoRequestDto.Telefone,
                Celular = contatoRequestDto.Celular,
                Whatsapp = contatoRequestDto.Whatsapp,
                Email = contatoRequestDto.Email,
                TipoContato = contatoRequestDto.TipoContato
            };

            _context.Contatos.Add(novoContato);
            await _context.SaveChangesAsync();

            var contatoSalvoDto = MapContatoToResponseDto(novoContato);
            _logger.LogInformation("Contato com ID {IdContato} e Email {Email} criado com sucesso.", novoContato.IdContato, novoContato.Email);
            return CreatedAtAction(nameof(BuscarContatoPorId), new { id = contatoSalvoDto.IdContato }, contatoSalvoDto);
        }

        /// <summary>
        /// Atualiza um contato existente.
        /// </summary>
        /// <param name="id">O ID do contato a ser atualizado.</param>
        /// <param name="contatoRequestDto">Os novos dados para o contato.</param>
        /// <returns>O contato atualizado.</returns>
        /// <response code="200">Retorna o contato atualizado.</response>
        /// <response code="400">Se os dados da requisição forem inválidos (ex: novo e-mail já existe em outro contato).</response>
        /// <response code="404">Se o contato com o ID especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpPut("{id}")]
        [ProducesResponseType(typeof(ContatoResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)] // Para e-mail duplicado
        public async Task<IActionResult> AtualizarContato(long id, [FromBody] ContatoRequestDto contatoRequestDto)
        {
            _logger.LogInformation("Endpoint PUT /api/contatos/{Id} chamado.", id);
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }

            var contatoExistente = await _context.Contatos.FirstOrDefaultAsync(c => c.IdContato == id);
            if (contatoExistente == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Contato com ID {id} não encontrado para atualização." });
            }

            // Verificar se o novo e-mail já existe em OUTRO contato
            if (contatoExistente.Email != contatoRequestDto.Email)
            {
                var outroContatoComEmail = await _context.Contatos
                                                    .AsNoTracking()
                                                    .FirstOrDefaultAsync(c => c.Email == contatoRequestDto.Email && c.IdContato != id);
                if (outroContatoComEmail != null)
                {
                    return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "E-mail já cadastrado", Detail = $"Já existe outro contato cadastrado com o e-mail: {contatoRequestDto.Email}" });
                }
            }

            contatoExistente.Ddd = contatoRequestDto.Ddd;
            contatoExistente.Telefone = contatoRequestDto.Telefone;
            contatoExistente.Celular = contatoRequestDto.Celular;
            contatoExistente.Whatsapp = contatoRequestDto.Whatsapp;
            contatoExistente.Email = contatoRequestDto.Email;
            contatoExistente.TipoContato = contatoRequestDto.TipoContato;

            await _context.SaveChangesAsync();
            return Ok(MapContatoToResponseDto(contatoExistente));
        }

        /// <summary>
        /// Deleta um contato pelo seu ID.
        /// </summary>
        /// <param name="id">O ID do contato a ser deletado.</param>
        /// <response code="204">Contato deletado com sucesso.</response>
        /// <response code="404">Se o contato com o ID especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpDelete("{id}")]
        [ProducesResponseType(StatusCodes.Status204NoContent)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> DeletarContato(long id)
        {
            _logger.LogInformation("Endpoint DELETE /api/contatos/{Id} chamado.", id);
            var contato = await _context.Contatos.FindAsync(id);
            if (contato == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Contato com ID {id} não encontrado para deleção." });
            }

            // Antes de remover, precisamos desassociar dos clientes para evitar erro de FK se a relação for obrigatória em Cliente.
            // O EF Core geralmente lida com isso para tabelas de junção, mas é uma boa prática ser explícito ou garantir o comportamento.
            // No DDL, as FKs em TB_CLIENTECONTATO3 não têm ON DELETE CASCADE, então o EF Core deve remover as entradas da tabela de junção.
            _context.Contatos.Remove(contato);
            await _context.SaveChangesAsync();

            return NoContent();
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: controller\EnderecosController .cs
// Namespace: gsApi.controller
// Tipo: EnderecosController
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/controller/EnderecosController.cs
using gsApi.data;
using gsApi.dto.request;
using gsApi.dto.response;
using gsApi.DTOs.Request;
using gsApi.DTOs.Response;
using gsApi.exceptions;
using gsApi.Exceptions;
using gsApi.model;
using gsApi.services;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;

namespace gsApi.controller
{
    /// <summary>
    /// Gerencia as operações relacionadas a Endereços, incluindo consulta a serviços externos como ViaCEP e Google Geocoding.
    /// </summary>
    [ApiController]
    [Route("api/enderecos")]
    [Produces("application/json")]
    [Consumes("application/json")]
    public class EnderecosController : ControllerBase
    {
        private readonly ILogger<EnderecosController> _logger;
        private readonly AppDbContext _context;
        private readonly IViaCepClient _viaCepClient;
        private readonly IGeoCodingClient _geoCodingClient;

        /// <summary>
        /// Construtor do EnderecosController.
        /// </summary>
        public EnderecosController(
            ILogger<EnderecosController> logger,
            AppDbContext context,
            IViaCepClient viaCepClient,
            IGeoCodingClient geoCodingClient)
        {
            _logger = logger;
            _context = context;
            _viaCepClient = viaCepClient;
            _geoCodingClient = geoCodingClient;
        }

        private EnderecoResponseDto MapEnderecoToResponseDto(Endereco endereco)
        {
            return new EnderecoResponseDto
            {
                IdEndereco = endereco.IdEndereco,
                Cep = endereco.Cep,
                Numero = endereco.Numero,
                Logradouro = endereco.Logradouro,
                Bairro = endereco.Bairro,
                Localidade = endereco.Localidade,
                Uf = endereco.Uf,
                Complemento = endereco.Complemento,
                Latitude = endereco.Latitude,
                Longitude = endereco.Longitude
            };
        }

        /// <summary>
        /// Lista todos os endereços cadastrados de forma paginada.
        /// </summary>
        /// <param name="pageNumber">Número da página (padrão: 1).</param>
        /// <param name="pageSize">Quantidade de itens por página (padrão: 10).</param>
        /// <param name="sortBy">Campo para ordenação (padrão: "cep"). Opções: "localidade", "idEndereco".</param>
        /// <returns>Uma lista paginada de endereços.</returns>
        /// <response code="200">Retorna a lista paginada de endereços.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpGet]
        [ProducesResponseType(typeof(PaginatedResponse<EnderecoResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> ListarTodosEnderecos(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 10,
            [FromQuery] string sortBy = "cep")
        {
            _logger.LogInformation("Endpoint GET /api/enderecos chamado. PageNumber: {PageNumber}, PageSize: {PageSize}, SortBy: {SortBy}", pageNumber, pageSize, sortBy);

            IQueryable<Endereco> query = _context.Enderecos.AsNoTracking();

            switch (sortBy.ToLowerInvariant())
            {
                case "localidade":
                    query = query.OrderBy(e => e.Localidade);
                    break;
                case "idendereco":
                    query = query.OrderBy(e => e.IdEndereco);
                    break;
                case "cep":
                default:
                    query = query.OrderBy(e => e.Cep);
                    break;
            }

            var totalCount = await query.CountAsync();
            var items = await query
                              .Skip((pageNumber - 1) * pageSize)
                              .Take(pageSize)
                              .ToListAsync();

            var enderecosDto = items.Select(MapEnderecoToResponseDto).ToList();
            var pagedResponse = new PaginatedResponse<EnderecoResponseDto>(enderecosDto, totalCount, pageNumber, pageSize);
            return Ok(pagedResponse);
        }

        /// <summary>
        /// Busca um endereço específico pelo seu ID.
        /// </summary>
        /// <param name="id">O ID do endereço a ser buscado.</param>
        /// <returns>O endereço encontrado.</returns>
        /// <response code="200">Retorna o endereço encontrado.</response>
        /// <response code="404">Se o endereço com o ID especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpGet("{id}")]
        [ProducesResponseType(typeof(EnderecoResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> BuscarEnderecoPorId(long id)
        {
            _logger.LogInformation("Endpoint GET /api/enderecos/{Id} chamado.", id);
            var endereco = await _context.Enderecos.AsNoTracking().FirstOrDefaultAsync(e => e.IdEndereco == id);

            if (endereco == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Endereço com ID {id} não encontrado." });
            }
            return Ok(MapEnderecoToResponseDto(endereco));
        }

        /// <summary>
        /// Consulta dados de um endereço a partir de um CEP utilizando o serviço ViaCEP.
        /// </summary>
        /// <param name="cep">O CEP a ser consultado (deve estar no formato XXXXXXXX ou XXXXX-XXX).</param>
        /// <returns>Os dados do endereço correspondente ao CEP, se encontrado.</returns>
        /// <response code="200">Dados do CEP encontrados e retornados com sucesso.</response>
        /// <response code="400">Se o formato do CEP fornecido for inválido (conforme validação do [RegularExpression]).</response>
        /// <response code="404">Se o CEP não for encontrado no serviço ViaCEP ou se for considerado inválido pelo serviço.</response>
        /// <response code="503">Se o serviço ViaCEP estiver indisponível ou ocorrer um erro na comunicação.</response>
        [HttpGet("consultar-cep/{cep}")]
        [ProducesResponseType(typeof(ViaCepResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status503ServiceUnavailable)]
        public async Task<IActionResult> ConsultarCep(
            [FromRoute][RegularExpression(@"^\d{5}-?\d{3}$", ErrorMessage = "O formato do CEP é inválido. Use XXXXXXXX ou XXXXX-XXX.")] string cep)
        {
            _logger.LogInformation("ENDERECOS_CONTROLLER: Endpoint GET /api/enderecos/consultar-cep/{Cep} chamado.", cep);

            try
            {
                var enderecoViaCep = await _viaCepClient.GetEnderecoByCepAsync(cep);

                if (enderecoViaCep == null)
                {
                    _logger.LogWarning("ENDERECOS_CONTROLLER: Consulta ao ViaCEP para o CEP '{Cep}' não retornou dados ou CEP não encontrado pelo ViaCepClient.", cep);
                    return NotFound(new ProblemDetails
                    {
                        Status = StatusCodes.Status404NotFound,
                        Title = "CEP não encontrado",
                        Detail = $"O CEP '{cep}' não foi encontrado ou é inválido."
                    });
                }

                _logger.LogInformation("ENDERECOS_CONTROLLER: Dados do CEP '{Cep}' obtidos com sucesso.", cep);
                return Ok(enderecoViaCep);
            }
            catch (ServicoIndisponivelException ex)
            {
                _logger.LogError(ex, "ENDERECOS_CONTROLLER: ServicoIndisponivelException ao consultar CEP '{Cep}'. Mensagem: {ExceptionMessage}", cep, ex.Message);
                return StatusCode(StatusCodes.Status503ServiceUnavailable, new ProblemDetails
                {
                    Status = StatusCodes.Status503ServiceUnavailable,
                    Title = "Serviço ViaCEP indisponível",
                    Detail = ex.Message
                });
            }
        }

        /// <summary>
        /// Calcula as coordenadas geográficas (latitude e longitude) para um endereço.
        /// </summary>
        /// <param name="enderecoGeoRequestDto">Dados do endereço para geocodificação (Logradouro, Cidade, UF são obrigatórios).</param>
        /// <returns>As coordenadas geográficas calculadas.</returns>
        /// <response code="200">Coordenadas calculadas com sucesso.</response>
        /// <response code="400">Se os dados de entrada para geocodificação forem inválidos.</response>
        /// <response code="404">Se não for possível encontrar coordenadas para o endereço fornecido.</response>
        /// <response code="500">Se ocorrer um erro de configuração interna (ex: API Key do Google não configurada).</response>
        /// <response code="503">Se o serviço de geocodificação estiver indisponível.</response>
        [HttpPost("calcular-coordenadas")]
        [ProducesResponseType(typeof(GeoCoordinatesDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status503ServiceUnavailable)]
        public async Task<IActionResult> CalcularCoordenadas([FromBody] EnderecoGeoRequestDto enderecoGeoRequestDto)
        {
            _logger.LogInformation("Endpoint POST /api/enderecos/calcular-coordenadas chamado para: {Logradouro}, {Cidade}, {UF}",
                enderecoGeoRequestDto.Logradouro, enderecoGeoRequestDto.Cidade, enderecoGeoRequestDto.Uf);
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }
            try
            {
                var coordenadas = await _geoCodingClient.GetCoordinatesFromAddressAsync(enderecoGeoRequestDto);
                if (coordenadas == null)
                {
                    return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Coordenadas não encontradas", Detail = "Não foi possível encontrar coordenadas para o endereço fornecido." });
                }
                return Ok(coordenadas);
            }
            catch (ServicoIndisponivelException ex)
            {
                _logger.LogError(ex, "Erro ao calcular coordenadas para o endereço: {Logradouro}, {Cidade}", enderecoGeoRequestDto.Logradouro, enderecoGeoRequestDto.Cidade);
                return StatusCode(StatusCodes.Status503ServiceUnavailable, new ProblemDetails { Status = StatusCodes.Status503ServiceUnavailable, Title = "Serviço de Geocodificação indisponível", Detail = ex.Message });
            }
            catch (InvalidOperationException ex) // Captura específica para API Key não configurada no GeoCodingClient
            {
                _logger.LogError(ex, "Erro de configuração ao calcular coordenadas (API Key ausente?): {Message}", ex.Message);
                return StatusCode(StatusCodes.Status500InternalServerError, new ProblemDetails { Status = StatusCodes.Status500InternalServerError, Title = "Erro de configuração interna", Detail = "Não foi possível calcular as coordenadas devido a um erro de configuração do serviço de geocodificação." });
            }
        }

        /// <summary>
        /// Cria um novo endereço. Requer que latitude e longitude sejam fornecidas.
        /// </summary>
        /// <param name="enderecoRequestDto">Os dados do endereço a ser criado.</param>
        /// <returns>O endereço recém-criado.</returns>
        /// <response code="201">Retorna o endereço recém-criado com a localização do recurso.</response>
        /// <response code="400">Se os dados da requisição forem inválidos.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpPost]
        [ProducesResponseType(typeof(EnderecoResponseDto), StatusCodes.Status201Created)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> CriarEndereco([FromBody] EnderecoRequestDto enderecoRequestDto)
        {
            _logger.LogInformation("Endpoint POST /api/enderecos chamado para criar endereço com CEP: {Cep}", enderecoRequestDto.Cep);
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }

            var novoEndereco = new Endereco
            {
                Cep = new string(enderecoRequestDto.Cep.Where(char.IsDigit).ToArray()),
                Numero = enderecoRequestDto.Numero,
                Logradouro = enderecoRequestDto.Logradouro,
                Bairro = enderecoRequestDto.Bairro,
                Localidade = enderecoRequestDto.Localidade,
                Uf = enderecoRequestDto.Uf.ToUpper(),
                Complemento = enderecoRequestDto.Complemento,
                Latitude = enderecoRequestDto.Latitude,
                Longitude = enderecoRequestDto.Longitude
            };

            _context.Enderecos.Add(novoEndereco);
            await _context.SaveChangesAsync();

            var enderecoSalvoDto = MapEnderecoToResponseDto(novoEndereco);
            return CreatedAtAction(nameof(BuscarEnderecoPorId), new { id = enderecoSalvoDto.IdEndereco }, enderecoSalvoDto);
        }

        /// <summary>
        /// Atualiza um endereço existente.
        /// </summary>
        /// <param name="id">O ID do endereço a ser atualizado.</param>
        /// <param name="enderecoRequestDto">Os novos dados para o endereço.</param>
        /// <returns>O endereço atualizado.</returns>
        /// <response code="200">Retorna o endereço atualizado.</response>
        /// <response code="400">Se os dados da requisição forem inválidos.</response>
        /// <response code="404">Se o endereço com o ID especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor.</response>
        [HttpPut("{id}")]
        [ProducesResponseType(typeof(EnderecoResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> AtualizarEndereco(long id, [FromBody] EnderecoRequestDto enderecoRequestDto)
        {
            _logger.LogInformation("Endpoint PUT /api/enderecos/{Id} chamado.", id);
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }

            var enderecoExistente = await _context.Enderecos.FirstOrDefaultAsync(e => e.IdEndereco == id);
            if (enderecoExistente == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Endereço com ID {id} não encontrado." });
            }

            enderecoExistente.Cep = new string(enderecoRequestDto.Cep.Where(char.IsDigit).ToArray());
            enderecoExistente.Numero = enderecoRequestDto.Numero;
            enderecoExistente.Logradouro = enderecoRequestDto.Logradouro;
            enderecoExistente.Bairro = enderecoRequestDto.Bairro;
            enderecoExistente.Localidade = enderecoRequestDto.Localidade;
            enderecoExistente.Uf = enderecoRequestDto.Uf.ToUpper();
            enderecoExistente.Complemento = enderecoRequestDto.Complemento;
            enderecoExistente.Latitude = enderecoRequestDto.Latitude;
            enderecoExistente.Longitude = enderecoRequestDto.Longitude;

            await _context.SaveChangesAsync();
            return Ok(MapEnderecoToResponseDto(enderecoExistente));
        }

        /// <summary>
        /// Deleta um endereço pelo seu ID.
        /// </summary>
        /// <param name="id">O ID do endereço a ser deletado.</param>
        /// <response code="204">Endereço deletado com sucesso.</response>
        /// <response code="404">Se o endereço com o ID especificado não for encontrado.</response>
        /// <response code="500">Se ocorrer um erro interno no servidor (ex: violação de chave estrangeira se o endereço estiver em uso).</response>
        [HttpDelete("{id}")]
        [ProducesResponseType(StatusCodes.Status204NoContent)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> DeletarEndereco(long id)
        {
            _logger.LogInformation("Endpoint DELETE /api/enderecos/{Id} chamado.", id);
            var endereco = await _context.Enderecos.FindAsync(id);
            if (endereco == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Endereço com ID {id} não encontrado." });
            }

            _context.Enderecos.Remove(endereco);
            await _context.SaveChangesAsync();
            return NoContent();
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: controller\EonetController.cs
// Namespace: gsApi.controller
// Tipo: EonetController
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/controller/EonetController.cs
using gsApi.data;
using gsApi.dto.request;
using gsApi.dto.response;
using gsApi.DTOs.Request;

using gsApi.DTOs.Response;

// Removidos usings duplicados para gsApi.DTOs... se gsApi.dto... já cobre
using gsApi.exceptions; // Para ServicoIndisponivelException
using gsApi.Exceptions;
using gsApi.model;
using gsApi.model.DTOs.Response;
using gsApi.services; // Para INasaEonetClient
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;

namespace gsApi.controller
{
    /// <summary>
    /// Gerencia eventos EONET, incluindo sincronização com a NASA e buscas locais.
    /// </summary>
    [ApiController]
    [Route("api/eonet")]
    [Produces("application/json")]
    [Consumes("application/json")]
    public class EonetController : ControllerBase
    {
        private readonly ILogger<EonetController> _logger;
        private readonly AppDbContext _context;
        private readonly INasaEonetClient _nasaEonetClient;

        public EonetController(ILogger<EonetController> logger, AppDbContext context, INasaEonetClient nasaEonetClient)
        {
            _logger = logger;
            _context = context;
            _nasaEonetClient = nasaEonetClient;
        }

        /// <summary>
        /// Lista todos os eventos EONET armazenados localmente, de forma paginada.
        /// </summary>
        [HttpGet]
        [ProducesResponseType(typeof(object), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> ListarTodosEventosEonetLocalmente(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 10,
            [FromQuery] string sortBy = "data",
            [FromQuery] string sortDirection = "desc")
        {
            _logger.LogInformation("Endpoint GET /api/eonet (listar locais) chamado com pageNumber: {PageNumber}, pageSize: {PageSize}, sortBy: {SortBy}, sortDirection: {SortDirection}",
                pageNumber, pageSize, sortBy, sortDirection);

            IQueryable<EonetEvent> query = _context.EonetEvents.AsNoTracking();

            bool descending = sortDirection.Equals("desc", StringComparison.OrdinalIgnoreCase);
            switch (sortBy.ToLowerInvariant())
            {
                case "eonetidapi":
                    query = descending ? query.OrderByDescending(e => e.EonetIdApi) : query.OrderBy(e => e.EonetIdApi);
                    break;
                case "data":
                default:
                    query = descending ? query.OrderByDescending(e => e.Data) : query.OrderBy(e => e.Data);
                    break;
            }

            var totalCount = await query.CountAsync();
            var items = await query
                              .Skip((pageNumber - 1) * pageSize)
                              .Take(pageSize)
                              .ToListAsync();

            var eventosDto = items.Select(e => new EonetResponseDto
            {
                IdEonet = e.IdEonet,
                EonetIdApi = e.EonetIdApi,
                Data = e.Data, // Agora DateTime?
                Json = e.Json
            }).ToList();

            var pagedResponse = new { Content = eventosDto, TotalElements = totalCount, PageNumber = pageNumber, PageSize = pageSize, TotalPages = (int)Math.Ceiling(totalCount / (double)pageSize) };
            return Ok(pagedResponse);
        }

        /// <summary>
        /// Busca um evento EONET armazenado localmente pelo seu ID interno.
        /// </summary>
        [HttpGet("{idInterno}")]
        [ProducesResponseType(typeof(EonetResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> BuscarEventoLocalPorIdInterno(long idInterno)
        {
            _logger.LogInformation("Endpoint GET /api/eonet/{IdInterno} chamado.", idInterno);
            var evento = await _context.EonetEvents.AsNoTracking().FirstOrDefaultAsync(e => e.IdEonet == idInterno);

            if (evento == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Evento EONET local com ID interno {idInterno} não encontrado." });
            }
            var eventoDto = new EonetResponseDto
            {
                IdEonet = evento.IdEonet,
                EonetIdApi = evento.EonetIdApi,
                Data = evento.Data, // Agora DateTime?
                Json = evento.Json
            };
            return Ok(eventoDto);
        }

        /// <summary>
        /// Busca um evento EONET armazenado localmente pelo ID da API da NASA.
        /// </summary>
        [HttpGet("api-id/{eonetApiId}")]
        [ProducesResponseType(typeof(EonetResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> BuscarEventoLocalPorEonetApiId(string eonetApiId)
        {
            _logger.LogInformation("Endpoint GET /api/eonet/api-id/{EonetApiId} chamado.", eonetApiId);
            var evento = await _context.EonetEvents.AsNoTracking().FirstOrDefaultAsync(e => e.EonetIdApi == eonetApiId);

            if (evento == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Evento EONET local com ID da API {eonetApiId} não encontrado." });
            }
            var eventoDto = new EonetResponseDto
            {
                IdEonet = evento.IdEonet,
                EonetIdApi = evento.EonetIdApi,
                Data = evento.Data, // Agora DateTime?
                Json = evento.Json
            };
            return Ok(eventoDto);
        }

        /// <summary>
        /// Salva manualmente um novo evento EONET no banco de dados local.
        /// </summary>
        [HttpPost]
        [ProducesResponseType(typeof(EonetResponseDto), StatusCodes.Status201Created)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> SalvarEventoEonetManualmente([FromBody] EonetRequestDto eonetRequestDto)
        {
            _logger.LogInformation("Endpoint POST /api/eonet (salvar manual) chamado para EonetIdApi: {EonetIdApi}", eonetRequestDto.EonetIdApi);
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }

            if (await _context.EonetEvents.AnyAsync(e => e.EonetIdApi == eonetRequestDto.EonetIdApi))
            {
                return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Requisição inválida", Detail = $"Já existe um evento EONET registrado com o API ID: {eonetRequestDto.EonetIdApi}" });
            }

            var novoEvento = new EonetEvent
            {
                EonetIdApi = eonetRequestDto.EonetIdApi,
                // EonetRequestDto.Data é DateTimeOffset. Convertendo para DateTime (UTC).
                Data = eonetRequestDto.Data.UtcDateTime,
                Json = eonetRequestDto.Json
            };

            _context.EonetEvents.Add(novoEvento);
            await _context.SaveChangesAsync();

            var eventoSalvoDto = new EonetResponseDto
            {
                IdEonet = novoEvento.IdEonet,
                EonetIdApi = novoEvento.EonetIdApi,
                Data = novoEvento.Data, // Agora DateTime?
                Json = novoEvento.Json // Ou "(Conteúdo JSON salvo)" para não retornar o JSON inteiro
            };
            return CreatedAtAction(nameof(BuscarEventoLocalPorIdInterno), new { idInterno = eventoSalvoDto.IdEonet }, eventoSalvoDto);
        }

        /// <summary>
        /// Atualiza manualmente um evento EONET existente no banco de dados local.
        /// </summary>
        [HttpPut("{idInterno}")]
        [ProducesResponseType(typeof(EonetResponseDto), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ValidationProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> AtualizarEventoEonetManualmente(long idInterno, [FromBody] EonetRequestDto eonetRequestDto)
        {
            _logger.LogInformation("Endpoint PUT /api/eonet/{IdInterno} (atualizar manual) chamado.", idInterno);
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }

            var eventoExistente = await _context.EonetEvents.FirstOrDefaultAsync(e => e.IdEonet == idInterno);
            if (eventoExistente == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Evento EONET local com ID interno {idInterno} não encontrado." });
            }

            if (eventoExistente.EonetIdApi != eonetRequestDto.EonetIdApi &&
                await _context.EonetEvents.AnyAsync(e => e.EonetIdApi == eonetRequestDto.EonetIdApi && e.IdEonet != idInterno))
            {
                return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Requisição inválida", Detail = $"Já existe outro evento EONET registrado com o API ID: {eonetRequestDto.EonetIdApi}" });
            }

            eventoExistente.EonetIdApi = eonetRequestDto.EonetIdApi;
            // EonetRequestDto.Data é DateTimeOffset. Convertendo para DateTime (UTC).
            eventoExistente.Data = eonetRequestDto.Data.UtcDateTime;
            eventoExistente.Json = eonetRequestDto.Json;

            await _context.SaveChangesAsync();

            var eventoAtualizadoDto = new EonetResponseDto
            {
                IdEonet = eventoExistente.IdEonet,
                EonetIdApi = eventoExistente.EonetIdApi,
                Data = eventoExistente.Data, // Agora DateTime?
                Json = eventoExistente.Json // Ou "(Conteúdo JSON atualizado)"
            };
            return Ok(eventoAtualizadoDto);
        }

        /// <summary>
        /// Deleta um evento EONET do banco de dados local pelo seu ID interno.
        /// </summary>
        [HttpDelete("{idInterno}")]
        [ProducesResponseType(StatusCodes.Status204NoContent)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status404NotFound)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> DeletarEventoEonetLocal(long idInterno)
        {
            _logger.LogInformation("Endpoint DELETE /api/eonet/{IdInterno} chamado.", idInterno);
            var evento = await _context.EonetEvents.FindAsync(idInterno);
            if (evento == null)
            {
                return NotFound(new ProblemDetails { Status = StatusCodes.Status404NotFound, Title = "Recurso não encontrado", Detail = $"Evento EONET local com ID interno {idInterno} não encontrado." });
            }

            _context.EonetEvents.Remove(evento);
            await _context.SaveChangesAsync();

            return NoContent();
        }

        /// <summary>
        /// Busca eventos EONET armazenados localmente dentro de um intervalo de datas.
        /// </summary>
        [HttpGet("por-data")]
        [ProducesResponseType(typeof(List<EonetResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> BuscarEventosLocaisPorIntervaloDeData(
            [FromQuery, Required] DateTimeOffset dataInicialOffset, // Renomeado para clareza
            [FromQuery, Required] DateTimeOffset dataFinalOffset)   // Renomeado para clareza
        {
            _logger.LogInformation("Endpoint GET /api/eonet/por-data chamado com dataInicialOffset: {DataInicialOffset}, dataFinalOffset: {DataFinalOffset}", dataInicialOffset, dataFinalOffset);

            if (dataInicialOffset > dataFinalOffset)
            {
                return BadRequest(new ProblemDetails { Status = StatusCodes.Status400BadRequest, Title = "Requisição inválida", Detail = "Data inicial não pode ser posterior à data final." });
            }

            // Convertendo os parâmetros DateTimeOffset para DateTime UTC para comparação com EonetEvent.Data (DateTime?)
            DateTime dataInicialUtc = dataInicialOffset.UtcDateTime;
            DateTime dataFinalUtc = dataFinalOffset.UtcDateTime;

            var eventos = await _context.EonetEvents
                                    .Where(e => e.Data.HasValue && e.Data.Value >= dataInicialUtc && e.Data.Value <= dataFinalUtc)
                                    .AsNoTracking()
                                    .OrderBy(e => e.Data) // Ou OrderByDescending(e => e.Data) dependendo da necessidade
                                    .ToListAsync();

            var eventosDto = eventos.Select(e => new EonetResponseDto
            {
                IdEonet = e.IdEonet,
                EonetIdApi = e.EonetIdApi,
                Data = e.Data, // Agora DateTime?
                Json = e.Json
            }).ToList();
            return Ok(eventosDto);
        }

        /// <summary>
        /// Busca novos eventos da API da NASA EONET e os persiste/atualiza localmente.
        /// </summary>
        [HttpPost("nasa/sincronizar")]
        [ProducesResponseType(typeof(List<EonetResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status503ServiceUnavailable)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> SincronizarEventosDaNasa(
            [FromQuery] int? limit,
            [FromQuery] int? days,
            [FromQuery] string? status = "open",
            [FromQuery] string? source = null)
        {
            _logger.LogInformation("Endpoint POST /api/eonet/nasa/sincronizar chamado. Limit: {Limit}, Days: {Days}, Status: {Status}, Source: {Source}", limit, days, status, source);
            NasaEonetApiResponseDto? respostaDaApi;
            try
            {
                respostaDaApi = await _nasaEonetClient.GetEventsAsync(limit, days, status, source);
            }
            catch (ServicoIndisponivelException ex)
            {
                _logger.LogError(ex, "Falha ao comunicar com a API da NASA EONET durante a sincronização.");
                return StatusCode(StatusCodes.Status503ServiceUnavailable, new ProblemDetails { Status = 503, Title = "Serviço Externo Indisponível", Detail = ex.Message });
            }

            if (respostaDaApi == null || respostaDaApi.Events == null || !respostaDaApi.Events.Any())
            {
                _logger.LogInformation("Nenhum evento recebido da API da NASA EONET para os parâmetros fornecidos ou resposta vazia.");
                return Ok(new List<EonetResponseDto>());
            }

            List<EonetResponseDto> eventosProcessadosLocalmente = new List<EonetResponseDto>();
            foreach (var eventoDtoDaApi in respostaDaApi.Events)
            {
                if (string.IsNullOrEmpty(eventoDtoDaApi.Id))
                {
                    _logger.LogWarning("Evento da API EONET recebido sem ID, pulando: {Title}", eventoDtoDaApi.Title);
                    continue;
                }

                var eventoLocal = await _context.EonetEvents.FirstOrDefaultAsync(e => e.EonetIdApi == eventoDtoDaApi.Id);
                bool isNew = eventoLocal == null;
                if (isNew)
                {
                    eventoLocal = new EonetEvent { EonetIdApi = eventoDtoDaApi.Id };
                }
                // else { // Opcional: Lógica para atualizar EonetIdApi se necessário, mas geralmente não muda }

                try
                {
                    eventoLocal.Json = JsonSerializer.Serialize(eventoDtoDaApi, new JsonSerializerOptions { WriteIndented = false });
                }
                catch (JsonException jsonEx)
                {
                    _logger.LogError(jsonEx, "Falha ao serializar NasaEonetEventDto para JSON para o evento API ID {ApiId}.", eventoDtoDaApi.Id);
                    eventoLocal.Json = $"{{\"error\":\"Falha ao serializar evento para JSON\", \"originalTitle\":\"{eventoDtoDaApi.Title?.Replace("\"", "\\\"")}\"}}";
                }

                var principalDateOffset = eventoDtoDaApi.Geometry?.FirstOrDefault(g => g != null)?.Date;
                // Converte para DateTime UTC ou usa DateTime.UtcNow se nulo
                eventoLocal.Data = principalDateOffset?.UtcDateTime ?? DateTime.UtcNow;

                if (isNew)
                {
                    _context.EonetEvents.Add(eventoLocal);
                }
                else
                {
                    _context.EonetEvents.Update(eventoLocal);
                }
                await _context.SaveChangesAsync(); // Salva cada evento individualmente para isolar possíveis erros

                eventosProcessadosLocalmente.Add(new EonetResponseDto
                {
                    IdEonet = eventoLocal.IdEonet,
                    EonetIdApi = eventoLocal.EonetIdApi,
                    Data = eventoLocal.Data, // Agora DateTime?
                    Json = "(Conteúdo JSON sincronizado)" // Evita retornar o JSON completo na resposta da sincronização
                });
            }

            _logger.LogInformation("{Count} eventos da NASA EONET processados e salvos/atualizados localmente.", eventosProcessadosLocalmente.Count);
            return Ok(eventosProcessadosLocalmente);
        }

        /// <summary>
        /// Busca eventos diretamente da API EONET da NASA com base em vários filtros.
        /// </summary>
        [HttpGet("nasa/proximos")]
        [ProducesResponseType(typeof(List<NasaEonetEventDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status204NoContent)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status503ServiceUnavailable)]
        public async Task<IActionResult> BuscarEventosDaNasa(
            [FromQuery] double? latitude,
            [FromQuery] double? longitude,
            [FromQuery] double? raioKm,
            [FromQuery] string? startDate, // Formato YYYY-MM-DD
            [FromQuery] string? endDate,   // Formato YYYY-MM-DD
            [FromQuery] int? limit,
            [FromQuery] int? days,
            [FromQuery] string? status,
            [FromQuery] string? source)
        {
            _logger.LogInformation("Endpoint GET /api/eonet/nasa/proximos chamado com Lat: {Lat}, Lon: {Lon}, RaioKm: {Raio}, Start: {Start}, End: {End}, Limit: {Limit}, Days: {Days}, Status: {Status}, Source: {Source}",
                latitude, longitude, raioKm, startDate, endDate, limit, days, status, source);

            string? bbox = null;
            if (latitude.HasValue && longitude.HasValue && raioKm.HasValue && raioKm.Value > 0)
            {
                // A API EONET espera BBOX no formato: minLon,minLat,maxLon,maxLat
                // Implementar a lógica para calcular o BBOX a partir de lat/lon/raioKm é mais complexo.
                // A API EONET v3 não parece suportar lat/lon/radius diretamente.
                // Vamos focar nos outros parâmetros por agora, ou você precisará implementar o cálculo do BBOX.
                _logger.LogInformation("Busca por proximidade (lat/lon/raio) solicitada. A API EONET v3 espera um BBOX. Esta funcionalidade pode precisar de um cálculo de BBOX no backend.");
                // Por simplicidade, não usaremos BBOX nesta chamada de exemplo, a menos que o INasaEonetClient o construa.
            }

            try
            {
                var respostaDaApi = await _nasaEonetClient.GetEventsAsync(limit, days, status, source, bbox, startDate, endDate);
                if (respostaDaApi == null || respostaDaApi.Events == null || !respostaDaApi.Events.Any())
                {
                    _logger.LogInformation("Nenhum evento encontrado na API da NASA para os critérios fornecidos.");
                    return NoContent(); // Retorna 204 se não houver eventos
                }
                return Ok(respostaDaApi.Events);
            }
            catch (ServicoIndisponivelException ex)
            {
                _logger.LogError(ex, "Falha ao comunicar com a API da NASA EONET.");
                return StatusCode(StatusCodes.Status503ServiceUnavailable, new ProblemDetails { Status = 503, Title = "Serviço Externo Indisponível", Detail = ex.Message });
            }
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: controller\StatsController.cs
// Namespace: gsApi.controller
// Tipo: StatsController
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/controller/StatsController.cs
using gsApi.data;
using gsApi.dto.response; // Para CategoryCountDto e NasaEonetEventDto (usado para parsear o JSON)
using gsApi.DTOs.Response;
using gsApi.model;
using gsApi.model.DTOs.Response;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;

namespace gsApi.controller
{
    /// <summary>
    /// Fornece endpoints para obter dados estatísticos sobre eventos EONET.
    /// </summary>
    [ApiController]
    [Route("api/stats")]
    [Produces("application/json")]
    [Consumes("application/json")]
    public class StatsController : ControllerBase
    {
        private readonly ILogger<StatsController> _logger;
        private readonly AppDbContext _context;

        public StatsController(ILogger<StatsController> logger, AppDbContext context)
        {
            _logger = logger;
            _context = context;
        }

        /// <summary>
        /// Obtém a contagem de eventos EONET locais por categoria para um determinado período em dias.
        /// </summary>
        /// <remarks>
        /// Calcula o número de eventos para cada categoria com base nos dados JSON armazenados 
        /// para os eventos EONET dentro do período especificado.
        /// </remarks>
        /// <param name="days">Número de dias no passado a serem considerados para a estatística (ex: 365 para o último ano). Deve ser um número positivo. Padrão é 365.</param>
        /// <response code="200">Retorna as estatísticas de contagem de eventos por categoria.</response>
        /// <response code="400">Se o parâmetro 'days' for inválido (ex: não positivo).</response>
        /// <response code="500">Se ocorrer um erro interno inesperado no servidor durante o processamento.</response>
        [HttpGet("eonet/count-by-category")]
        [ProducesResponseType(typeof(List<CategoryCountDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
        [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> GetEonetCountByCategory(
            [FromQuery, Range(1, int.MaxValue, ErrorMessage = "O parâmetro 'days' deve ser um número positivo maior que zero.")] int days = 365)
        {
            _logger.LogInformation("Endpoint GET /api/stats/eonet/count-by-category chamado com days: {Days}", days);

            // A validação do range de 'days' já é feita pelo atributo [Range] e seria tratada pelo ModelState.
            // Se quisermos uma validação explícita adicional ou se o ModelState não for usado para este caso:
            if (days <= 0)
            {
                // Isso normalmente seria pego pelo filtro de validação do ASP.NET Core se o ModelState fosse checado,
                // mas para garantir um retorno claro se essa checagem não for feita antes.
                return BadRequest(new ProblemDetails
                {
                    Status = StatusCodes.Status400BadRequest,
                    Title = "Parâmetro Inválido",
                    Detail = "O parâmetro 'days' deve ser um número positivo maior que zero."
                });
            }

            var dataFinal = DateTimeOffset.UtcNow;
            var dataInicial = dataFinal.AddDays(-days);

            _logger.LogInformation("Calculando estatísticas de eventos EONET por categoria de {DataInicial} até {DataFinal}", dataInicial, dataFinal);

            var eventosNoPeriodo = await _context.EonetEvents
                                             .Where(e => e.Data.HasValue && e.Data.Value >= dataInicial && e.Data.Value <= dataFinal && e.Json != null)
                                             .AsNoTracking()
                                             .ToListAsync();

            _logger.LogInformation("{Count} eventos locais encontrados com JSON e data válida entre {DataInicial} e {DataFinal} para contagem por categoria.",
                eventosNoPeriodo.Count, dataInicial, dataFinal);

            var categoryCounts = new Dictionary<string, long>();
            var jsonSerializerOptions = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };

            foreach (var eventoLocal in eventosNoPeriodo)
            {
                if (string.IsNullOrEmpty(eventoLocal.Json))
                {
                    continue;
                }

                try
                {
                    // Desserializar o JSON armazenado para o DTO NasaEonetEventDto
                    NasaEonetEventDto? eventoNasaDto = JsonSerializer.Deserialize<NasaEonetEventDto>(eventoLocal.Json, jsonSerializerOptions);

                    if (eventoNasaDto?.Categories != null)
                    {
                        foreach (var category in eventoNasaDto.Categories)
                        {
                            if (!string.IsNullOrEmpty(category.Title))
                            {
                                if (categoryCounts.ContainsKey(category.Title))
                                {
                                    categoryCounts[category.Title]++;
                                }
                                else
                                {
                                    categoryCounts[category.Title] = 1;
                                }
                            }
                        }
                    }
                }
                catch (JsonException jsonEx)
                {
                    _logger.LogWarning(jsonEx, "Falha ao desserializar JSON para o evento EONET com ID Interno {IdInterno} e API ID {ApiId}. JSON Snippet: {JsonSnippet}",
                        eventoLocal.IdEonet,
                        eventoLocal.EonetIdApi,
                        eventoLocal.Json.Length > 200 ? eventoLocal.Json.Substring(0, 200) + "..." : eventoLocal.Json);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Erro inesperado ao processar categorias para o evento EONET com ID Interno {IdInterno} e API ID {ApiId}.", eventoLocal.IdEonet, eventoLocal.EonetIdApi);
                }
            }

            var statsResult = categoryCounts
                                .Select(kvp => new CategoryCountDto(kvp.Key, kvp.Value))
                                .OrderByDescending(dto => dto.Count)
                                .ToList();

            _logger.LogInformation("Estatísticas de contagem por categoria geradas com {Count} categorias distintas.", statsResult.Count);
            return Ok(statsResult);
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: data\AppDbContext .cs
// Namespace: gsApi.data
// Tipo: AppDbContext
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/data/AppDbContext.cs
using Microsoft.EntityFrameworkCore;
using gsApi.model;
using System.Collections.Generic;

namespace gsApi.data
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }

        public DbSet<Cliente> Clientes { get; set; }
        public DbSet<Contato> Contatos { get; set; }
        public DbSet<Endereco> Enderecos { get; set; }
        public DbSet<EonetEvent> EonetEvents { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Nomes de sequences e colunas em MAIÚSCULAS
            modelBuilder.Entity<Cliente>(entity =>
            {
                entity.Property(c => c.IdCliente)
                      .HasColumnName("ID_CLIENTE") // Garantir que o nome da coluna PK está explícito
                      .HasDefaultValueSql("TB_CLIENTE3_ID_CLIENTE_SEQ.NEXTVAL");
            });

            modelBuilder.Entity<Contato>(entity =>
            {
                entity.Property(c => c.IdContato)
                      .HasColumnName("ID_CONTATO")
                      .HasDefaultValueSql("TB_CONTATO3_ID_CONTATO_SEQ.NEXTVAL");
            });

            modelBuilder.Entity<Endereco>(entity =>
            {
                entity.Property(e => e.IdEndereco)
                      .HasColumnName("ID_ENDERECO")
                      .HasDefaultValueSql("TB_ENDERECO3_ID_ENDERECO_SEQ.NEXTVAL");
            });

            modelBuilder.Entity<EonetEvent>(entity =>
            {
                entity.Property(e => e.IdEonet)
                      .HasColumnName("ID_EONET")
                      .HasDefaultValueSql("TB_EONET3_ID_EONET_SEQ.NEXTVAL");

                entity.Property(e => e.Data)
                      .HasColumnName("DATA")
                      .HasColumnType("TIMESTAMP"); // DDL: TIMESTAMP (6) WITH LOCAL TIME ZONE. "TIMESTAMP" é um bom mapeamento para DateTime.
            });

            // Relações Many-to-Many com nomes de tabelas e colunas em MAIÚSCULAS
            modelBuilder.Entity<Cliente>()
                .HasMany(c => c.Contatos)
                .WithMany(t => t.Clientes)
                .UsingEntity<Dictionary<string, object>>(
                    "TB_CLIENTECONTATO3", // Nome da tabela de junção
                    r => r.HasOne<Contato>().WithMany().HasForeignKey("TB_CONTATO3_ID_CONTATO").HasConstraintName("TB_CLIENTECONTATO3_TB_CONTATO3_FK"),
                    l => l.HasOne<Cliente>().WithMany().HasForeignKey("TB_CLIENTE3_ID_CLIENTE").HasConstraintName("TB_CLIENTECONTATO3_TB_CLIENTE3_FK"),
                    j =>
                    {
                        j.ToTable("TB_CLIENTECONTATO3");
                        j.HasKey("TB_CLIENTE3_ID_CLIENTE", "TB_CONTATO3_ID_CONTATO");
                    });

            modelBuilder.Entity<Cliente>()
                .HasMany(c => c.Enderecos)
                .WithMany(e => e.Clientes)
                .UsingEntity<Dictionary<string, object>>(
                    "TB_CLIENTEENDERECO3",
                    r => r.HasOne<Endereco>().WithMany().HasForeignKey("TB_ENDERECO3_ID_ENDERECO").HasConstraintName("TB_CLIENTEENDERECO3_TB_ENDERECO3_FK"),
                    l => l.HasOne<Cliente>().WithMany().HasForeignKey("TB_CLIENTE3_ID_CLIENTE").HasConstraintName("TB_CLIENTEENDERECO3_TB_CLIENTE3_FK"),
                    j =>
                    {
                        j.ToTable("TB_CLIENTEENDERECO3");
                        j.HasKey("TB_CLIENTE3_ID_CLIENTE", "TB_ENDERECO3_ID_ENDERECO");
                    });

            modelBuilder.Entity<Endereco>()
                .HasMany(e => e.EventosEonet)
                .WithMany(ev => ev.Enderecos)
                .UsingEntity<Dictionary<string, object>>(
                    "TB_ENDERECOEVENTOS3",
                    r => r.HasOne<EonetEvent>().WithMany().HasForeignKey("TB_EONET3_ID_EONET").HasConstraintName("TB_ENDERECOEVENTOS3_TB_EONET3_FK"),
                    l => l.HasOne<Endereco>().WithMany().HasForeignKey("TB_ENDERECO3_ID_ENDERECO").HasConstraintName("TB_ENDERECOEVENTOS3_TB_ENDERECO3_FK"),
                    j =>
                    {
                        j.ToTable("TB_ENDERECOEVENTOS3");
                        j.HasKey("TB_ENDERECO3_ID_ENDERECO", "TB_EONET3_ID_EONET");
                    });
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\request\AlertableEventDto.cs
// Namespace: gsApi.dto.request
// Tipo: AlertableEventDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/request/AlertableEventDto.cs
namespace gsApi.dto.request
{
    /// <summary>
    /// DTO contendo detalhes de um evento para fins de alerta.
    /// </summary>
    public class AlertableEventDto
    {
        /// <summary>
        /// ID do evento (ex: ID da EONET).
        /// </summary>
        public string? EventId { get; set; }

        /// <summary>
        /// Título do evento. Se for obrigatório para o alerta, marque como 'required'.
        /// </summary>
        public required string Title { get; set; } // Exemplo: Tornando o título obrigatório

        /// <summary>
        /// Data do evento (formatada como string).
        /// </summary>
        public string? EventDate { get; set; }

        /// <summary>
        /// Link para mais informações sobre o evento.
        /// </summary>
        public string? Link { get; set; }

        /// <summary>
        /// Descrição breve do evento.
        /// </summary>
        public string? Description { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\request\ClienteRequestDto.cs
// Namespace: gsApi.dto.request
// Tipo: ClienteRequestDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/request/ClienteRequestDto.cs
using System.ComponentModel.DataAnnotations;
using System.Collections.Generic;

namespace gsApi.dto.request // Namespace correto
{
    public class ClienteRequestDto
    {
        [Required(ErrorMessage = "O nome não pode estar em branco.")]
        [StringLength(100, MinimumLength = 2, ErrorMessage = "O nome deve ter entre 2 e 100 caracteres.")]
        public required string Nome { get; set; }

        [Required(ErrorMessage = "O sobrenome não pode estar em branco.")]
        [StringLength(100, MinimumLength = 2, ErrorMessage = "O sobrenome deve ter entre 2 e 100 caracteres.")]
        public required string Sobrenome { get; set; }

        [Required(ErrorMessage = "A data de nascimento não pode estar em branco.")]
        [RegularExpression(@"^(\d{4}-\d{2}-\d{2}|\d{2}/\d{2}/\d{4})$", ErrorMessage = "A data de nascimento deve estar no formato yyyy-MM-dd ou dd/MM/yyyy.")]
        public required string DataNascimento { get; set; }

        [Required(ErrorMessage = "O documento não pode estar em branco.")]
        [StringLength(18, MinimumLength = 11, ErrorMessage = "O documento deve ter entre 11 e 18 caracteres.")]
        public required string Documento { get; set; }

        public List<long>? ContatosIds { get; set; }
        public List<long>? EnderecosIds { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\request\ContatoRequestDto.cs
// Namespace: gsApi.DTOs.Request
// Tipo: ContatoRequestDto
//----------------------------------------------------------------------------------------------------

﻿// File: DTOs/Request/ContatoRequestDto.cs
using System.ComponentModel.DataAnnotations;

namespace gsApi.DTOs.Request
{
    /// <summary>
    /// DTO para criar/atualizar um contato via API.
    /// </summary>
    public class ContatoRequestDto
    {
        [Required(ErrorMessage = "O DDD é obrigatório.")]
        [StringLength(3, MinimumLength = 2, ErrorMessage = "O DDD deve ter entre 2 e 3 dígitos.")]
        public string Ddd { get; set; } = string.Empty;

        [Required(ErrorMessage = "O Telefone é obrigatório.")]
        [StringLength(15, ErrorMessage = "O Telefone não pode exceder 15 caracteres.")]
        public string Telefone { get; set; } = string.Empty;

        [Required(ErrorMessage = "O Celular é obrigatório.")]
        [StringLength(15, ErrorMessage = "O Celular não pode exceder 15 caracteres.")]
        public string Celular { get; set; } = string.Empty;

        [Required(ErrorMessage = "O Whatsapp é obrigatório.")]
        [StringLength(15, ErrorMessage = "O Whatsapp não pode exceder 15 caracteres.")]
        public string Whatsapp { get; set; } = string.Empty;

        [Required(ErrorMessage = "O Email é obrigatório.")]
        [EmailAddress(ErrorMessage = "Formato de email inválido.")]
        public string Email { get; set; } = string.Empty;

        [Required(ErrorMessage = "O Tipo de Contato é obrigatório.")]
        [StringLength(50, ErrorMessage = "O Tipo de Contato não pode exceder 50 caracteres.")]
        public string TipoContato { get; set; } = string.Empty;
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\request\EnderecoGeoRequestDto.cs
// Namespace: gsApi.DTOs.Request
// Tipo: EnderecoGeoRequestDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/request/EnderecoGeoRequestDto.cs
using System.ComponentModel.DataAnnotations;

namespace gsApi.DTOs.Request
{
    public class EnderecoGeoRequestDto
    {
        [Required(ErrorMessage = "Logradouro é obrigatório para geocodificação.")]
        [StringLength(255)]
        public required string Logradouro { get; set; }

        [StringLength(10)]
        public string? Numero { get; set; } // Opcional

        [Required(ErrorMessage = "Cidade (Localidade) é obrigatória para geocodificação.")]
        [StringLength(100)]
        public required string Cidade { get; set; }

        [Required(ErrorMessage = "UF (Estado) é obrigatória para geocodificação.")]
        [StringLength(2, MinimumLength = 2)]
        public required string Uf { get; set; }

        [StringLength(100)]
        public string? Bairro { get; set; } // Opcional

        [StringLength(9)]
        public string? Cep { get; set; } // Opcional
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\request\EnderecoRequestDto.cs
// Namespace: gsApi.DTOs.Request
// Tipo: EnderecoRequestDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/request/EnderecoRequestDto.cs
using System.ComponentModel.DataAnnotations;

namespace gsApi.DTOs.Request
{
    public class EnderecoRequestDto
    {
        [Required(ErrorMessage = "O CEP não pode estar em branco.")]
        [RegularExpression(@"^\d{5}-?\d{3}$", ErrorMessage = "O CEP deve estar no formato XXXXX-XXX ou XXXXXXXX.")]
        public required string Cep { get; set; }

        [Required(ErrorMessage = "O número não pode ser nulo.")]
        [Range(1, 99999, ErrorMessage = "O número deve ser um inteiro de até 5 dígitos.")]
        public int Numero { get; set; } // Tipo de valor, 'required' C# não se aplica para nulidade

        [Required(ErrorMessage = "O logradouro não pode estar em branco.")]
        [StringLength(255, ErrorMessage = "O logradouro não pode exceder 255 caracteres.")]
        public required string Logradouro { get; set; }

        [Required(ErrorMessage = "O bairro não pode estar em branco.")]
        [StringLength(255, ErrorMessage = "O bairro não pode exceder 255 caracteres.")]
        public required string Bairro { get; set; }

        [Required(ErrorMessage = "A localidade (cidade) não pode estar em branco.")]
        [StringLength(100, ErrorMessage = "A localidade não pode exceder 100 caracteres.")]
        public required string Localidade { get; set; }

        [Required(ErrorMessage = "A UF não pode estar em branco.")]
        [StringLength(2, MinimumLength = 2, ErrorMessage = "A UF deve ter 2 caracteres.")]
        public required string Uf { get; set; }

        [Required(ErrorMessage = "O complemento não pode estar em branco.")]
        [StringLength(255, ErrorMessage = "O complemento não pode exceder 255 caracteres.")]
        public required string Complemento { get; set; }

        [Required(ErrorMessage = "Latitude não pode ser nula.")]
        [Range(-90.0, 90.0, ErrorMessage = "Latitude inválida. Deve estar entre -90 e 90.")]
        public double Latitude { get; set; } // Tipo de valor

        [Required(ErrorMessage = "Longitude não pode ser nula.")]
        [Range(-180.0, 180.0, ErrorMessage = "Longitude inválida. Deve estar entre -180 e 180.")]
        public double Longitude { get; set; } // Tipo de valor
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\request\EonetRequestDto.cs
// Namespace: gsApi.DTOs.Request
// Tipo: EonetRequestDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/request/EonetRequestDto.cs
using System; // Para DateTimeOffset
using System.ComponentModel.DataAnnotations;

namespace gsApi.DTOs.Request
{
    public class EonetRequestDto
    {
        [Required(ErrorMessage = "O conteúdo JSON não pode ser nulo.")]
        public required string Json { get; set; }

        [Required(ErrorMessage = "A data do evento não pode ser nula.")]
        public DateTimeOffset Data { get; set; } // Tipo de valor

        [Required(ErrorMessage = "O ID da API EONET não pode estar em branco.")]
        [StringLength(50, ErrorMessage = "O ID da API EONET não pode exceder 50 caracteres.")]
        public required string EonetIdApi { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\request\UserAlertRequestDto.cs
// Namespace: gsApi.dto.request
// Tipo: UserAlertRequestDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/request/UserAlertRequestDto.cs
using System.ComponentModel.DataAnnotations;

namespace gsApi.dto.request
{
    /// <summary>
    /// DTO para solicitar o disparo de um alerta para um usuário específico.
    /// </summary>
    public class UserAlertRequestDto
    {
        /// <summary>
        /// ID do usuário a ser alertado.
        /// </summary>
        [Required(ErrorMessage = "O ID do usuário é obrigatório.")]
        public long UserId { get; set; } // Para CS9035, UserId é long, não precisa de 'required' se não for classe.

        /// <summary>
        /// Detalhes do evento para o alerta.
        /// </summary>
        [Required(ErrorMessage = "Os detalhes do evento são obrigatórios.")]
        public required AlertableEventDto EventDetails { get; set; } // Usando AlertableEventDto e 'required'
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\CategoryCountDto.cs
// Namespace: gsApi.model.DTOs.Response
// Tipo: CategoryCountDto
//----------------------------------------------------------------------------------------------------

﻿// File: SeuProjetoNET/DTOs/Response/CategoryCountDto.cs
namespace gsApi.model.DTOs.Response
{
    public class CategoryCountDto
    {
        public string CategoryTitle { get; set; }
        public long Count { get; set; }

        public CategoryCountDto(string categoryTitle, long count)
        {
            CategoryTitle = categoryTitle;
            Count = count;
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\ClienteResponseDto.cs
// Namespace: gsApi.dto.response
// Tipo: ClienteResponseDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/ClienteResponseDto.cs
using gsApi.DTOs.Response;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;

namespace gsApi.dto.response
{
    public class ClienteResponseDto
    {
        public long IdCliente { get; set; }

        [Required]
        public required string Nome { get; set; }

        [Required]
        public required string Sobrenome { get; set; }

        [Required]
        public required string DataNascimento { get; set; }

        [Required]
        public required string Documento { get; set; }

        public ICollection<ContatoResponseDto> Contatos { get; set; } = new List<ContatoResponseDto>();
        public ICollection<EnderecoResponseDto> Enderecos { get; set; } = new List<EnderecoResponseDto>();
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\ContatoResponseDto.cs
// Namespace: gsApi.dto.response
// Tipo: ContatoResponseDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/ContatoResponseDto.cs
// Baseado no seu arquivo: gsApi.DTOs.Response.ContatoResponseDto
using System.ComponentModel.DataAnnotations;

namespace gsApi.dto.response // Padronizando namespace
{
    public class ContatoResponseDto
    {
        // IdContato não precisa de [Required] se for gerado pelo banco e sempre presente na resposta.
        public long IdContato { get; set; }

        [Required]
        public required string Ddd { get; set; }
        [Required]
        public required string Telefone { get; set; }
        [Required]
        public required string Celular { get; set; }
        [Required]
        public required string Whatsapp { get; set; }
        [Required]
        [EmailAddress]
        public required string Email { get; set; }
        [Required]
        public required string TipoContato { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\EnderecoResponseDto.cs
// Namespace: gsApi.dto.response
// Tipo: EnderecoResponseDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/EnderecoResponseDto.cs
using System.ComponentModel.DataAnnotations;

namespace gsApi.dto.response
{
    public class EnderecoResponseDto
    {
        public long IdEndereco { get; set; }

        [Required]
        public required string Cep { get; set; }

        public int Numero { get; set; }

        [Required]
        public required string Logradouro { get; set; }

        [Required]
        public required string Bairro { get; set; }

        [Required]
        public required string Localidade { get; set; }

        [Required]
        public required string Uf { get; set; }

        public string? Complemento { get; set; } // Anulável

        public double Latitude { get; set; }

        public double Longitude { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\EonetResponseDto.cs
// Namespace: gsApi.dto.response
// Tipo: EonetResponseDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/EonetResponseDto.cs
using System;
using System.ComponentModel.DataAnnotations;

namespace gsApi.dto.response
{
    public class EonetResponseDto
    {
        public long IdEonet { get; set; }
        public string? Json { get; set; }
        public DateTime? Data { get; set; } // <--- CORREÇÃO: Alterado para DateTime?

        [Required]
        public required string EonetIdApi { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\GeoCoordinatesDto .cs
// Namespace: gsApi.DTOs.Response
// Tipo: GeoCoordinatesDto
//----------------------------------------------------------------------------------------------------

﻿// File: SeuProjetoNET/DTOs/Response/GeoCoordinatesDto.cs
namespace gsApi.DTOs.Response
{
    public class GeoCoordinatesDto
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public string? MatchedAddress { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\GoogleGeocodingApiResponseDto .cs
// Namespace: gsApi.dto.response
// Tipo: GoogleGeocodingApiResponseDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/GoogleGeocodingApiResponseDto.cs
using System.Collections.Generic;
using System.Text.Json.Serialization;
namespace gsApi.dto.response
{
    public class GoogleGeocodingApiResponseDto
    {
        [JsonPropertyName("results")]
        public List<GoogleGeocodingResultDto> Results { get; set; } = new List<GoogleGeocodingResultDto>(); // Inicializado

        [JsonPropertyName("status")]
        public string? Status { get; set; } // Status pode vir, mas para ser seguro, anulável ou required se sempre garantido

        [JsonPropertyName("error_message")]
        public string? ErrorMessage { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\GoogleGeocodingGeometryDto.cs
// Namespace: gsApi.dto.response
// Tipo: GoogleGeocodingGeometryDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/GoogleGeocodingGeometryDto.cs
using System.Text.Json.Serialization;
namespace gsApi.dto.response
{
    public class GoogleGeocodingGeometryDto
    {
        [JsonPropertyName("location")]
        public GoogleGeocodingLocationDto? Location { get; set; } // Anulável
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\GoogleGeocodingLocationDto.cs
// Namespace: gsApi.dto.response
// Tipo: GoogleGeocodingLocationDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/GoogleGeocodingLocationDto.cs
using System.Text.Json.Serialization;
namespace gsApi.dto.response
{
    public class GoogleGeocodingLocationDto
    {
        [JsonPropertyName("lat")]
        public double Latitude { get; set; }

        [JsonPropertyName("lng")]
        public double Longitude { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\GoogleGeocodingResultDto.cs
// Namespace: gsApi.dto.response
// Tipo: GoogleGeocodingResultDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/GoogleGeocodingResultDto.cs
using System.Collections.Generic;
using System.Text.Json.Serialization;
namespace gsApi.dto.response
{
    public class GoogleGeocodingResultDto
    {
        [JsonPropertyName("formatted_address")]
        public string? FormattedAddress { get; set; } // Anulável

        [JsonPropertyName("geometry")]
        public GoogleGeocodingGeometryDto? Geometry { get; set; } // Anulável

        [JsonPropertyName("place_id")]
        public string? PlaceId { get; set; } // Anulável

        [JsonPropertyName("types")]
        public List<string> Types { get; set; } = new List<string>(); // Inicializado
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\NasaEonetApiResponseDto.cs
// Namespace: gsApi.dto.response
// Tipo: NasaEonetApiResponseDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/NasaEonetApiResponseDto.cs
using gsApi.DTOs.Response;
using System.Collections.Generic;
using System.Text.Json.Serialization;
namespace gsApi.dto.response
{
    public class NasaEonetApiResponseDto
    {
        [JsonPropertyName("title")]
        public required string Title { get; set; }

        [JsonPropertyName("description")]
        public string? Description { get; set; }

        [JsonPropertyName("link")]
        public required string Link { get; set; }

        [JsonPropertyName("events")]
        // Conforme seu input, esta é uma boa forma:
        public required List<NasaEonetEventDto> Events { get; set; } = new List<NasaEonetEventDto>();
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\NasaEonetCategoryDto.cs
// Namespace: gsApi.dto.response
// Tipo: NasaEonetCategoryDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/NasaEonetCategoryDto.cs
namespace gsApi.dto.response
{
    public class NasaEonetCategoryDto
    {
        public required string Id { get; set; }
        public required string Title { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\NasaEonetEventDto .cs
// Namespace: gsApi.DTOs.Response
// Tipo: NasaEonetEventDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/NasaEonetEventDto.cs
using gsApi.dto.response;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace gsApi.DTOs.Response
{
    public class NasaEonetEventDto
    {
        [JsonPropertyName("id")]
        public required string Id { get; set; }

        [JsonPropertyName("title")]
        public required string Title { get; set; }

        [JsonPropertyName("description")]
        public string? Description { get; set; } // Permanece anulável

        [JsonPropertyName("link")]
        public required string Link { get; set; }

        [JsonPropertyName("categories")]
        public required List<NasaEonetCategoryDto> Categories { get; set; }

        [JsonPropertyName("sources")]
        public List<NasaEonetSourceDto>? Sources { get; set; } // Permanece anulável

        [JsonPropertyName("geometry")]
        public required List<NasaEonetGeometryDto> Geometry { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\NasaEonetGeometryDto.cs
// Namespace: gsApi.dto.response
// Tipo: NasaEonetGeometryDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/NasaEonetGeometryDto.cs
using System;
namespace gsApi.dto.response
{
    public class NasaEonetGeometryDto
    {
        public double? MagnitudeValue { get; set; }
        public string? MagnitudeUnit { get; set; }
        public DateTimeOffset Date { get; set; } // Se a API sempre fornece, ok. Se não, DateTimeOffset?
        public required string Type { get; set; }
        public required object Coordinates { get; set; } // object já é anulável por natureza
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\NasaEonetSourceDto.cs
// Namespace: gsApi.dto.response
// Tipo: NasaEonetSourceDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/NasaEonetSourceDto.cs
namespace gsApi.dto.response
{
    public class NasaEonetSourceDto
    {
        public required string Id { get; set; }
        public required string Url { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\NominatimResponseDto.cs
// Namespace: gsApi.dto.response
// Tipo: NominatimResponseDto
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/dto/response/NominatimResponseDto.cs
using System.Collections.Generic;
using System.Text.Json.Serialization;
namespace gsApi.dto.response
{
    public class NominatimResponseDto
    {
        [JsonPropertyName("place_id")]
        public long PlaceId { get; set; } // Tipos valor não são inerentemente nulos

        [JsonPropertyName("licence")]
        public string? Licence { get; set; }

        [JsonPropertyName("osm_type")]
        public string? OsmType { get; set; }

        [JsonPropertyName("osm_id")]
        public long OsmId { get; set; }

        [JsonPropertyName("lat")]
        public string? Latitude { get; set; }

        [JsonPropertyName("lon")]
        public string? Longitude { get; set; }

        [JsonPropertyName("display_name")]
        public string? DisplayName { get; set; }

        [JsonPropertyName("boundingbox")]
        public List<string>? BoundingBox { get; set; } = new List<string>();

        [JsonPropertyName("error")]
        public string? Error { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\TimeCountDto.cs
// Namespace: gsApi.DTOs.Response
// Tipo: TimeCountDto
//----------------------------------------------------------------------------------------------------

﻿// File: SeuProjetoNET/DTOs/Response/TimeCountDto.cs
namespace gsApi.DTOs.Response
{
    public class TimeCountDto
    {
        public string TimeLabel { get; set; }
        public long Count { get; set; }

        public TimeCountDto(string timeLabel, long count)
        {
            TimeLabel = timeLabel;
            Count = count;
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: dto\response\ViaCepResponseDto.cs
// Namespace: gsApi.DTOs.Response
// Tipo: ViaCepResponseDto
//----------------------------------------------------------------------------------------------------

﻿// File: SeuProjetoNET/DTOs/Response/ViaCepResponseDto.cs
using System.Text.Json.Serialization;

namespace gsApi.DTOs.Response
{
    public class ViaCepResponseDto
    {
        [JsonPropertyName("cep")]
        public string? Cep { get; set; }
        [JsonPropertyName("logradouro")]
        public string? Logradouro { get; set; }
        [JsonPropertyName("complemento")]
        public string? Complemento { get; set; }
        [JsonPropertyName("bairro")]
        public string? Bairro { get; set; }
        [JsonPropertyName("localidade")]
        public string? Localidade { get; set; }
        [JsonPropertyName("uf")]
        public string? Uf { get; set; }
        [JsonPropertyName("ibge")]
        public string? Ibge { get; set; }
        [JsonPropertyName("gia")]
        public string? Gia { get; set; }
        [JsonPropertyName("ddd")]
        public string? Ddd { get; set; }
        [JsonPropertyName("siafi")]
        public string? Siafi { get; set; }
        [JsonPropertyName("erro")]
        public bool Erro { get; set; }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: exceptions\RecursoNaoEncontradoException .cs
// Namespace: gsApi.exceptions
// Tipo: RecursoNaoEncontradoException
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/exceptions/RecursoNaoEncontradoException.cs
using System;

namespace gsApi.exceptions // Namespace correto
{
    public class RecursoNaoEncontradoException : Exception
    {
        public RecursoNaoEncontradoException() : base() { }
        public RecursoNaoEncontradoException(string message) : base(message) { }
        public RecursoNaoEncontradoException(string message, Exception innerException) : base(message, innerException) { }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: exceptions\ServicoIndisponivelException .cs
// Namespace: gsApi.Exceptions
// Tipo: ServicoIndisponivelException
//----------------------------------------------------------------------------------------------------

﻿// File: SeuProjetoNET/Exceptions/ServicoIndisponivelException.cs
using System;

namespace gsApi.Exceptions
{
    public class ServicoIndisponivelException : Exception
    {
        public ServicoIndisponivelException() : base() { }

        public ServicoIndisponivelException(string message) : base(message) { }

        public ServicoIndisponivelException(string message, Exception innerException) : base(message, innerException) { }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: exceptions\ValidacaoException .cs
// Namespace: gsApi.Exceptions
// Tipo: ValidacaoException
//----------------------------------------------------------------------------------------------------

﻿// File: SeuProjetoNET/Exceptions/ValidacaoException.cs
using System;
using System.Collections.Generic;

namespace gsApi.Exceptions
{
    public class ValidacaoException : Exception
    {
        public List<string>? Erros { get; }

        public ValidacaoException() : base() { }

        public ValidacaoException(string message) : base(message) { }

        public ValidacaoException(string message, Exception innerException) : base(message, innerException) { }

        public ValidacaoException(string message, List<string> erros) : base(message)
        {
            Erros = erros;
        }
        public ValidacaoException(List<string> erros) : base(erros != null && erros.Count > 0 ? erros[0] : "Erro de validação.")
        {
            Erros = erros;
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: middleware\TratadorGlobalExcecoesMiddleware.cs
// Namespace: gsApi.middleware
// Tipo: TratadorGlobalExcecoesMiddleware
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/middleware/TratadorGlobalExcecoesMiddleware.cs
using gsApi.exceptions; // Namespace corrigido para suas exceções
using gsApi.Exceptions;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Net;
using System.Text.Json;
using System.Threading.Tasks;

namespace gsApi.middleware // Namespace correto
{
    public class TratadorGlobalExcecoesMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<TratadorGlobalExcecoesMiddleware> _logger;

        public TratadorGlobalExcecoesMiddleware(RequestDelegate next, ILogger<TratadorGlobalExcecoesMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Ocorreu uma exceção não tratada: {Message}", ex.Message);
                await HandleExceptionAsync(context, ex);
            }
        }

        private static Task HandleExceptionAsync(HttpContext context, Exception exception)
        {
            context.Response.ContentType = "application/json";
            HttpStatusCode statusCode;
            object responsePayload;

            switch (exception)
            {
                case RecursoNaoEncontradoException ex:
                    statusCode = HttpStatusCode.NotFound;
                    responsePayload = new { timestamp = DateTime.UtcNow, status = (int)statusCode, error = "Not Found", message = ex.Message, path = context.Request.Path.Value };
                    break;
                case ServicoIndisponivelException ex:
                    statusCode = HttpStatusCode.ServiceUnavailable;
                    responsePayload = new { timestamp = DateTime.UtcNow, status = (int)statusCode, error = "Service Unavailable", message = ex.Message, path = context.Request.Path.Value };
                    break;
                case ValidacaoException ex:
                    statusCode = HttpStatusCode.BadRequest;
                    responsePayload = new { timestamp = DateTime.UtcNow, status = (int)statusCode, error = "Bad Request - Validation Error", messages = ex.Erros ?? new List<string> { ex.Message }, path = context.Request.Path.Value };
                    break;
                case ArgumentException ex:
                    statusCode = HttpStatusCode.BadRequest;
                    responsePayload = new { timestamp = DateTime.UtcNow, status = (int)statusCode, error = "Bad Request", message = ex.Message, path = context.Request.Path.Value };
                    break;
                default:
                    statusCode = HttpStatusCode.InternalServerError;
                    responsePayload = new { timestamp = DateTime.UtcNow, status = (int)statusCode, error = "Internal Server Error", message = "Ocorreu um erro inesperado no servidor.", path = context.Request.Path.Value };
                    break;
            }

            context.Response.StatusCode = (int)statusCode;
            return context.Response.WriteAsync(JsonSerializer.Serialize(responsePayload, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: model\Cliente.cs
// Namespace: gsApi.model
// Tipo: Cliente
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/model/Cliente.cs
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace gsApi.model
{
    [Table("TB_CLIENTE3")]
    public class Cliente
    {
        [Key]
        [Column("ID_CLIENTE")]
        public long IdCliente { get; set; }

        [Required(ErrorMessage = "O nome não pode estar em branco.")]
        [StringLength(100)]
        [Column("NOME")]
        public required string Nome { get; set; }

        [Required(ErrorMessage = "O sobrenome não pode estar em branco.")]
        [StringLength(100)]
        [Column("SOBRENOME")]
        public required string Sobrenome { get; set; }

        [Required(ErrorMessage = "A data de nascimento não pode estar em branco.")]
        [StringLength(10)]
        [Column("DATA_NASCIMENTO")]
        public required string DataNascimento { get; set; }

        [Required(ErrorMessage = "O documento não pode estar em branco.")]
        [StringLength(18)]
        [Column("DOCUMENTO")]
        public required string Documento { get; set; }

        public virtual ICollection<Contato> Contatos { get; set; } = new List<Contato>();
        public virtual ICollection<Endereco> Enderecos { get; set; } = new List<Endereco>();
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: model\Contato.cs
// Namespace: gsApi.model
// Tipo: Contato
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/model/Contato.cs
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace gsApi.model
{
    [Table("TB_CONTATO3")]
    public class Contato
    {
        [Key]
        [Column("ID_CONTATO")]
        public long IdContato { get; set; }

        [Required(ErrorMessage = "O DDD não pode estar em branco.")]
        [StringLength(3)]
        [Column("DDD")]
        public required string Ddd { get; set; }

        [Required(ErrorMessage = "O telefone não pode estar em branco.")]
        [StringLength(15)]
        [Column("TELEFONE")]
        public required string Telefone { get; set; }

        [Required(ErrorMessage = "O celular não pode estar em branco.")]
        [StringLength(15)]
        [Column("CELULAR")]
        public required string Celular { get; set; }

        [Required(ErrorMessage = "O WhatsApp não pode estar em branco.")]
        [StringLength(15)]
        [Column("WHATSAPP")]
        public required string Whatsapp { get; set; }

        [Required(ErrorMessage = "O e-mail não pode estar em branco.")]
        [StringLength(255)]
        [EmailAddress(ErrorMessage = "Formato de e-mail inválido.")]
        [Column("EMAIL")]
        public required string Email { get; set; }

        [Required(ErrorMessage = "O tipo de contato não pode estar em branco.")]
        [StringLength(50)]
        [Column("TIPO_CONTATO")]
        public required string TipoContato { get; set; }

        [JsonIgnore]
        public virtual ICollection<Cliente> Clientes { get; set; } = new List<Cliente>();
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: model\Endereco.cs
// Namespace: gsApi.model
// Tipo: Endereco
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/model/Endereco.cs
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;

namespace gsApi.model
{
    [Table("TB_ENDERECO3")]
    public class Endereco
    {
        [Key]
        [Column("ID_ENDERECO")]
        public long IdEndereco { get; set; }

        [Required(ErrorMessage = "O CEP não pode estar em branco.")]
        [StringLength(9)]
        [Column("CEP")]
        public required string Cep { get; set; }

        [Required(ErrorMessage = "O número do endereço é obrigatório.")]
        [Column("NUMERO")]
        public int Numero { get; set; }

        [Required(ErrorMessage = "O logradouro não pode estar em branco.")]
        [StringLength(255)]
        [Column("LOGRADOURO")]
        public required string Logradouro { get; set; }

        [Required(ErrorMessage = "O bairro não pode estar em branco.")]
        [StringLength(255)]
        [Column("BAIRRO")]
        public required string Bairro { get; set; }

        [Required(ErrorMessage = "A localidade (cidade) não pode estar em branco.")]
        [StringLength(100)]
        [Column("LOCALIDADE")]
        public required string Localidade { get; set; }

        [Required(ErrorMessage = "A UF não pode estar em branco.")]
        [StringLength(2)]
        [Column("UF")]
        public required string Uf { get; set; }

        [Required(ErrorMessage = "O complemento é obrigatório.")] // Mantido como required conforme modelo original
        [StringLength(255)]
        [Column("COMPLEMENTO")]
        public required string Complemento { get; set; }

        [Required(ErrorMessage = "Latitude é obrigatória.")]
        [Column("LATITUDE", TypeName = "NUMBER(10,7)")]
        public double Latitude { get; set; }

        [Required(ErrorMessage = "Longitude é obrigatória.")]
        [Column("LONGITUDE", TypeName = "NUMBER(10,7)")]
        public double Longitude { get; set; }

        [JsonIgnore]
        public virtual ICollection<Cliente> Clientes { get; set; } = new List<Cliente>();
        public virtual ICollection<EonetEvent> EventosEonet { get; set; } = new List<EonetEvent>();
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: model\EonetEvent.cs
// Namespace: gsApi.model
// Tipo: EonetEvent
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/model/EonetEvent.cs
using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace gsApi.model
{
    [Table("TB_EONET3")]
    public class EonetEvent
    {
        [Key]
        [Column("ID_EONET")]
        public long IdEonet { get; set; }

        [Column("JSON", TypeName = "CLOB")]
        public string? Json { get; set; }

        [Column("DATA")] // O tipo de coluna será configurado no AppDbContext
        public DateTime? Data { get; set; } // Alterado para DateTime?

        [Required(ErrorMessage = "O ID da API EONET é obrigatório.")]
        [StringLength(50)]
        [Column("EONET_ID")]
        public required string EonetIdApi { get; set; }

        [JsonIgnore]
        public virtual ICollection<Endereco> Enderecos { get; set; } = new List<Endereco>();
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// Namespace: (namespace padrão)
// Tipo: .NETCoreApp,Version=v8.0.AssemblyAttributes
//----------------------------------------------------------------------------------------------------

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]



//----------------------------------------------------------------------------------------------------
// Caminho: obj\Debug\net8.0\gsApi.AssemblyInfo.cs
// Namespace: (namespace padrão)
// Tipo: gsApi.AssemblyInfo
//----------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.42000
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("gsApi")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+be336cafed47d53d3857db7cf89dbd3affe50d39")]
[assembly: System.Reflection.AssemblyProductAttribute("gsApi")]
[assembly: System.Reflection.AssemblyTitleAttribute("gsApi")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Gerado pela classe WriteCodeFragment do MSBuild.



//----------------------------------------------------------------------------------------------------
// Caminho: obj\Debug\net8.0\gsApi.GlobalUsings.g.cs
// Namespace: (namespace padrão)
// Tipo: gsApi.GlobalUsings.g
//----------------------------------------------------------------------------------------------------

// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;



//----------------------------------------------------------------------------------------------------
// Caminho: obj\Debug\net8.0\gsApi.MvcApplicationPartsAssemblyInfo.cs
// Namespace: (namespace padrão)
// Tipo: gsApi.MvcApplicationPartsAssemblyInfo
//----------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.42000
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]

// Gerado pela classe WriteCodeFragment do MSBuild.



//----------------------------------------------------------------------------------------------------
// Caminho: obj\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// Namespace: (namespace padrão)
// Tipo: .NETCoreApp,Version=v8.0.AssemblyAttributes
//----------------------------------------------------------------------------------------------------

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]



//----------------------------------------------------------------------------------------------------
// Caminho: obj\Release\net8.0\gsApi.AssemblyInfo.cs
// Namespace: (namespace padrão)
// Tipo: gsApi.AssemblyInfo
//----------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.42000
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("gsApi")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+4002ac52fdf9c132c45ad172a36ce08700637113")]
[assembly: System.Reflection.AssemblyProductAttribute("gsApi")]
[assembly: System.Reflection.AssemblyTitleAttribute("gsApi")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Gerado pela classe WriteCodeFragment do MSBuild.



//----------------------------------------------------------------------------------------------------
// Caminho: obj\Release\net8.0\gsApi.GlobalUsings.g.cs
// Namespace: (namespace padrão)
// Tipo: gsApi.GlobalUsings.g
//----------------------------------------------------------------------------------------------------

// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;



//----------------------------------------------------------------------------------------------------
// Caminho: service\GeoCodingClient .cs
// Namespace: gsApi.services
// Tipo: GeoCodingClient
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/services/GeoCodingClient.cs
using gsApi.dto.request;
using gsApi.dto.response;
using gsApi.exceptions;
using Microsoft.Extensions.Configuration; // Para IConfiguration
using Microsoft.Extensions.Logging;
using gsApi.DTOs.Request;
using gsApi.DTOs.Response;
using gsApi.Exceptions;
using System;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Json;
using System.Text.Json;
using System.Threading.Tasks;
using System.Web; // Para HttpUtility.UrlEncode

namespace gsApi.services
{
    public class GeoCodingClient : IGeoCodingClient
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<GeoCodingClient> _logger;
        private readonly string? _apiKey;
        private readonly string _googleApiUrl;

        public GeoCodingClient(HttpClient httpClient, ILogger<GeoCodingClient> logger, IConfiguration configuration)
        {
            _httpClient = httpClient; // BaseAddress (maps.googleapis.com) pode ser configurado no Program.cs
            _logger = logger;
            _apiKey = configuration["ExternalServices:GoogleGeocoding:ApiKey"];
            _googleApiUrl = configuration.GetValue<string>("ExternalServices:GoogleGeocoding:ApiUrl") ?? "https://maps.googleapis.com/maps/api/geocode/json";

            if (string.IsNullOrEmpty(_apiKey))
            {
                _logger.LogError("Chave da API do Google Geocoding (ExternalServices:GoogleGeocoding:ApiKey) não configurada no appsettings.json.");
                // Considerar lançar uma exceção aqui ou permitir que o serviço funcione sem chave (algumas APIs permitem uso limitado)
            }
        }

        public async Task<GeoCoordinatesDto?> GetCoordinatesFromAddressAsync(EnderecoGeoRequestDto enderecoDto)
        {
            if (string.IsNullOrWhiteSpace(enderecoDto.Logradouro) ||
                string.IsNullOrWhiteSpace(enderecoDto.Cidade) ||
                string.IsNullOrWhiteSpace(enderecoDto.Uf))
            {
                _logger.LogWarning("Dados de endereço insuficientes para geocodificação (requer logradouro, cidade, UF).");
                return null;
            }

            if (string.IsNullOrEmpty(_apiKey))
            {
                throw new InvalidOperationException("API Key do Google Geocoding não está configurada.");
            }

            var addressQueryBuilder = new List<string>();
            if (!string.IsNullOrWhiteSpace(enderecoDto.Logradouro)) addressQueryBuilder.Add(enderecoDto.Logradouro);
            if (!string.IsNullOrWhiteSpace(enderecoDto.Numero)) addressQueryBuilder.Add(enderecoDto.Numero);
            if (!string.IsNullOrWhiteSpace(enderecoDto.Bairro)) addressQueryBuilder.Add(enderecoDto.Bairro);
            if (!string.IsNullOrWhiteSpace(enderecoDto.Cidade)) addressQueryBuilder.Add(enderecoDto.Cidade);
            if (!string.IsNullOrWhiteSpace(enderecoDto.Uf)) addressQueryBuilder.Add(enderecoDto.Uf);
            if (!string.IsNullOrWhiteSpace(enderecoDto.Cep)) addressQueryBuilder.Add(enderecoDto.Cep.Replace("-", ""));
            addressQueryBuilder.Add("Brasil"); // Adicionar país para maior precisão

            string addressString = string.Join(", ", addressQueryBuilder.Where(s => !string.IsNullOrWhiteSpace(s)));

            // Componentes para restringir a busca ao Brasil e usar o CEP se disponível
            string components = "country:BR";
            if (!string.IsNullOrWhiteSpace(enderecoDto.Cep))
            {
                components += $"|postal_code:{enderecoDto.Cep.Replace("-", "")}";
            }


            var requestUri = $"{_googleApiUrl}?address={HttpUtility.UrlEncode(addressString)}&components={HttpUtility.UrlEncode(components)}&key={_apiKey}&language=pt-BR";
            _logger.LogInformation("Consultando Google Geocoding API: {RequestUri}", requestUri.Replace(_apiKey, "***API_KEY_OCULTADA***"));

            try
            {
                var response = await _httpClient.GetAsync(requestUri);
                var responseContent = await response.Content.ReadAsStringAsync(); // Ler como string para debug

                if (response.IsSuccessStatusCode)
                {
                    var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                    var apiResponse = JsonSerializer.Deserialize<GoogleGeocodingApiResponseDto>(responseContent, options);

                    if (apiResponse != null && apiResponse.Status == "OK" && apiResponse.Results != null && apiResponse.Results.Any())
                    {
                        var bestResult = apiResponse.Results.First();
                        if (bestResult.Geometry?.Location != null)
                        {
                            _logger.LogInformation("Coordenadas encontradas para: {AddressString}", addressString);
                            return new GeoCoordinatesDto
                            {
                                Latitude = bestResult.Geometry.Location.Latitude,
                                Longitude = bestResult.Geometry.Location.Longitude,
                                MatchedAddress = bestResult.FormattedAddress
                            };
                        }
                    }
                    _logger.LogWarning("Google Geocoding API retornou status {Status} ou nenhum resultado válido para {AddressString}. Resposta: {ApiResponse}", apiResponse?.Status, addressString, responseContent);
                    return null;
                }
                else
                {
                    _logger.LogError("Erro ao consultar Google Geocoding API para {AddressString}. Status: {StatusCode}. Resposta: {ResponseContent}",
                        addressString, response.StatusCode, responseContent);
                    throw new ServicoIndisponivelException($"Google Geocoding API retornou status: {response.StatusCode}");
                }
            }
            catch (HttpRequestException ex)
            {
                _logger.LogError(ex, "Erro de HttpRequest ao consultar Google Geocoding API para {AddressString}.", addressString);
                throw new ServicoIndisponivelException($"Erro de comunicação ao consultar o Google Geocoding API para o endereço.", ex);
            }
            catch (JsonException ex)
            {
                _logger.LogError(ex, "Erro de desserialização JSON ao consultar Google Geocoding API para {AddressString}.", addressString);
                throw new ServicoIndisponivelException($"Erro ao processar a resposta do Google Geocoding API.", ex);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro inesperado ao consultar Google Geocoding API para {AddressString}.", addressString);
                throw;
            }
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: service\IEmailNotificationService.cs
// Namespace: gsApi.services
// Tipo: IEmailNotificationService
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/services/IEmailNotificationService.cs
using gsApi.dto.request; // Para AlertableEventDto
using System.Threading.Tasks;

namespace gsApi.services
{
    public interface IEmailNotificationService
    {
        Task SendEventAlertEmailAsync(string recipientEmail, string userName, AlertableEventDto eventDetails);
        // Você pode adicionar outros métodos de envio de email aqui se necessário
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: service\IGeoCodingClient.cs
// Namespace: gsApi.services
// Tipo: IGeoCodingClient
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/services/IGeoCodingClient.cs
using gsApi.dto.request; // Para EnderecoGeoRequestDto
using gsApi.dto.response; // Para GeoCoordinatesDto
using gsApi.DTOs.Request;
using gsApi.DTOs.Response;
using System.Threading.Tasks;

namespace gsApi.services
{
    public interface IGeoCodingClient
    {
        Task<GeoCoordinatesDto?> GetCoordinatesFromAddressAsync(EnderecoGeoRequestDto enderecoDto);
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: service\INasaEonetClient.cs
// Namespace: gsApi.services
// Tipo: INasaEonetClient
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/services/INasaEonetClient.cs
using gsApi.dto.response; // Para NasaEonetApiResponseDto
using gsApi.model.DTOs.Response;
using System.Collections.Generic; // Para List
using System.Threading.Tasks;

namespace gsApi.services
{
    public interface INasaEonetClient
    {
        Task<NasaEonetApiResponseDto?> GetEventsAsync(
            int? limit = null,
            int? days = null,
            string? status = null,
            string? source = null,
            string? bbox = null, // Formato: W,S,E,N (minLon,minLat,maxLon,maxLat)
            string? startDate = null, // Formato: YYYY-MM-DD
            string? endDate = null    // Formato: YYYY-MM-DD
        );
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: service\IViaCepClient.cs
// Namespace: gsApi.services
// Tipo: IViaCepClient
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/services/IViaCepClient.cs
using gsApi.dto.response;
using gsApi.DTOs.Response;
using System.Threading.Tasks;

namespace gsApi.services // Namespace correto
{
    public interface IViaCepClient
    {
        Task<ViaCepResponseDto?> GetEnderecoByCepAsync(string cep);
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: service\NasaEonetClient.cs
// Namespace: gsApi.services
// Tipo: NasaEonetClient
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/services/NasaEonetClient.cs
using gsApi.dto.response;
using gsApi.exceptions;
using gsApi.Exceptions;
using gsApi.model.DTOs.Response;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Json;
using System.Text.Json;
using System.Threading.Tasks;
using System.Web; // Para HttpUtility

namespace gsApi.services
{
    public class NasaEonetClient : INasaEonetClient
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<NasaEonetClient> _logger;
        private readonly string _eonetApiEventUrl;


        public NasaEonetClient(HttpClient httpClient, ILogger<NasaEonetClient> logger, IConfiguration configuration)
        {
            _httpClient = httpClient; // BaseAddress (https://eonet.gsfc.nasa.gov/api/v3/) será configurada no Program.cs
            _logger = logger;
            // O endpoint específico de eventos (/events) será adicionado na chamada.
            _eonetApiEventUrl = configuration.GetValue<string>("ExternalServices:NasaEonet:EventsEndpoint") ?? "events"; // Padrão "events"
        }

        public async Task<NasaEonetApiResponseDto?> GetEventsAsync(
            int? limit = null,
            int? days = null,
            string? status = null,
            string? source = null,
            string? bbox = null,
            string? startDate = null,
            string? endDate = null)
        {
            var queryParams = new Dictionary<string, string?>();
            if (limit.HasValue) queryParams["limit"] = limit.ToString();

            // EONET API prioriza start/end se ambos 'days' e 'start'/'end' estiverem presentes.
            if (!string.IsNullOrWhiteSpace(startDate)) queryParams["start"] = startDate;
            if (!string.IsNullOrWhiteSpace(endDate)) queryParams["end"] = endDate;
            // Só adiciona 'days' se start e end não estiverem definidos.
            else if (days.HasValue) queryParams["days"] = days.ToString();

            if (!string.IsNullOrWhiteSpace(status)) queryParams["status"] = status;
            if (!string.IsNullOrWhiteSpace(source)) queryParams["source"] = source;
            if (!string.IsNullOrWhiteSpace(bbox)) queryParams["bbox"] = bbox;

            var queryString = HttpUtility.ParseQueryString(string.Empty);
            foreach (var kvp in queryParams.Where(kvp => kvp.Value != null))
            {
                queryString[kvp.Key] = kvp.Value;
            }

            string requestUri = _eonetApiEventUrl;
            if (queryString.Count > 0)
            {
                requestUri += $"?{queryString.ToString()}";
            }

            _logger.LogInformation("Consultando NASA EONET API: {BaseAddress}{RequestUri}", _httpClient.BaseAddress, requestUri);

            try
            {
                var response = await _httpClient.GetAsync(requestUri);
                var responseContent = await response.Content.ReadAsStringAsync(); // Ler para debug em caso de erro

                if (response.IsSuccessStatusCode)
                {
                    var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                    var apiResponse = JsonSerializer.Deserialize<NasaEonetApiResponseDto>(responseContent, options);
                    _logger.LogInformation("Dados da NASA EONET obtidos. Título: {Title}, Número de Eventos: {Count}",
                        apiResponse?.Title, apiResponse?.Events?.Count ?? 0);
                    return apiResponse;
                }
                else
                {
                    _logger.LogError("Erro ao consultar NASA EONET API. Status: {StatusCode}. Resposta: {ResponseContent}",
                        response.StatusCode, responseContent);
                    throw new ServicoIndisponivelException($"Serviço NASA EONET retornou status: {response.StatusCode}");
                }
            }
            catch (HttpRequestException ex)
            {
                _logger.LogError(ex, "Erro de HttpRequest ao consultar NASA EONET API.");
                throw new ServicoIndisponivelException("Erro de comunicação ao consultar o serviço NASA EONET.", ex);
            }
            catch (JsonException ex)
            {
                _logger.LogError(ex, "Erro de desserialização JSON ao consultar NASA EONET API.");
                throw new ServicoIndisponivelException("Erro ao processar a resposta do serviço NASA EONET.", ex);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro inesperado ao consultar NASA EONET API.");
                throw;
            }
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: service\SmtpSettings.cs
// Namespace: gsApi.services
// Tipo: SmtpSettings
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/services/EmailNotificationService.cs
using gsApi.dto.request;
using MailKit.Net.Smtp;
using MailKit.Security;
using Microsoft.Extensions.Configuration; // Para IConfiguration
using Microsoft.Extensions.Logging;
using MimeKit;
using MimeKit.Text;
using System;
using System.Threading.Tasks;

namespace gsApi.services
{
    public class SmtpSettings
    {
        public string Server { get; set; } = string.Empty;
        public int Port { get; set; }
        public string Username { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
        public string FromAddress { get; set; } = string.Empty;
        public string FromName { get; set; } = string.Empty;
        public bool UseSsl { get; set; } = true; // Padrão para true, pode ser configurável
    }

    public class EmailNotificationService : IEmailNotificationService
    {
        private readonly ILogger<EmailNotificationService> _logger;
        private readonly SmtpSettings _smtpSettings;

        public EmailNotificationService(ILogger<EmailNotificationService> logger, IConfiguration configuration)
        {
            _logger = logger;
            _smtpSettings = configuration.GetSection("SmtpSettings").Get<SmtpSettings>() ?? new SmtpSettings();

            if (string.IsNullOrEmpty(_smtpSettings.Server) || string.IsNullOrEmpty(_smtpSettings.FromAddress))
            {
                _logger.LogError("Configurações SMTP (SmtpSettings:Server e SmtpSettings:FromAddress) não encontradas ou incompletas no appsettings.json.");
                // Considerar lançar exceção se o envio de e-mail for crítico
            }
        }

        public async Task SendEventAlertEmailAsync(string recipientEmail, string userName, AlertableEventDto eventDetails)
        {
            if (string.IsNullOrEmpty(_smtpSettings.Server) || string.IsNullOrEmpty(recipientEmail))
            {
                _logger.LogWarning("Não foi possível enviar e-mail de alerta: configurações SMTP incompletas ou destinatário de e-mail nulo/vazio para o usuário {UserName}", userName);
                return; // Ou lançar exceção
            }

            _logger.LogInformation("Preparando para enviar e-mail de alerta para {RecipientEmail} sobre o evento {EventTitle}", recipientEmail, eventDetails.Title);

            try
            {
                var email = new MimeMessage();
                email.From.Add(new MailboxAddress(_smtpSettings.FromName, _smtpSettings.FromAddress));
                email.To.Add(MailboxAddress.Parse(recipientEmail));
                email.Subject = $"Alerta de Desastre: {eventDetails.Title ?? "Novo Evento"} Próximo à Sua Localização!";

                var bodyBuilder = new BodyBuilder();
                bodyBuilder.HtmlBody = $@"
                    <p>Olá, {userName}!</p>
                    <p>Detectamos um evento de desastre natural próximo a uma de suas localizações cadastradas ou de seu interesse:</p>
                    <p><strong>Evento:</strong> {eventDetails.Title ?? "N/A"}</p>
                    {(string.IsNullOrWhiteSpace(eventDetails.EventDate) ? "" : $"<p><strong>Data do Evento:</strong> {eventDetails.EventDate}</p>")}
                    {(string.IsNullOrWhiteSpace(eventDetails.Description) ? "" : $"<p><strong>Descrição:</strong> {eventDetails.Description}</p>")}
                    {(string.IsNullOrWhiteSpace(eventDetails.Link) ? "" : $"<p><strong>Mais informações em:</strong> <a href='{eventDetails.Link}'>{eventDetails.Link}</a></p>")}
                    <p>Por favor, tome as precauções necessárias.</p>
                    <p>Atenciosamente,<br/>Equipe GS Alerta Desastres</p>";

                email.Body = bodyBuilder.ToMessageBody();

                using var smtp = new SmtpClient();
                // Definir SecureSocketOptions com base na configuração UseSsl e porta
                SecureSocketOptions socketOptions = SecureSocketOptions.Auto;
                if (_smtpSettings.UseSsl)
                {
                    socketOptions = _smtpSettings.Port == 465 ? SecureSocketOptions.SslOnConnect : SecureSocketOptions.StartTls;
                }
                else
                {
                    socketOptions = SecureSocketOptions.None;
                }

                await smtp.ConnectAsync(_smtpSettings.Server, _smtpSettings.Port, socketOptions);
                _logger.LogInformation("Conectado ao servidor SMTP: {SmtpServer}:{SmtpPort} com UseSsl={UseSsl}", _smtpSettings.Server, _smtpSettings.Port, _smtpSettings.UseSsl);

                if (!string.IsNullOrEmpty(_smtpSettings.Username) && !string.IsNullOrEmpty(_smtpSettings.Password))
                {
                    await smtp.AuthenticateAsync(_smtpSettings.Username, _smtpSettings.Password);
                    _logger.LogInformation("Autenticado no servidor SMTP com usuário {SmtpUsername}", _smtpSettings.Username);
                }

                await smtp.SendAsync(email);
                _logger.LogInformation("E-mail de alerta enviado com sucesso para {RecipientEmail} sobre o evento {EventId}", recipientEmail, eventDetails.EventId);
                await smtp.DisconnectAsync(true);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Falha ao enviar e-mail de alerta para {RecipientEmail} sobre o evento {EventId}.", recipientEmail, eventDetails.EventId);
                // Não relance a exceção aqui necessariamente, para não quebrar o fluxo principal se o e-mail for uma notificação secundária.
                // Ou lance uma exceção customizada se o envio de e-mail for crítico.
                // throw new ServicoIndisponivelException("Falha ao enviar notificação por e-mail.", ex);
            }
        }
    }
}



//----------------------------------------------------------------------------------------------------
// Caminho: service\ViaCepClient .cs
// Namespace: gsApi.services
// Tipo: ViaCepClient
//----------------------------------------------------------------------------------------------------

﻿// File: gsApi/services/ViaCepClient.cs
using gsApi.dto.response;
using gsApi.DTOs.Response;
using gsApi.exceptions;
using gsApi.Exceptions;
using Microsoft.Extensions.Logging;
using System;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Json; // Para ReadFromJsonAsync
using System.Text.Json;
using System.Threading.Tasks;

namespace gsApi.services
{
    /// <summary>
    /// Cliente para interagir com a API do ViaCEP para consulta de endereços por CEP.
    /// </summary>
    public class ViaCepClient : IViaCepClient
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<ViaCepClient> _logger;

        /// <summary>
        /// Construtor do ViaCepClient.
        /// </summary>
        /// <param name="httpClient">Instância de HttpClient configurada (com BaseAddress para ViaCEP).</param>
        /// <param name="logger">Instância do logger.</param>
        public ViaCepClient(HttpClient httpClient, ILogger<ViaCepClient> logger)
        {
            _httpClient = httpClient;
            _logger = logger;
            if (_httpClient.BaseAddress == null)
            {
                _logger.LogCritical("ViaCepClient: HttpClient BaseAddress não foi configurado. Verifique a configuração do serviço no Program.cs e a URL base no appsettings.json (ExternalServices:ViaCep:BaseUrl).");
                // É crucial que o BaseAddress seja configurado no Program.cs
                // throw new InvalidOperationException("BaseAddress do HttpClient para ViaCepClient não está configurado.");
            }
        }

        /// <summary>
        /// Obtém informações de endereço para um determinado CEP.
        /// </summary>
        /// <param name="cep">O CEP a ser consultado (pode conter hífen ou ser apenas números).</param>
        /// <returns>Um <see cref="ViaCepResponseDto"/> com os dados do endereço se encontrado; caso contrário, null.</returns>
        /// <exception cref="ServicoIndisponivelException">Se ocorrer um erro na comunicação com o serviço ViaCEP ou no processamento da resposta.</exception>
        /// <exception cref="InvalidOperationException">Se o BaseAddress do HttpClient não estiver configurado.</exception>
        public async Task<ViaCepResponseDto?> GetEnderecoByCepAsync(string cep)
        {
            if (string.IsNullOrWhiteSpace(cep))
            {
                _logger.LogWarning("VIA_CEP_CLIENT: Tentativa de buscar CEP nulo ou vazio.");
                return null;
            }

            if (_httpClient.BaseAddress == null)
            {
                // Lançar exceção aqui se o BaseAddress não estiver configurado,
                // pois a chamada subsequente com URI relativa falhará.
                var errorMsg = "VIA_CEP_CLIENT: BaseAddress do HttpClient não configurado para ViaCepClient. Não é possível fazer a requisição.";
                _logger.LogCritical(errorMsg);
                throw new InvalidOperationException(errorMsg);
            }

            var cepFormatado = new string(cep.Where(char.IsDigit).ToArray());
            _logger.LogDebug("VIA_CEP_CLIENT: CEP original '{OriginalCep}', CEP formatado '{CepFormatado}'.", cep, cepFormatado);

            if (cepFormatado.Length != 8)
            {
                _logger.LogWarning("VIA_CEP_CLIENT: CEP formatado '{CepFormatado}' (original: '{OriginalCep}') não possui 8 dígitos.", cepFormatado, cep);
                return null;
            }

            var requestUri = $"{cepFormatado}/json/"; // URI Relativa
            _logger.LogInformation("VIA_CEP_CLIENT: Consultando ViaCEP. URI Relativa: '{RequestUri}', BaseAddress: '{BaseAddress}'", requestUri, _httpClient.BaseAddress);

            try
            {
                var response = await _httpClient.GetAsync(requestUri);
                var responseContent = await response.Content.ReadAsStringAsync();

                _logger.LogDebug("VIA_CEP_CLIENT: Resposta do ViaCEP - Status: {StatusCode}, Conteúdo (primeiros 500 chars): {ResponseContentSnippet}", response.StatusCode, responseContent.Length > 500 ? responseContent.Substring(0, 500) : responseContent);

                if (response.IsSuccessStatusCode)
                {
                    var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                    ViaCepResponseDto? viaCepDto = null;
                    try
                    {
                        viaCepDto = JsonSerializer.Deserialize<ViaCepResponseDto>(responseContent, options);
                    }
                    catch (JsonException jsonEx)
                    {
                        _logger.LogError(jsonEx, "VIA_CEP_CLIENT: Erro de desserialização JSON para CEP '{CepFormatado}'. Conteúdo da Resposta: {ResponseContent}", cepFormatado, responseContent);
                        throw new ServicoIndisponivelException($"Erro ao processar a resposta (JSON inválido) do ViaCEP para o CEP {cepFormatado}.", jsonEx);
                    }

                    if (viaCepDto != null && viaCepDto.Erro)
                    {
                        _logger.LogInformation("VIA_CEP_CLIENT: CEP '{CepFormatado}' não encontrado no ViaCEP (serviço retornou 'erro: true').", cepFormatado);
                        return null;
                    }

                    if (viaCepDto == null)
                    {
                        _logger.LogWarning("VIA_CEP_CLIENT: Resposta do ViaCEP desserializada para null, mas com status de sucesso, para CEP '{CepFormatado}'. Conteúdo: {ResponseContent}", cepFormatado, responseContent);
                        return null;
                    }

                    _logger.LogInformation("VIA_CEP_CLIENT: Dados do CEP '{CepFormatado}' obtidos com sucesso do ViaCEP.", cepFormatado);
                    return viaCepDto;
                }
                else
                {
                    _logger.LogError("VIA_CEP_CLIENT: Erro ao consultar ViaCEP para CEP '{CepFormatado}'. Status: {StatusCode}, Resposta: {ResponseContent}",
                        cepFormatado, response.StatusCode, responseContent);
                    throw new ServicoIndisponivelException($"Serviço ViaCEP retornou status HTTP: {response.StatusCode}.");
                }
            }
            catch (InvalidOperationException ex) when (ex.Message.Contains("BaseAddress must be set"))
            {
                // Este catch é para o caso do BaseAddress ser verificado novamente aqui, mas a checagem no topo do método já deveria pegar.
                _logger.LogCritical(ex, "VIA_CEP_CLIENT: Tentativa de chamada HTTP sem BaseAddress configurado para CEP {CepFormatado}.", cepFormatado);
                throw; // Relança a exceção original
            }
            catch (HttpRequestException ex)
            {
                _logger.LogError(ex, "VIA_CEP_CLIENT: Erro de HttpRequest (rede/DNS?) ao consultar ViaCEP para CEP '{CepFormatado}'. HttpClient BaseAddress: {BaseAddress}", cepFormatado, _httpClient.BaseAddress);
                throw new ServicoIndisponivelException($"Erro de comunicação ao consultar o ViaCEP para o CEP {cepFormatado}. Verifique a conexão ou a URL base do serviço.", ex);
            }
            catch (ServicoIndisponivelException) { throw; } // Relança exceções já tratadas e específicas do serviço
            catch (Exception ex)
            {
                _logger.LogError(ex, "VIA_CEP_CLIENT: Erro inesperado ao consultar ViaCEP para CEP '{CepFormatado}'.", cepFormatado);
                throw new ServicoIndisponivelException($"Ocorreu um erro inesperado ao tentar consultar o ViaCEP para o CEP {cepFormatado}.", ex);
            }
        }
    }
}
