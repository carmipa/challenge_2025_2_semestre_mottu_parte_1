// Script: converte-projeto-java-em-txt-unico (v5.1)
// Projeto: mottu-api-restful
// Data de geração: 2025-09-10 14:48:41

// Estrutura de diretórios do projeto (simplificada):
mottu-api-restful/
    backup/
        mottu-gradle/
            gradle/
                wrapper/
            outro/
            src/
                main/
                    java/
                        br/
                            com/
                                fiap/
                                    mottu/
                                        config/
                                        controller/
                                        dto/
                                            box/
                                            cliente/
                                            contato/
                                            dashboard/
                                            endereco/
                                            estacionamento/
                                            patio/
                                            rastreamento/
                                            veiculo/
                                            zona/
                                        exception/
                                            handler/
                                        external/
                                            outros/
                                            viacep/
                                        filter/
                                        mapper/
                                        model/
                                            relacionamento/
                                        repository/
                                            relacionamento/
                                        service/
                                            ocr/
                                        specification/
                                        validation/
                    resources/
                        classifiers/
                        static/
                        templates/
                        tessdata/
                            configs/
                            script/
                            tessconfigs/
                test/
                    java/
                        br/
                            com/
                                fiap/
                                    mottu/
        mottu-maven/
            mottu/
        mottu-web/
            .next/
                cache/
                    images/
                        -EhxdmQ7xIO2QGUgY1gFTfcJJ6hCRVEzcf-qvWSBxPQ/
                        6_JD39joBQGCQgWW1m2hi-YRPnwlTc00GKkAYJiboGE/
                        9hI-57P-Z1mZXpqh7F0S0_qLZo2viegW6UcxJsLKSxU/
                        DoFB6Tis_fmGZ1WUDx-LHUlmcT1nib5zJj1e3hQ_USA/
                        EbiAr0RviwjNcRr1-YxE_YjauUR0MU7v6cILH2YIfAM/
                        RLBlZokyxMe3gO-zRVWGlnphJudly5TQ3h9DddA1UE4/
                        RdKj542ujE8ZSGobPSpnX1v34tG3Ndf-mXw1G2HsdHM/
                        TboyfRepQhxiyjGr17_64qchKH4vKU1PJnbE9hQGVXs/
                        bFtXwATb4cvVt3atU8uafjXtbUsGY_Bqcux64kX0W2A/
                    swc/
                        plugins/
                            v7_windows_x86_64_10.0.0/
                            v7_windows_x86_64_8.0.0/
                            windows_x86_64_18.0.0/
                    webpack/
                        client-development/
                        client-development-fallback/
                        server-development/
                server/
                    app/
                        box/
                            detalhes/
                                [id]/
                            listar/
                        clientes/
                            cadastrar/
                            listar/
                        contato/
                        dashboard/
                        favicon.ico/
                        mapa-2d/
                        mapa-do-site/
                        patio/
                            listar/
                        radar/
                            buscar/
                        veiculo/
                            cadastrar/
                            listar/
                        zona/
                            listar/
                    vendor-chunks/
                static/
                    chunks/
                        app/
                            box/
                                detalhes/
                                    [id]/
                                listar/
                            clientes/
                                cadastrar/
                                listar/
                            contato/
                            dashboard/
                            mapa-2d/
                            mapa-do-site/
                            patio/
                                listar/
                            radar/
                                buscar/
                            veiculo/
                                cadastrar/
                                listar/
                            zona/
                                listar/
                    css/
                        app/
                            contato/
                    development/
                    media/
                    webpack/
                        app/
                            dashboard/
                            mapa-2d/
                types/
                    app/
                        box/
                            detalhes/
                                [id]/
                            listar/
                        clientes/
                            cadastrar/
                            listar/
                        contato/
                        dashboard/
                        mapa-2d/
                        mapa-do-site/
                        patio/
                            listar/
                        radar/
                            buscar/
                        veiculo/
                            cadastrar/
                            listar/
                        zona/
                            listar/
            public/
                fotos-equipe/
            src/
                app/
                    box/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                            [id]/
                        detalhes/
                            [id]/
                        listar/
                    clientes/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                            [id]/
                        detalhes/
                            [id]/
                        listar/
                    contato/
                    dashboard/
                    inicio/
                    mapa-2d/
                    mapa-do-site/
                    patio/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                            [id]/
                        detalhes/
                            [id]/
                        listar/
                    radar/
                        armazenar/
                        buscar/
                        mobile-upload/
                            [sessionId]/
                    veiculo/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                            [id]/
                        detalhes/
                            [id]/
                        listar/
                    zona/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                            [id]/
                        detalhes/
                            [id]/
                        listar/
                components/
                    forms/
                    map/
                types/
                utils/
                    api/
                    map/
        mottu-web-ini/
            public/
            src/
                app/
                    box/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                            [id]/
                        listar/
                    clientes/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                        listar/
                    inicio/
                    patio/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                        listar/
                    veiculo/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                            [id]/
                        listar/
                    zona/
                        alterar/
                            [id]/
                        buscar/
                        cadastrar/
                        deletar/
                            [id]/
                        listar/
                components/
                    forms/
                types/
                utils/
    mottu-gradle/
        gradle/
            wrapper/
        outro/
        src/
            main/
                java/
                    br/
                        com/
                            fiap/
                                mottu/
                                    config/
                                    controller/
                                    dto/
                                        box/
                                        cliente/
                                        contato/
                                        dashboard/
                                        endereco/
                                        estacionamento/
                                        patio/
                                        rastreamento/
                                        veiculo/
                                        zona/
                                    exception/
                                        handler/
                                    external/
                                        viacep/
                                    filter/
                                    mapper/
                                    model/
                                        relacionamento/
                                    repository/
                                        relacionamento/
                                    service/
                                        ocr/
                                    specification/
                                    validation/
                resources/
                    classifiers/
                    tessdata/
                        configs/
                        tessconfigs/
            test/
                java/
                    br/
                        com/
                            fiap/
                                mottu/
    mottu-web/
        .next/
            cache/
                swc/
                    plugins/
                        windows_x86_64_18.0.0/
                webpack/
                    client-development/
                    server-development/
            server/
                app/
                    clientes/
                        detalhes/
                            [id]/
                        listar/
                    dashboard/
                    favicon.ico/
                    mapa-2d/
                    radar/
                        armazenar/
                    veiculo/
                        cadastrar/
                    zona/
                        listar/
                pages/
                vendor-chunks/
            static/
                chunks/
                    app/
                        clientes/
                            detalhes/
                                [id]/
                            listar/
                        dashboard/
                        mapa-2d/
                        radar/
                            armazenar/
                        veiculo/
                            cadastrar/
                        zona/
                            listar/
                    pages/
                css/
                    app/
                development/
                media/
                webpack/
                    app/
            types/
                app/
                    clientes/
                        detalhes/
                            [id]/
                        listar/
                    dashboard/
                    mapa-2d/
                    radar/
                        armazenar/
                    veiculo/
                        cadastrar/
                    zona/
                        listar/
        node_modules/
            .bin/
            @alloc/
                quick-lru/
            @babel/
                runtime-corejs3/
                    core-js/
                        array/
                        date/
                        instance/
                        json/
                        math/
                        number/
                        object/
                        reflect/
                        string/
                        symbol/
                    core-js-stable/
                        array/
                        date/
                        instance/
                        json/
                        math/
                        number/
                        object/
                        reflect/
                        string/
                        symbol/
                    helpers/
                        esm/
                    regenerator/
            @emnapi/
                core/
                    dist/
                runtime/
                    dist/
                wasi-threads/
                    dist/
            @eslint/
                config-array/
                    dist/
                        cjs/
                            std__path/
                        esm/
                            std__path/
                config-helpers/
                    dist/
                        cjs/
                        esm/
                core/
                    dist/
                        cjs/
                        esm/
                eslintrc/
                    conf/
                    dist/
                    lib/
                        config-array/
                        shared/
                        types/
                js/
                    src/
                        configs/
                    types/
                object-schema/
                    dist/
                        cjs/
                        esm/
                plugin-kit/
                    dist/
                        cjs/
                        esm/
            @eslint-community/
                eslint-utils/
                    node_modules/
                        eslint-visitor-keys/
                            dist/
                            lib/
                regexpp/
            @floating-ui/
                core/
                    dist/
                dom/
                    dist/
                react/
                    dist/
                    utils/
                react-dom/
                    dist/
                utils/
                    dist/
                    dom/
            @headlessui/
                react/
                    dist/
                        components/
                            button/
                            checkbox/
                            close-button/
                            combobox/
                            combobox-button/
                            combobox-input/
                            combobox-label/
                            combobox-option/
                            combobox-options/
                            data-interactive/
                            description/
                            dialog/
                            dialog-description/
                            dialog-panel/
                            dialog-title/
                            disclosure/
                            disclosure-button/
                            disclosure-panel/
                            field/
                            fieldset/
                            focus-trap/
                            focus-trap-features/
                            input/
                            label/
                            legend/
                            listbox/
                            listbox-button/
                            listbox-label/
                            listbox-option/
                            listbox-options/
                            listbox-selected-option/
                            menu/
                            menu-button/
                            menu-heading/
                            menu-item/
                            menu-items/
                            menu-section/
                            menu-separator/
                            popover/
                            popover-backdrop/
                            popover-button/
                            popover-group/
                            popover-overlay/
                            popover-panel/
                            portal/
                            radio/
                            radio-group/
                            radio-group-description/
                            radio-group-label/
                            radio-group-option/
                            select/
                            switch/
                            switch-description/
                            switch-group/
                            switch-label/
                            tab/
                            tab-group/
                            tab-list/
                            tab-panel/
                            tab-panels/
                            tabs/
                            textarea/
                            tooltip/
                            transition/
                            transition-child/
                            transitions/
                        hooks/
                            __mocks__/
                            document-overflow/
                        internal/
                        machines/
                        utils/
            @humanfs/
                core/
                    dist/
                    src/
                node/
                    dist/
                    node_modules/
                        @humanwhocodes/
                            retry/
                                dist/
                    src/
            @humanwhocodes/
                module-importer/
                    dist/
                    src/
                retry/
                    dist/
            @img/
                sharp-win32-x64/
                    lib/
            @isaacs/
                fs-minipass/
                    dist/
                        commonjs/
                        esm/
            @jridgewell/
                gen-mapping/
                    dist/
                        types/
                    src/
                    types/
                remapping/
                    dist/
                    src/
                    types/
                resolve-uri/
                    dist/
                        types/
                sourcemap-codec/
                    dist/
                    src/
                    types/
                trace-mapping/
                    dist/
                    src/
                    types/
            @kurkle/
                color/
                    dist/
            @napi-rs/
                wasm-runtime/
                    dist/
            @next/
                env/
                    dist/
                eslint-plugin-next/
                    dist/
                        rules/
                        utils/
                swc-win32-x64-msvc/
            @nodelib/
                fs.scandir/
                    out/
                        adapters/
                        providers/
                        types/
                        utils/
                fs.stat/
                    out/
                        adapters/
                        providers/
                        types/
                fs.walk/
                    out/
                        providers/
                        readers/
                        types/
            @nolyfill/
                is-core-module/
            @react-aria/
                focus/
                    dist/
                    src/
                interactions/
                    dist/
                    src/
                ssr/
                    dist/
                    src/
                utils/
                    dist/
                    src/
                        shadowdom/
            @react-leaflet/
                core/
                    lib/
            @react-stately/
                flags/
                    dist/
                    src/
                utils/
                    dist/
                    src/
            @react-types/
                shared/
                    src/
            @reduxjs/
                toolkit/
                    dist/
                        cjs/
                        query/
                            cjs/
                            react/
                                cjs/
                        react/
                            cjs/
                    query/
                        react/
                    react/
                    src/
                        dynamicMiddleware/
                            react/
                            tests/
                        entities/
                            tests/
                                fixtures/
                        listenerMiddleware/
                            tests/
                        query/
                            core/
                                buildMiddleware/
                            react/
                            tests/
                                mocks/
                            utils/
                        react/
                        tests/
                            utils/
            @rtsao/
                scc/
            @rushstack/
                eslint-patch/
                    lib/
                        eslint-bulk-suppressions/
                            cli/
                                utils/
                        exports/
            @standard-schema/
                spec/
                    dist/
                utils/
                    dist/
            @swc/
                helpers/
                    _/
                        _apply_decorated_descriptor/
                        _apply_decs_2203_r/
                        _array_like_to_array/
                        _array_with_holes/
                        _array_without_holes/
                        _assert_this_initialized/
                        _async_generator/
                        _async_generator_delegate/
                        _async_iterator/
                        _async_to_generator/
                        _await_async_generator/
                        _await_value/
                        _call_super/
                        _check_private_redeclaration/
                        _class_apply_descriptor_destructure/
                        _class_apply_descriptor_get/
                        _class_apply_descriptor_set/
                        _class_apply_descriptor_update/
                        _class_call_check/
                        _class_check_private_static_access/
                        _class_check_private_static_field_descriptor/
                        _class_extract_field_descriptor/
                        _class_name_tdz_error/
                        _class_private_field_destructure/
                        _class_private_field_get/
                        _class_private_field_init/
                        _class_private_field_loose_base/
                        _class_private_field_loose_key/
                        _class_private_field_set/
                        _class_private_field_update/
                        _class_private_method_get/
                        _class_private_method_init/
                        _class_private_method_set/
                        _class_static_private_field_destructure/
                        _class_static_private_field_spec_get/
                        _class_static_private_field_spec_set/
                        _class_static_private_field_update/
                        _class_static_private_method_get/
                        _construct/
                        _create_class/
                        _create_for_of_iterator_helper_loose/
                        _create_super/
                        _decorate/
                        _defaults/
                        _define_enumerable_properties/
                        _define_property/
                        _dispose/
                        _export_star/
                        _extends/
                        _get/
                        _get_prototype_of/
                        _identity/
                        _inherits/
                        _inherits_loose/
                        _initializer_define_property/
                        _initializer_warning_helper/
                        _instanceof/
                        _interop_require_default/
                        _interop_require_wildcard/
                        _is_native_function/
                        _is_native_reflect_construct/
                        _iterable_to_array/
                        _iterable_to_array_limit/
                        _iterable_to_array_limit_loose/
                        _jsx/
                        _new_arrow_check/
                        _non_iterable_rest/
                        _non_iterable_spread/
                        _object_destructuring_empty/
                        _object_spread/
                        _object_spread_props/
                        _object_without_properties/
                        _object_without_properties_loose/
                        _overload_yield/
                        _possible_constructor_return/
                        _read_only_error/
                        _set/
                        _set_prototype_of/
                        _skip_first_generator_next/
                        _sliced_to_array/
                        _sliced_to_array_loose/
                        _super_prop_base/
                        _tagged_template_literal/
                        _tagged_template_literal_loose/
                        _throw/
                        _to_array/
                        _to_consumable_array/
                        _to_primitive/
                        _to_property_key/
                        _ts_add_disposable_resource/
                        _ts_decorate/
                        _ts_dispose_resources/
                        _ts_generator/
                        _ts_metadata/
                        _ts_param/
                        _ts_values/
                        _type_of/
                        _unsupported_iterable_to_array/
                        _update/
                        _using/
                        _using_ctx/
                        _wrap_async_generator/
                        _wrap_native_super/
                        _write_only_error/
                        index/
                    cjs/
                    esm/
                    scripts/
                    src/
            @tailwindcss/
                node/
                    dist/
                oxide/
                    scripts/
                oxide-win32-x64-msvc/
                postcss/
                    dist/
            @tanstack/
                react-virtual/
                    dist/
                        cjs/
                        esm/
                    src/
                virtual-core/
                    dist/
                        cjs/
                        esm/
                    src/
            @tybys/
                wasm-util/
                    dist/
                    lib/
                        cjs/
                            wasi/
                        mjs/
                            wasi/
            @types/
                d3-array/
                d3-color/
                d3-ease/
                d3-interpolate/
                d3-path/
                d3-scale/
                d3-shape/
                d3-time/
                d3-timer/
                estree/
                geojson/
                json-schema/
                json5/
                leaflet/
                node/
                    assert/
                    compatibility/
                    dns/
                    fs/
                    readline/
                    stream/
                    timers/
                    ts5.6/
                react/
                    ts5.0/
                        v18/
                            ts5.0/
                react-dom/
                    test-utils/
                use-sync-external-store/
                    shim/
            @typescript-eslint/
                eslint-plugin/
                    dist/
                        configs/
                            eslintrc/
                            flat/
                        rules/
                            enum-utils/
                            naming-convention-utils/
                            prefer-optional-chain-utils/
                        util/
                    node_modules/
                        ignore/
                parser/
                    dist/
                project-service/
                    dist/
                scope-manager/
                    dist/
                        definition/
                        lib/
                        referencer/
                        scope/
                        variable/
                tsconfig-utils/
                    dist/
                type-utils/
                    dist/
                        typeOrValueSpecifiers/
                types/
                    dist/
                        generated/
                typescript-estree/
                    dist/
                        create-program/
                        jsx/
                        parseSettings/
                        ts-estree/
                    node_modules/
                        brace-expansion/
                            .github/
                        fast-glob/
                            out/
                                managers/
                                providers/
                                    filters/
                                    matchers/
                                    transformers/
                                readers/
                                types/
                                utils/
                        glob-parent/
                        minimatch/
                            dist/
                                commonjs/
                                esm/
                utils/
                    dist/
                        ast-utils/
                            eslint-utils/
                        eslint-utils/
                        ts-eslint/
                            eslint/
                        ts-utils/
                visitor-keys/
                    dist/
            @unrs/
                resolver-binding-win32-x64-msvc/
            acorn/
                dist/
            acorn-jsx/
            ajv/
                dist/
                lib/
                    compile/
                    dot/
                    dotjs/
                    refs/
                scripts/
            ansi-styles/
            argparse/
                lib/
            aria-query/
                lib/
                    etc/
                        roles/
                            abstract/
                            dpub/
                            graphics/
                            literal/
                    util/
            array-buffer-byte-length/
                .github/
                test/
            array-includes/
                .github/
                test/
            array.prototype.findlast/
                .github/
                test/
            array.prototype.findlastindex/
                .github/
                test/
            array.prototype.flat/
                .github/
                test/
            array.prototype.flatmap/
                .github/
                test/
            array.prototype.tosorted/
                .github/
                test/
            arraybuffer.prototype.slice/
                test/
            ast-types-flow/
                lib/
            async-function/
                .github/
                test/
            asynckit/
                lib/
            available-typed-arrays/
                .github/
                test/
            axe-core/
                locales/
            axios/
                dist/
                    browser/
                    esm/
                    node/
                lib/
                    adapters/
                    cancel/
                    core/
                    defaults/
                    env/
                        classes/
                    helpers/
                    platform/
                        browser/
                            classes/
                        common/
                        node/
                            classes/
            axobject-query/
                lib/
                    etc/
                        objects/
                    util/
            balanced-match/
                .github/
            bmp-js/
                lib/
                test/
            brace-expansion/
            braces/
                lib/
            call-bind/
                .github/
                test/
            call-bind-apply-helpers/
                .github/
                test/
            call-bound/
                .github/
                test/
            callsites/
            caniuse-lite/
                data/
                    features/
                    regions/
                dist/
                    lib/
                    unpacker/
            chalk/
                source/
            chart.js/
                auto/
                dist/
                    chunks/
                    controllers/
                    core/
                    elements/
                    helpers/
                    platform/
                    plugins/
                        plugin.filler/
                    scales/
                    types/
                helpers/
            chownr/
                dist/
                    commonjs/
                    esm/
            client-only/
            clsx/
                dist/
            color/
            color-convert/
            color-name/
            color-string/
            combined-stream/
                lib/
            concat-map/
                example/
                test/
            core-js-pure/
                actual/
                    array/
                        virtual/
                    array-buffer/
                    async-disposable-stack/
                    async-iterator/
                    data-view/
                    date/
                    disposable-stack/
                    dom-collections/
                    dom-exception/
                    error/
                    function/
                        virtual/
                    instance/
                    iterator/
                    json/
                    map/
                    math/
                    number/
                        virtual/
                    object/
                    promise/
                    reflect/
                    regexp/
                    set/
                    string/
                        virtual/
                    symbol/
                    typed-array/
                    url/
                    url-search-params/
                    weak-map/
                    weak-set/
                es/
                    array/
                        virtual/
                    array-buffer/
                    async-disposable-stack/
                    async-iterator/
                    data-view/
                    date/
                    disposable-stack/
                    error/
                    function/
                        virtual/
                    instance/
                    iterator/
                    json/
                    map/
                    math/
                    number/
                        virtual/
                    object/
                    promise/
                    reflect/
                    regexp/
                    set/
                    string/
                        virtual/
                    symbol/
                    typed-array/
                    weak-map/
                    weak-set/
                features/
                    array/
                        virtual/
                    array-buffer/
                    async-disposable-stack/
                    async-iterator/
                    bigint/
                    data-view/
                    date/
                    disposable-stack/
                    dom-collections/
                    dom-exception/
                    error/
                    function/
                        virtual/
                    instance/
                    iterator/
                    json/
                    map/
                    math/
                    number/
                        virtual/
                    object/
                    observable/
                    promise/
                    reflect/
                    regexp/
                    set/
                    string/
                        virtual/
                    symbol/
                    typed-array/
                    url/
                    url-search-params/
                    weak-map/
                    weak-set/
                full/
                    array/
                        virtual/
                    array-buffer/
                    async-disposable-stack/
                    async-iterator/
                    bigint/
                    data-view/
                    date/
                    disposable-stack/
                    dom-collections/
                    dom-exception/
                    error/
                    function/
                        virtual/
                    instance/
                    iterator/
                    json/
                    map/
                    math/
                    number/
                        virtual/
                    object/
                    observable/
                    promise/
                    reflect/
                    regexp/
                    set/
                    string/
                        virtual/
                    symbol/
                    typed-array/
                    url/
                    url-search-params/
                    weak-map/
                    weak-set/
                internals/
                modules/
                proposals/
                stable/
                    array/
                        virtual/
                    array-buffer/
                    async-disposable-stack/
                    async-iterator/
                    data-view/
                    date/
                    disposable-stack/
                    dom-collections/
                    dom-exception/
                    error/
                    function/
                        virtual/
                    instance/
                    iterator/
                    json/
                    map/
                    math/
                    number/
                        virtual/
                    object/
                    promise/
                    reflect/
                    regexp/
                    set/
                    string/
                        virtual/
                    symbol/
                    typed-array/
                    url/
                    url-search-params/
                    weak-map/
                    weak-set/
                stage/
                web/
            cross-spawn/
                lib/
                    util/
            csstype/
            d3-array/
                dist/
                src/
                    threshold/
            d3-color/
                dist/
                src/
            d3-ease/
                dist/
                src/
            d3-format/
                dist/
                locale/
                src/
            d3-interpolate/
                dist/
                src/
                    transform/
            d3-path/
                dist/
                src/
            d3-scale/
                dist/
                src/
            d3-shape/
                dist/
                src/
                    curve/
                    offset/
                    order/
                    symbol/
            d3-time/
                dist/
                src/
            d3-time-format/
                dist/
                locale/
                src/
            d3-timer/
                dist/
                src/
            damerau-levenshtein/
                scripts/
                test/
            data-view-buffer/
                .github/
                test/
            data-view-byte-length/
                .github/
                test/
            data-view-byte-offset/
                .github/
                test/
            debug/
                src/
            decimal.js-light/
                doc/
            deep-is/
                example/
                test/
            define-data-property/
                .github/
                test/
            define-properties/
                .github/
            delayed-stream/
                lib/
            detect-libc/
                lib/
            doctrine/
                lib/
            dunder-proto/
                .github/
                test/
            emoji-regex/
                es2015/
            enhanced-resolve/
                lib/
                    util/
            es-abstract/
                2015/
                    tables/
                2016/
                    tables/
                2017/
                    tables/
                2018/
                    tables/
                2019/
                    tables/
                2020/
                    BigInt/
                    Number/
                    tables/
                2021/
                    BigInt/
                    Number/
                    tables/
                2022/
                    BigInt/
                    Number/
                    tables/
                2023/
                    BigInt/
                    Number/
                    tables/
                2024/
                    BigInt/
                    Number/
                    tables/
                2025/
                    BigInt/
                    Number/
                    tables/
                5/
                helpers/
                    records/
                operations/
            es-define-property/
                .github/
                test/
            es-errors/
                .github/
                test/
            es-iterator-helpers/
                .github/
                Iterator/
                Iterator.concat/
                Iterator.from/
                Iterator.prototype/
                Iterator.prototype.constructor/
                Iterator.prototype.drop/
                Iterator.prototype.every/
                Iterator.prototype.filter/
                Iterator.prototype.find/
                Iterator.prototype.flatMap/
                Iterator.prototype.forEach/
                Iterator.prototype.map/
                Iterator.prototype.reduce/
                Iterator.prototype.some/
                Iterator.prototype.take/
                Iterator.prototype.toArray/
                Iterator.zip/
                Iterator.zipKeyed/
                IteratorHelperPrototype/
                WrapForValidIteratorPrototype/
                aos/
                test/
                    helpers/
            es-object-atoms/
                .github/
                test/
            es-set-tostringtag/
                test/
            es-shim-unscopables/
                .github/
                test/
            es-to-primitive/
                .github/
                helpers/
                test/
            es-toolkit/
                compat/
                dist/
                    _internal/
                    array/
                    compat/
                        _internal/
                        array/
                        function/
                        math/
                        object/
                        predicate/
                        string/
                        util/
                    error/
                    function/
                    math/
                    object/
                    predicate/
                    promise/
                    string/
                    util/
                src/
                    compat/
                        _internal/
            escape-string-regexp/
            eslint/
                conf/
                lib/
                    cli-engine/
                        formatters/
                    config/
                    eslint/
                    languages/
                        js/
                            source-code/
                                token-store/
                    linter/
                        code-path-analysis/
                    rule-tester/
                    rules/
                        utils/
                            unicode/
                    services/
                    shared/
                    types/
                messages/
            eslint-config-next/
            eslint-import-resolver-node/
                node_modules/
                    debug/
                        src/
            eslint-import-resolver-typescript/
                lib/
            eslint-module-utils/
                node_modules/
                    debug/
                        src/
            eslint-plugin-import/
                config/
                    flat/
                docs/
                    rules/
                lib/
                    core/
                    exportMap/
                    rules/
                memo-parser/
                node_modules/
                    .bin/
                    debug/
                        src/
                    semver/
            eslint-plugin-jsx-a11y/
                __mocks__/
                __tests__/
                    __util__/
                        helpers/
                    src/
                        rules/
                        util/
                            implicitRoles/
                docs/
                    rules/
                lib/
                    configs/
                    rules/
                    util/
                        implicitRoles/
            eslint-plugin-react/
                configs/
                lib/
                    rules/
                    util/
                node_modules/
                    .bin/
                    resolve/
                        .github/
                        example/
                        lib/
                        test/
                            dotdot/
                                abc/
                            module_dir/
                                xmodules/
                                    aaa/
                                ymodules/
                                    aaa/
                                zmodules/
                                    bbb/
                            node_path/
                                x/
                                    aaa/
                                    ccc/
                                y/
                                    bbb/
                                    ccc/
                            pathfilter/
                                deep_ref/
                            precedence/
                                aaa/
                                bbb/
                            resolver/
                                baz/
                                browser_field/
                                dot_main/
                                dot_slash_main/
                                empty_main/
                                false_main/
                                incorrect_main/
                                invalid_main/
                                missing_index/
                                missing_main/
                                multirepo/
                                    packages/
                                        package-a/
                                        package-b/
                                nested_symlinks/
                                    mylib/
                                null_main/
                                other_path/
                                    lib/
                                quux/
                                    foo/
                                same_names/
                                    foo/
                                symlinked/
                                    _/
                                        node_modules/
                                        symlink_target/
                                    package/
                                without_basedir/
                            shadowed_core/
                                node_modules/
                                    util/
                    semver/
            eslint-plugin-react-hooks/
                cjs/
            eslint-scope/
                dist/
                lib/
            eslint-visitor-keys/
                dist/
                lib/
            espree/
                dist/
                lib/
            esquery/
                dist/
            esrecurse/
            estraverse/
            esutils/
                lib/
            eventemitter3/
                dist/
            fast-deep-equal/
                es6/
            fast-glob/
                node_modules/
                    glob-parent/
                out/
                    managers/
                    providers/
                        filters/
                        matchers/
                        transformers/
                    readers/
                    types/
                    utils/
            fast-json-stable-stringify/
                .github/
                benchmark/
                example/
                test/
            fast-levenshtein/
            fastq/
                .github/
                    workflows/
                test/
            file-entry-cache/
            fill-range/
            find-up/
            flat-cache/
                src/
            flatted/
                cjs/
                esm/
                php/
                python/
                types/
            follow-redirects/
            for-each/
                .github/
                test/
            form-data/
                lib/
            function-bind/
                .github/
                test/
            function.prototype.name/
                .github/
                helpers/
                test/
            functions-have-names/
                .github/
                test/
            get-intrinsic/
                .github/
                test/
            get-proto/
                .github/
                test/
            get-symbol-description/
                .github/
                test/
            get-tsconfig/
                dist/
            glob-parent/
            globals/
            globalthis/
                test/
            gopd/
                .github/
                test/
            graceful-fs/
            graphemer/
                lib/
            has-bigints/
                .github/
                test/
            has-flag/
            has-property-descriptors/
                .github/
                test/
            has-proto/
                .github/
                test/
            has-symbols/
                .github/
                test/
                    shams/
            has-tostringtag/
                .github/
                test/
                    shams/
            hasown/
                .github/
            idb-keyval/
                dist/
                    src/
                    test/
                        src/
                        test/
            ignore/
            imask/
                dist/
                esm/
                    controls/
                    core/
                    masked/
                        pattern/
            immer/
                dist/
                    cjs/
                src/
                    core/
                    plugins/
                    types/
                    utils/
            import-fresh/
            imurmurhash/
            internal-slot/
                .github/
                test/
            internmap/
                dist/
                src/
            is-array-buffer/
                .github/
                test/
            is-arrayish/
            is-async-function/
                test/
            is-bigint/
                .github/
                test/
            is-boolean-object/
                .github/
                test/
            is-bun-module/
                dist/
            is-callable/
                .github/
                test/
            is-core-module/
                test/
            is-data-view/
                .github/
                test/
            is-date-object/
                .github/
                test/
            is-extglob/
            is-finalizationregistry/
                .github/
                test/
            is-generator-function/
                test/
            is-glob/
            is-map/
                .github/
                test/
            is-negative-zero/
                .github/
                test/
            is-number/
            is-number-object/
                .github/
                test/
            is-regex/
                test/
            is-set/
                .github/
                test/
            is-shared-array-buffer/
                .github/
                test/
            is-string/
                .github/
                test/
            is-symbol/
                .github/
                test/
            is-typed-array/
                .github/
                test/
            is-url/
                test/
            is-weakmap/
                .github/
                test/
            is-weakref/
                .github/
                test/
            is-weakset/
                .github/
                test/
            isarray/
            isexe/
                test/
            iterator.prototype/
                .github/
                test/
            jiti/
                dist/
                lib/
            js-tokens/
            js-yaml/
                dist/
                lib/
                    schema/
                    type/
            json-buffer/
                test/
            json-schema-traverse/
                spec/
                    fixtures/
            json-stable-stringify-without-jsonify/
                example/
                test/
            json5/
                dist/
                lib/
            jsx-ast-utils/
                .github/
                __tests__/
                    src/
                lib/
                    values/
                        expressions/
                src/
                    values/
                        expressions/
            keyv/
                src/
            language-subtag-registry/
                data/
                    json/
            language-tags/
                lib/
            leaflet/
                dist/
                    images/
                src/
                    control/
                    core/
                    dom/
                    geo/
                        crs/
                        projection/
                    geometry/
                    images/
                    layer/
                        marker/
                        tile/
                        vector/
                    map/
                        handler/
            levn/
                lib/
            lightningcss/
                node/
            lightningcss-win32-x64-msvc/
            locate-path/
            lodash.merge/
            loose-envify/
            lucide-react/
                dist/
                    cjs/
                    esm/
                        icons/
                        shared/
                            src/
                    umd/
            magic-string/
                dist/
            math-intrinsics/
                .github/
                constants/
                test/
            merge2/
            micromatch/
            mime-db/
            mime-types/
            minimatch/
            minimist/
                .github/
                example/
                test/
            minipass/
                dist/
                    commonjs/
                    esm/
            minizlib/
                dist/
                    commonjs/
                    esm/
            mkdirp/
                dist/
                    cjs/
                        src/
                    mjs/
            ms/
            nanoid/
                async/
                non-secure/
                url-alphabet/
            napi-postinstall/
                lib/
            natural-compare/
            next/
                compat/
                dist/
                    api/
                    cli/
                        internal/
                    client/
                        app-dir/
                        compat/
                        components/
                            builtin/
                            errors/
                            http-access-fallback/
                            metadata/
                            router-reducer/
                                reducers/
                            segment-cache-impl/
                            styles/
                        dev/
                            error-overlay/
                            hot-reloader/
                                app/
                                pages/
                        legacy/
                        lib/
                        portal/
                        react-client-callbacks/
                        request/
                        tracing/
                    compiled/
                        @ampproject/
                            toolbox-optimizer/
                        @babel/
                            runtime/
                                helpers/
                                    esm/
                                regenerator/
                        @edge-runtime/
                            cookies/
                            ponyfill/
                            primitives/
                        @hapi/
                            accept/
                        @mswjs/
                            interceptors/
                                ClientRequest/
                        @napi-rs/
                            triples/
                        @next/
                            font/
                                dist/
                                    fontkit/
                                    google/
                                    local/
                                google/
                                local/
                            react-refresh-utils/
                                dist/
                                    internal/
                        @opentelemetry/
                            api/
                        @vercel/
                            nft/
                            og/
                                emoji/
                                figma/
                                language/
                                satori/
                        acorn/
                        amphtml-validator/
                        anser/
                        assert/
                        async-retry/
                        async-sema/
                        babel/
                        babel-packages/
                        browserify-zlib/
                        browserslist/
                        buffer/
                        busboy/
                        bytes/
                        ci-info/
                        cli-select/
                        client-only/
                        commander/
                        comment-json/
                        compression/
                        conf/
                        constants-browserify/
                        content-disposition/
                        content-type/
                        cookie/
                        cross-spawn/
                        crypto-browserify/
                        css.escape/
                        cssnano-simple/
                        data-uri-to-buffer/
                        debug/
                        devalue/
                        domain-browser/
                        edge-runtime/
                        events/
                        find-up/
                        fresh/
                        glob/
                        gzip-size/
                        http-proxy/
                        http-proxy-agent/
                        https-browserify/
                        https-proxy-agent/
                        icss-utils/
                        ignore-loader/
                        image-detector/
                        image-size/
                        is-animated/
                        is-docker/
                        is-wsl/
                        jest-worker/
                        json5/
                        jsonwebtoken/
                        loader-runner/
                        loader-utils2/
                        loader-utils3/
                        lodash.curry/
                        lru-cache/
                        mini-css-extract-plugin/
                            hmr/
                        nanoid/
                        native-url/
                        neo-async/
                        next-devtools/
                        next-server/
                        node-html-parser/
                        ora/
                        os-browserify/
                        p-limit/
                        p-queue/
                        path-browserify/
                        path-to-regexp/
                        picomatch/
                        postcss-flexbugs-fixes/
                        postcss-modules-extract-imports/
                        postcss-modules-local-by-default/
                        postcss-modules-scope/
                        postcss-modules-values/
                        postcss-plugin-stub-for-cssnano-simple/
                        postcss-preset-env/
                        postcss-safe-parser/
                        postcss-scss/
                        postcss-value-parser/
                        process/
                        punycode/
                        querystring-es3/
                        raw-body/
                        react/
                            cjs/
                        react-dom/
                            cjs/
                        react-dom-experimental/
                            cjs/
                        react-experimental/
                            cjs/
                        react-is/
                            cjs/
                        react-refresh/
                            cjs/
                        react-server-dom-turbopack/
                            cjs/
                        react-server-dom-turbopack-experimental/
                            cjs/
                        react-server-dom-webpack/
                            cjs/
                        react-server-dom-webpack-experimental/
                            cjs/
                        regenerator-runtime/
                        safe-stable-stringify/
                        sass-loader/
                        scheduler/
                            cjs/
                        scheduler-experimental/
                            cjs/
                        schema-utils2/
                        schema-utils3/
                        semver/
                        send/
                        server-only/
                        setimmediate/
                        shell-quote/
                        source-map/
                        source-map08/
                        stacktrace-parser/
                        stream-browserify/
                        stream-http/
                        string-hash/
                        string_decoder/
                        strip-ansi/
                        superstruct/
                        tar/
                        terser/
                        text-table/
                        timers-browserify/
                        tty-browserify/
                        ua-parser-js/
                        unistore/
                        util/
                        vm-browserify/
                        watchpack/
                        web-vitals/
                        web-vitals-attribution/
                        webpack/
                        webpack-sources1/
                        webpack-sources3/
                        ws/
                        zod/
                        zod-validation-error/
                    diagnostics/
                    esm/
                        api/
                        client/
                            app-dir/
                            compat/
                            components/
                                builtin/
                                errors/
                                http-access-fallback/
                                metadata/
                                router-reducer/
                                    reducers/
                                segment-cache-impl/
                                styles/
                            dev/
                                error-overlay/
                                hot-reloader/
                                    app/
                                    pages/
                            legacy/
                            lib/
                            portal/
                            react-client-callbacks/
                            request/
                            tracing/
                        export/
                            helpers/
                            routes/
                        lib/
                            eslint/
                            framework/
                            fs/
                            helpers/
                            memory/
                            metadata/
                                generate/
                                resolvers/
                                types/
                            typescript/
                        next-devtools/
                            server/
                                font/
                            shared/
                            userspace/
                                app/
                                    errors/
                                pages/
                        pages/
                        server/
                            after/
                            api-utils/
                                node/
                            app-render/
                                metadata-insertion/
                                module-loading/
                                rsc/
                            async-storage/
                            base-http/
                            dev/
                                browser-logs/
                            instrumentation/
                            lib/
                                cache-handlers/
                                experimental/
                                incremental-cache/
                                module-loader/
                                router-utils/
                                server-ipc/
                                trace/
                            node-environment-extensions/
                            normalizers/
                                built/
                                    app/
                                    pages/
                                request/
                            og/
                            request/
                            response-cache/
                            resume-data-cache/
                            route-definitions/
                            route-matcher-managers/
                            route-matcher-providers/
                                dev/
                                    helpers/
                                        file-reader/
                                helpers/
                                    manifest-loaders/
                            route-matchers/
                            route-matches/
                            route-modules/
                                app-page/
                                    helpers/
                                    vendored/
                                        contexts/
                                        rsc/
                                        ssr/
                                app-route/
                                    helpers/
                                pages/
                                    builtin/
                                    vendored/
                                        contexts/
                                pages-api/
                            stream-utils/
                            typescript/
                                rules/
                            use-cache/
                            web/
                                exports/
                                sandbox/
                                spec-extension/
                                    adapters/
                        shared/
                            lib/
                                errors/
                                i18n/
                                isomorphic/
                                lazy-dynamic/
                                page-path/
                                router/
                                    utils/
                                segment-cache/
                                turbopack/
                                utils/
                    experimental/
                        testing/
                            server/
                        testmode/
                            playwright/
                            proxy/
                    export/
                        helpers/
                        routes/
                    lib/
                        eslint/
                        framework/
                        fs/
                        helpers/
                        memory/
                        metadata/
                            generate/
                            resolvers/
                            types/
                        typescript/
                    next-devtools/
                        dev-overlay/
                            components/
                                call-stack/
                                call-stack-frame/
                                code-frame/
                                copy-button/
                                devtools-indicator/
                                    hooks/
                                devtools-panel/
                                    resize/
                                dialog/
                                errors/
                                    dev-tools-indicator/
                                        dev-tools-info/
                                    dialog/
                                    environment-name-label/
                                    error-message/
                                    error-overlay/
                                    error-overlay-bottom-stack/
                                    error-overlay-call-stack/
                                    error-overlay-footer/
                                        error-feedback/
                                    error-overlay-layout/
                                    error-overlay-nav/
                                    error-overlay-pagination/
                                    error-overlay-toolbar/
                                    error-type-label/
                                    overlay/
                                fader/
                                hot-linked-text/
                                hydration-diff/
                                overlay/
                                overview/
                                resizer/
                                terminal/
                                toast/
                                tooltip/
                                version-staleness-info/
                            container/
                                runtime-error/
                            font/
                            hooks/
                            icons/
                                thumbs/
                            menu/
                            panel/
                            styles/
                            utils/
                        server/
                            font/
                        shared/
                        userspace/
                            app/
                                errors/
                            pages/
                    pages/
                    server/
                        after/
                        api-utils/
                            node/
                        app-render/
                            metadata-insertion/
                            module-loading/
                            rsc/
                        async-storage/
                        base-http/
                        dev/
                            browser-logs/
                        instrumentation/
                        lib/
                            cache-handlers/
                            experimental/
                            incremental-cache/
                            module-loader/
                            router-utils/
                            server-ipc/
                            trace/
                        node-environment-extensions/
                        normalizers/
                            built/
                                app/
                                pages/
                            request/
                        og/
                        request/
                        response-cache/
                        resume-data-cache/
                        route-definitions/
                        route-matcher-managers/
                        route-matcher-providers/
                            dev/
                                helpers/
                                    file-reader/
                            helpers/
                                manifest-loaders/
                        route-matchers/
                        route-matches/
                        route-modules/
                            app-page/
                                helpers/
                                vendored/
                                    contexts/
                                    rsc/
                                    ssr/
                            app-route/
                                helpers/
                            pages/
                                builtin/
                                vendored/
                                    contexts/
                            pages-api/
                        stream-utils/
                        typescript/
                            rules/
                        use-cache/
                        web/
                            exports/
                            sandbox/
                            spec-extension/
                                adapters/
                    shared/
                        lib/
                            errors/
                            i18n/
                            isomorphic/
                            lazy-dynamic/
                            page-path/
                            router/
                                utils/
                            segment-cache/
                            turbopack/
                            utils/
                    styled-jsx/
                        types/
                    telemetry/
                        events/
                    trace/
                        report/
                experimental/
                    testing/
                    testmode/
                        playwright/
                font/
                    google/
                    local/
                image-types/
                legacy/
                navigation-types/
                    compat/
                node_modules/
                    @swc/
                        helpers/
                            _/
                                _apply_decorated_descriptor/
                                _apply_decs_2203_r/
                                _array_like_to_array/
                                _array_with_holes/
                                _array_without_holes/
                                _assert_this_initialized/
                                _async_generator/
                                _async_generator_delegate/
                                _async_iterator/
                                _async_to_generator/
                                _await_async_generator/
                                _await_value/
                                _call_super/
                                _check_private_redeclaration/
                                _class_apply_descriptor_destructure/
                                _class_apply_descriptor_get/
                                _class_apply_descriptor_set/
                                _class_apply_descriptor_update/
                                _class_call_check/
                                _class_check_private_static_access/
                                _class_check_private_static_field_descriptor/
                                _class_extract_field_descriptor/
                                _class_name_tdz_error/
                                _class_private_field_destructure/
                                _class_private_field_get/
                                _class_private_field_init/
                                _class_private_field_loose_base/
                                _class_private_field_loose_key/
                                _class_private_field_set/
                                _class_private_field_update/
                                _class_private_method_get/
                                _class_private_method_init/
                                _class_private_method_set/
                                _class_static_private_field_destructure/
                                _class_static_private_field_spec_get/
                                _class_static_private_field_spec_set/
                                _class_static_private_field_update/
                                _class_static_private_method_get/
                                _construct/
                                _create_class/
                                _create_for_of_iterator_helper_loose/
                                _create_super/
                                _decorate/
                                _defaults/
                                _define_enumerable_properties/
                                _define_property/
                                _dispose/
                                _export_star/
                                _extends/
                                _get/
                                _get_prototype_of/
                                _identity/
                                _inherits/
                                _inherits_loose/
                                _initializer_define_property/
                                _initializer_warning_helper/
                                _instanceof/
                                _interop_require_default/
                                _interop_require_wildcard/
                                _is_native_function/
                                _is_native_reflect_construct/
                                _iterable_to_array/
                                _iterable_to_array_limit/
                                _iterable_to_array_limit_loose/
                                _jsx/
                                _new_arrow_check/
                                _non_iterable_rest/
                                _non_iterable_spread/
                                _object_destructuring_empty/
                                _object_spread/
                                _object_spread_props/
                                _object_without_properties/
                                _object_without_properties_loose/
                                _possible_constructor_return/
                                _read_only_error/
                                _set/
                                _set_prototype_of/
                                _skip_first_generator_next/
                                _sliced_to_array/
                                _sliced_to_array_loose/
                                _super_prop_base/
                                _tagged_template_literal/
                                _tagged_template_literal_loose/
                                _throw/
                                _to_array/
                                _to_consumable_array/
                                _to_primitive/
                                _to_property_key/
                                _ts_add_disposable_resource/
                                _ts_decorate/
                                _ts_dispose_resources/
                                _ts_generator/
                                _ts_metadata/
                                _ts_param/
                                _ts_values/
                                _type_of/
                                _unsupported_iterable_to_array/
                                _update/
                                _using/
                                _using_ctx/
                                _wrap_async_generator/
                                _wrap_native_super/
                                _write_only_error/
                                index/
                            cjs/
                            esm/
                            scripts/
                            src/
                    postcss/
                        lib/
                types/
            node-fetch/
                lib/
            object-assign/
            object-inspect/
                .github/
                example/
                test/
                    browser/
            object-keys/
                test/
            object.assign/
                .github/
                dist/
                test/
            object.entries/
                test/
            object.fromentries/
                test/
            object.groupby/
                .github/
                test/
            object.values/
                test/
            opencollective-postinstall/
            optionator/
                lib/
            own-keys/
                .github/
                test/
            p-limit/
            p-locate/
            parent-module/
            path-exists/
            path-key/
            path-parse/
            picocolors/
            picomatch/
                lib/
            possible-typed-array-names/
                .github/
                test/
            postcss/
                lib/
            prelude-ls/
                lib/
            prop-types/
                lib/
            proxy-from-env/
            punycode/
            qrcode.react/
                lib/
                    esm/
            queue-microtask/
            react/
                cjs/
            react-chartjs-2/
                dist/
            react-dom/
                cjs/
            react-icons/
                ai/
                bi/
                bs/
                cg/
                ci/
                di/
                fa/
                fa6/
                fc/
                fi/
                gi/
                go/
                gr/
                hi/
                hi2/
                im/
                io/
                io5/
                lia/
                lib/
                lu/
                md/
                pi/
                ri/
                rx/
                si/
                sl/
                tb/
                tfi/
                ti/
                vsc/
                wi/
            react-imask/
                dist/
                esm/
            react-is/
                cjs/
                umd/
            react-leaflet/
                lib/
            react-redux/
                dist/
                    cjs/
                src/
                    components/
                    connect/
                    hooks/
                    utils/
            react-webcam/
                .vscode/
                dist/
            recharts/
                es6/
                    animation/
                    cartesian/
                    chart/
                    component/
                    container/
                    context/
                    polar/
                    shape/
                    state/
                        selectors/
                            combiners/
                        types/
                    synchronisation/
                    util/
                        cursor/
                        payload/
                        scale/
                            util/
                        stacks/
                        tooltip/
                lib/
                    animation/
                    cartesian/
                    chart/
                    component/
                    container/
                    context/
                    polar/
                    shape/
                    state/
                        selectors/
                            combiners/
                        types/
                    synchronisation/
                    util/
                        cursor/
                        payload/
                        scale/
                            util/
                        stacks/
                        tooltip/
                types/
                    animation/
                    cartesian/
                    chart/
                    component/
                    container/
                    context/
                    polar/
                    shape/
                    state/
                        selectors/
                            combiners/
                        types/
                    synchronisation/
                    util/
                        cursor/
                        payload/
                        scale/
                            util/
                        stacks/
                        tooltip/
                umd/
            redux/
                dist/
                    cjs/
                src/
                    types/
                    utils/
            redux-thunk/
                dist/
                    cjs/
                src/
            reflect.getprototypeof/
                test/
            regenerator-runtime/
            regexp.prototype.flags/
                test/
            reselect/
                dist/
                    cjs/
                src/
                    autotrackMemoize/
                    devModeChecks/
                    versionedTypes/
            resolve/
                .github/
                example/
                lib/
                test/
                    dotdot/
                        abc/
                    module_dir/
                        xmodules/
                            aaa/
                        ymodules/
                            aaa/
                        zmodules/
                            bbb/
                    node_path/
                        x/
                            aaa/
                            ccc/
                        y/
                            bbb/
                            ccc/
                    pathfilter/
                        deep_ref/
                    precedence/
                        aaa/
                        bbb/
                    resolver/
                        baz/
                        browser_field/
                        dot_main/
                        dot_slash_main/
                        false_main/
                        incorrect_main/
                        invalid_main/
                        multirepo/
                            packages/
                                package-a/
                                package-b/
                        nested_symlinks/
                            mylib/
                        other_path/
                            lib/
                        quux/
                            foo/
                        same_names/
                            foo/
                        symlinked/
                            _/
                                node_modules/
                                symlink_target/
                            package/
                        without_basedir/
                    shadowed_core/
                        node_modules/
                            util/
            resolve-from/
            resolve-pkg-maps/
                dist/
            reusify/
                .github/
                    workflows/
                benchmarks/
            run-parallel/
            safe-array-concat/
                .github/
                test/
            safe-push-apply/
                .github/
                test/
            safe-regex-test/
                .github/
                test/
            scheduler/
                cjs/
            semver/
                classes/
                functions/
                internal/
                ranges/
            set-function-length/
                .github/
            set-function-name/
                .github/
            set-proto/
                .github/
                test/
            sharp/
                install/
                lib/
                src/
            shebang-command/
            shebang-regex/
            side-channel/
                .github/
                test/
            side-channel-list/
                .github/
                test/
            side-channel-map/
                .github/
                test/
            side-channel-weakmap/
                .github/
                test/
            simple-swizzle/
            source-map-js/
                lib/
            stable-hash/
                dist/
            stop-iteration-iterator/
                .github/
                test/
            string.prototype.includes/
                .github/
                    workflows/
                tests/
            string.prototype.matchall/
                .github/
                test/
            string.prototype.repeat/
                tests/
            string.prototype.trim/
                test/
            string.prototype.trimend/
                test/
            string.prototype.trimstart/
                test/
            strip-bom/
            strip-json-comments/
            styled-jsx/
                dist/
                    babel/
                    index/
                    webpack/
                lib/
            supports-color/
            supports-preserve-symlinks-flag/
                .github/
                test/
            tabbable/
                dist/
                src/
            tailwindcss/
                dist/
            tapable/
                lib/
            tar/
                dist/
                    commonjs/
                    esm/
            tesseract.js/
                dist/
                docs/
                    images/
                examples/
                    browser/
                    node/
                scripts/
                src/
                    constants/
                    utils/
                    worker/
                        browser/
                        node/
                    worker-script/
                        browser/
                        constants/
                        node/
                        utils/
            tesseract.js-core/
            tiny-invariant/
                dist/
                    esm/
                src/
            tinyglobby/
                dist/
                node_modules/
                    fdir/
                        dist/
                    picomatch/
                        lib/
            to-regex-range/
            tr46/
                lib/
            ts-api-utils/
                lib/
            tsconfig-paths/
                lib/
                    __tests__/
                        data/
                src/
                    __tests__/
                        data/
            tslib/
                modules/
            type-check/
                lib/
            typed-array-buffer/
                .github/
                test/
            typed-array-byte-length/
                .github/
                test/
            typed-array-byte-offset/
                .github/
                test/
            typed-array-length/
                .github/
                test/
            typescript/
                lib/
                    cs/
                    de/
                    es/
                    fr/
                    it/
                    ja/
                    ko/
                    pl/
                    pt-br/
                    ru/
                    tr/
                    zh-cn/
                    zh-tw/
            unbox-primitive/
                .github/
                test/
            undici-types/
            unrs-resolver/
            uri-js/
                dist/
                    es5/
                    esnext/
                        schemes/
            use-sync-external-store/
                cjs/
                    use-sync-external-store-shim/
                shim/
            victory-vendor/
                es/
                lib/
                lib-vendor/
                    d3-array/
                        src/
                            threshold/
                    d3-color/
                        src/
                    d3-ease/
                        src/
                    d3-format/
                        src/
                    d3-interpolate/
                        src/
                            transform/
                    d3-path/
                        src/
                    d3-scale/
                        src/
                    d3-shape/
                        src/
                            curve/
                            offset/
                            order/
                            symbol/
                    d3-time/
                        src/
                    d3-time-format/
                        src/
                    d3-timer/
                        src/
                    d3-voronoi/
                        src/
                    internmap/
                        src/
            wasm-feature-detect/
                dist/
                    cjs/
                    esm/
                    umd/
            webidl-conversions/
                lib/
            whatwg-url/
                lib/
            which/
            which-boxed-primitive/
                .github/
                test/
            which-builtin-type/
                test/
            which-collection/
                .github/
                test/
            which-typed-array/
                .github/
                test/
            word-wrap/
            yallist/
                dist/
                    commonjs/
                    esm/
            yocto-queue/
            zlibjs/
        src/
            app/
                box/
                    alterar/
                        [id]/
                    buscar/
                    cadastrar/
                    deletar/
                        [id]/
                    detalhes/
                        [id]/
                    listar/
                clientes/
                    alterar/
                        [id]/
                    buscar/
                    cadastrar/
                    deletar/
                        [id]/
                    detalhes/
                        [id]/
                    listar/
                contato/
                dashboard/
                inicio/
                mapa-2d/
                mapa-do-site/
                patio/
                    alterar/
                        [id]/
                    buscar/
                    cadastrar/
                    deletar/
                        [id]/
                    detalhes/
                        [id]/
                    listar/
                radar/
                    armazenar/
                    buscar/
                    localizar/
                        [placa]/
                    mobile-upload/
                        [sessionId]/
                vagas/
                    buscar/
                    mapa/
                veiculo/
                    alterar/
                        [id]/
                    buscar/
                    cadastrar/
                    deletar/
                        [id]/
                    detalhes/
                        [id]/
                    listar/
                zona/
                    alterar/
                        [id]/
                    buscar/
                    cadastrar/
                    deletar/
                        [id]/
                    detalhes/
                        [id]/
                    listar/
            components/
                forms/
                map/
            types/
            utils/
                api/
                map/

// Índice de Pacotes e Arquivos:
//   PACOTE: [Arquivos de Configuração e Build]
//     - application.properties
//     - build.gradle
//     - application.properties
//     - application.properties
//     - build.gradle
//     - application.properties
//     - application.properties
//   PACOTE: br.com.fiap.mottu
//     - MottuApplication.java
//     - MottuGradleApplicationTests.java
//     - MottuApplication.java
//     - MottuGradleApplicationTests.java
//   PACOTE: br.com.fiap.mottu.config
//     - CorsConfig.java
//     - OpenApiConfig.java
//     - OpenCvLoader.java
//     - SwaggerBrowserLauncher.java
//     - CorsConfig.java
//     - OpenApiConfig.java
//     - OpenCvLoader.java
//     - SwaggerBrowserLauncher.java
//   PACOTE: br.com.fiap.mottu.controller
//     - BoxController.java
//     - ClienteController.java
//     - ContatoController.java
//     - EnderecoController.java
//     - EstacionamentoController.java
//     - PatioController.java
//     - RadarController.java
//     - RastreamentoController.java
//     - VeiculoController.java
//     - ZonaController.java
//     - BoxController.java
//     - ClienteController.java
//     - ContatoController.java
//     - EnderecoController.java
//     - EstacionamentoController.java
//     - PatioController.java
//     - RadarController.java
//     - RastreamentoController.java
//     - VagaController.java
//     - VeiculoController.java
//     - ZonaController.java
//   PACOTE: br.com.fiap.mottu.dashboard.controller
//     - DashboardController.java
//     - DashboardController.java
//   PACOTE: br.com.fiap.mottu.dto.box
//     - BoxRequestDto.java
//     - BoxResponseDto.java
//     - BoxRequestDto.java
//     - BoxResponseDto.java
//   PACOTE: br.com.fiap.mottu.dto.cliente
//     - ClienteRequestDto.java
//     - ClienteResponseDto.java
//     - ClienteRequestDto.java
//     - ClienteResponseDto.java
//   PACOTE: br.com.fiap.mottu.dto.contato
//     - ContatoRequestDto.java
//     - ContatoResponseDto.java
//     - ContatoRequestDto.java
//     - ContatoResponseDto.java
//   PACOTE: br.com.fiap.mottu.dto.dashboard
//     - OcupacaoDiaDto.java
//     - ResumoOcupacaoDto.java
//     - OcupacaoDiaDto.java
//     - ResumoOcupacaoDto.java
//   PACOTE: br.com.fiap.mottu.dto.endereco
//     - EnderecoRequestDto.java
//     - EnderecoResponseDto.java
//     - EnderecoRequestDto.java
//     - EnderecoResponseDto.java
//   PACOTE: br.com.fiap.mottu.dto.estacionamento
//     - PlacaRequestDto.java
//     - PlacaRequestDto.java
//   PACOTE: br.com.fiap.mottu.dto.patio
//     - PatioRequestDto.java
//     - PatioResponseDto.java
//     - PatioRequestDto.java
//     - PatioResponseDto.java
//   PACOTE: br.com.fiap.mottu.dto.rastreamento
//     - RastreamentoRequestDto.java
//     - RastreamentoResponseDto.java
//     - RastreamentoRequestDto.java
//     - RastreamentoResponseDto.java
//   PACOTE: br.com.fiap.mottu.dto.veiculo
//     - VeiculoLocalizacaoResponseDto.java
//     - VeiculoRequestDto.java
//     - VeiculoResponseDto.java
//     - VeiculoLocalizacaoResponseDto.java
//     - VeiculoRequestDto.java
//     - VeiculoResponseDto.java
//   PACOTE: br.com.fiap.mottu.dto.zona
//     - ZonaRequestDto.java
//     - ZonaResponseDto.java
//     - ZonaRequestDto.java
//     - ZonaResponseDto.java
//   PACOTE: br.com.fiap.mottu.exception
//     - DuplicatedResourceException.java
//     - InvalidInputException.java
//     - ResourceNotFoundException.java
//     - DuplicatedResourceException.java
//     - InvalidInputException.java
//     - ResourceNotFoundException.java
//   PACOTE: br.com.fiap.mottu.exception.handler
//     - GlobalExceptionHandler.java
//     - GlobalExceptionHandler.java
//   PACOTE: br.com.fiap.mottu.external.viacep
//     - ViaCepResponse.java
//     - ViaCepService.java
//     - ViaCepResponse.java
//     - ViaCepService.java
//   PACOTE: br.com.fiap.mottu.filter
//     - BoxFilter.java
//     - ClienteFilter.java
//     - ContatoFilter.java
//     - EnderecoFilter.java
//     - PatioFilter.java
//     - RastreamentoFilter.java
//     - VeiculoFilter.java
//     - ZonaFilter.java
//     - BoxFilter.java
//     - ClienteFilter.java
//     - ContatoFilter.java
//     - EnderecoFilter.java
//     - PatioFilter.java
//     - RastreamentoFilter.java
//     - VeiculoFilter.java
//     - ZonaFilter.java
//   PACOTE: br.com.fiap.mottu.mapper
//     - BoxMapperImpl.java
//     - ClienteMapperImpl.java
//     - ContatoMapperImpl.java
//     - EnderecoMapperImpl.java
//     - PatioMapperImpl.java
//     - RastreamentoMapperImpl.java
//     - VeiculoMapperImpl.java
//     - ZonaMapperImpl.java
//     - BoxMapper.java
//     - ClienteMapper.java
//     - ContatoMapper.java
//     - EnderecoMapper.java
//     - PatioMapper.java
//     - RastreamentoMapper.java
//     - VeiculoMapper.java
//     - ZonaMapper.java
//     - BoxMapperImpl.java
//     - ClienteMapperImpl.java
//     - ContatoMapperImpl.java
//     - EnderecoMapperImpl.java
//     - PatioMapperImpl.java
//     - RastreamentoMapperImpl.java
//     - VeiculoMapperImpl.java
//     - ZonaMapperImpl.java
//     - BoxMapper.java
//     - ClienteMapper.java
//     - ContatoMapper.java
//     - EnderecoMapper.java
//     - PatioMapper.java
//     - RastreamentoMapper.java
//     - VeiculoMapper.java
//     - ZonaMapper.java
//   PACOTE: br.com.fiap.mottu.model
//     - Box.java
//     - Cliente.java
//     - Contato.java
//     - Endereco.java
//     - Patio.java
//     - Rastreamento.java
//     - Veiculo.java
//     - Zona.java
//     - Box.java
//     - Cliente.java
//     - Contato.java
//     - Endereco.java
//     - Patio.java
//     - Rastreamento.java
//     - Veiculo.java
//     - Zona.java
//   PACOTE: br.com.fiap.mottu.model.relacionamento
//     - ClienteVeiculo.java
//     - ClienteVeiculoId.java
//     - ContatoPatio.java
//     - ContatoPatioId.java
//     - EnderecoPatio.java
//     - EnderecoPatioId.java
//     - PatioBox.java
//     - PatioBoxId.java
//     - VeiculoBox.java
//     - VeiculoBoxId.java
//     - VeiculoPatio.java
//     - VeiculoPatioId.java
//     - VeiculoRastreamento.java
//     - VeiculoRastreamentoId.java
//     - VeiculoZona.java
//     - VeiculoZonaId.java
//     - ZonaBox.java
//     - ZonaBoxId.java
//     - ZonaPatio.java
//     - ZonaPatioId.java
//     - ClienteVeiculo.java
//     - ClienteVeiculoId.java
//     - ContatoPatio.java
//     - ContatoPatioId.java
//     - EnderecoPatio.java
//     - EnderecoPatioId.java
//     - PatioBox.java
//     - PatioBoxId.java
//     - VeiculoBox.java
//     - VeiculoBoxId.java
//     - VeiculoPatio.java
//     - VeiculoPatioId.java
//     - VeiculoRastreamento.java
//     - VeiculoRastreamentoId.java
//     - VeiculoZona.java
//     - VeiculoZonaId.java
//     - ZonaBox.java
//     - ZonaBoxId.java
//     - ZonaPatio.java
//     - ZonaPatioId.java
//   PACOTE: br.com.fiap.mottu.repository
//     - BoxRepository.java
//     - ClienteRepository.java
//     - ContatoRepository.java
//     - DashboardStatsRepository.java
//     - EnderecoRepository.java
//     - PatioRepository.java
//     - RastreamentoRepository.java
//     - VeiculoRepository.java
//     - ZonaRepository.java
//     - BoxRepository.java
//     - ClienteRepository.java
//     - ContatoRepository.java
//     - DashboardStatsRepository.java
//     - EnderecoRepository.java
//     - PatioRepository.java
//     - RastreamentoRepository.java
//     - VeiculoRepository.java
//     - ZonaRepository.java
//   PACOTE: br.com.fiap.mottu.repository.relacionamento
//     - ClienteVeiculoRepository.java
//     - ContatoPatioRepository.java
//     - EnderecoPatioRepository.java
//     - PatioBoxRepository.java
//     - VeiculoBoxRepository.java
//     - VeiculoPatioRepository.java
//     - VeiculoRastreamentoRepository.java
//     - VeiculoZonaRepository.java
//     - ZonaBoxRepository.java
//     - ZonaPatioRepository.java
//     - ClienteVeiculoRepository.java
//     - ContatoPatioRepository.java
//     - EnderecoPatioRepository.java
//     - PatioBoxRepository.java
//     - VeiculoBoxRepository.java
//     - VeiculoPatioRepository.java
//     - VeiculoRastreamentoRepository.java
//     - VeiculoZonaRepository.java
//     - ZonaBoxRepository.java
//     - ZonaPatioRepository.java
//   PACOTE: br.com.fiap.mottu.service
//     - BoxService.java
//     - ClienteService.java
//     - ContatoService.java
//     - DashboardService.java
//     - EnderecoService.java
//     - EstacionamentoService.java
//     - PatioService.java
//     - RastreamentoService.java
//     - VeiculoService.java
//     - ZonaService.java
//     - BoxService.java
//     - ClienteService.java
//     - ContatoService.java
//     - DashboardService.java
//     - EnderecoService.java
//     - EstacionamentoService.java
//     - PatioService.java
//     - RastreamentoService.java
//     - VeiculoService.java
//     - ZonaService.java
//   PACOTE: br.com.fiap.mottu.service.ocr
//     - ImageCVUtils.java
//     - OcrSession.java
//     - OcrSessionManager.java
//     - PlateUtils.java
//     - TesseractService.java
//     - ImageCVUtils.java
//     - OcrSession.java
//     - OcrSessionManager.java
//     - OpenAlprService.java
//     - PlateRecognizer.java
//     - PlateUtils.java
//     - TesseractService.java
//   PACOTE: br.com.fiap.mottu.service.vaga
//     - VagaOracleService.java
//   PACOTE: br.com.fiap.mottu.specification
//     - BoxSpecification.java
//     - ClienteSpecification.java
//     - ContatoSpecification.java
//     - EnderecoSpecification.java
//     - PatioSpecification.java
//     - RastreamentoSpecification.java
//     - VeiculoSpecification.java
//     - ZonaSpecification.java
//     - BoxSpecification.java
//     - ClienteSpecification.java
//     - ContatoSpecification.java
//     - EnderecoSpecification.java
//     - PatioSpecification.java
//     - RastreamentoSpecification.java
//     - VeiculoSpecification.java
//     - ZonaSpecification.java
//   PACOTE: br.com.fiap.mottu.validation
//     - ValidationGroups.java
//     - ValidationGroups.java

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: [Arquivos de Configuração e Build]
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\bin\main\application.properties   |   TIPO: Configuração Spring
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

# ==================================================
# Spring Boot Application Configuration
# ==================================================

# --- Application Name and .env Import ---
# Defines the application name and allows importing configurations from a .env file.
spring.application.name=mottu-gradle

# --- Server Configuration ---
# Configures the embedded server (e.g., Tomcat).
server.port=8080
# Sets the application context path to root (e.g., http://localhost:8080/)
server.servlet.context-path=/

# --- Oracle DataSource Configuration ---
# Connection details for your Oracle database.
# The local XEPDB1 configuration is commented out; the FIAP Oracle DB is active.
#spring.datasource.url=jdbc:oracle:thin:@//localhost:1521/XEPDB1
#.profiles.active=dev
#spring.datasource.url=jdbc:oracle:thin:@//oracle.fiap.com.br:1521/ORCL
#spring.datasource.username=rm557881
#spring.datasource.password=fiap25
#spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

spring.profiles.active=dev
spring.datasource.url=jdbc:oracle:thin:@//localhost:1521/XEPDB1
spring.datasource.username=challenge
spring.datasource.password=paulo1
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- JPA / Hibernate Configuration ---
# Settings for Java Persistence API and Hibernate ORM.
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.hibernate.ddl-auto=validate

# --- Spring AI Configuration (Vertex AI Gemini) ---
# Reads Vertex AI Gemini settings from environment variables.
# Ensure VERTEX_AI_PROJECT_ID and API_KEY are set in your environment or .env file.
spring.ai.vertex.ai.gemini.project-id=${VERTEX_AI_PROJECT_ID}
spring.ai.vertex.ai.gemini.location=us-central1
spring.ai.vertex.ai.gemini.api-key=${API_KEY}
spring.ai.vertex.ai.gemini.transport=rest

# --- Springdoc OpenAPI (Swagger) Configuration ---
# Settings for API documentation generation.
# app.launch-swagger-on-startup=true # Tries to open Swagger UI in browser on startup.
# springdoc.api-docs.path=/v3/api-docs # Path for the OpenAPI specification.
# springdoc.swagger-ui.path=/swagger-ui/index.html # Path for the Swagger UI interface.

# --- HTTP Error Response Details ---
# Configures what details are included in HTTP error responses.
server.error.include-stacktrace=always
server.error.include-message=always
server.error.include-exception=true

# --- Logging Levels ---
# Defines verbosity for different logging categories.
logging.level.root=INFO

# Spring Framework specific logging
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.data.jpa=DEBUG
logging.level.org.springframework.security=TRACE
logging.level.org.springframework.security.web=TRACE
logging.level.org.springframework.security.authentication=TRACE

# Hibernate specific logging
logging.level.org.hibernate.type.descriptor.sql=TRACE
logging.level.org.hibernate.engine.jdbc.spi.SqlExceptionHelper=DEBUG
logging.level.org.hibernate.tool.schema.internal.SchemaCreatorImpl=DEBUG
logging.level.org.hibernate.dialect.Dialect=DEBUG
logging.level.org.hibernate.resource.jdbc=DEBUG

# Application specific logging (adjust br.com.fiap.mottu to your main application package if different)
logging.level.br.com.fiap.mottu=DEBUG

# Database driver and connection pool logging
logging.level.oracle=DEBUG
logging.level.com.zaxxer.hikari=DEBUG


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build.gradle   |   TIPO: Gradle Build File
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

plugins {
    id 'java'
    id 'org.springframework.boot' version '3.5.4'
    id 'io.spring.dependency-management' version '1.1.7'
}

group = 'br.com.fiap.mottu'
version = '0.0.1-SNAPSHOT'
description = 'mottu-gradle'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
    developmentOnly
    runtimeClasspath {
        extendsFrom developmentOnly
    }
    // remove conflitos com spring-jcl
    all {
        exclude group: 'commons-logging', module: 'commons-logging'
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion    = '1.18.38'
    springdocVersion = '2.8.8'
}

dependencies {
    // === SPRING CORE ===
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'

    // === DEV TOOLS ===
    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    // === LOMBOK ===
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"

    // === MAPSTRUCT ===
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"

    // === DATABASE ===
    runtimeOnly 'com.oracle.database.jdbc:ojdbc11'

    // === OPENAPI / SWAGGER ===
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${springdocVersion}"

    // === OCR e Visão Computacional ===
    implementation 'net.sourceforge.tess4j:tess4j:5.11.0'
    implementation 'org.openpnp:opencv:4.9.0-0' // inclui nu.pattern.OpenCV para carregar nativos

    // === TESTES ===
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'io.projectreactor:reactor-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // Plugins ImageIO para formatos não suportados nativamente
    implementation 'com.twelvemonkeys.imageio:imageio-jpeg:3.12.0'
    implementation 'com.twelvemonkeys.imageio:imageio-tiff:3.12.0'
    implementation 'com.twelvemonkeys.imageio:imageio-webp:3.12.0'
    implementation 'com.twelvemonkeys.imageio:imageio-bmp:3.12.0'
    implementation 'com.twelvemonkeys.imageio:imageio-pnm:3.12.0'

    // (Opcional) JAI ImageIO Core — melhora suporte a alguns TIFF/JP2K
    implementation 'com.github.jai-imageio:jai-imageio-core:1.4.0'
}


tasks.named('test') {

    useJUnitPlatform()
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build\resources\main\application.properties   |   TIPO: Configuração Spring
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

# ==================================================
# Spring Boot Application Configuration
# ==================================================

# --- Application Name and .env Import ---
# Defines the application name and allows importing configurations from a .env file.
spring.application.name=mottu-gradle

# --- Server Configuration ---
# Configures the embedded server (e.g., Tomcat).
server.port=8080
# Sets the application context path to root (e.g., http://localhost:8080/)
server.servlet.context-path=/

# --- Oracle DataSource Configuration ---
# Connection details for your Oracle database.
# The local XEPDB1 configuration is commented out; the FIAP Oracle DB is active.
#spring.datasource.url=jdbc:oracle:thin:@//localhost:1521/XEPDB1
#.profiles.active=dev
#spring.datasource.url=jdbc:oracle:thin:@//oracle.fiap.com.br:1521/ORCL
#spring.datasource.username=rm557881
#spring.datasource.password=fiap25
#spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

spring.profiles.active=dev
spring.datasource.url=jdbc:oracle:thin:@//localhost:1521/XEPDB1
spring.datasource.username=challenge
spring.datasource.password=paulo1
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- JPA / Hibernate Configuration ---
# Settings for Java Persistence API and Hibernate ORM.
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.hibernate.ddl-auto=validate

# --- Spring AI Configuration (Vertex AI Gemini) ---
# Reads Vertex AI Gemini settings from environment variables.
# Ensure VERTEX_AI_PROJECT_ID and API_KEY are set in your environment or .env file.
spring.ai.vertex.ai.gemini.project-id=${VERTEX_AI_PROJECT_ID}
spring.ai.vertex.ai.gemini.location=us-central1
spring.ai.vertex.ai.gemini.api-key=${API_KEY}
spring.ai.vertex.ai.gemini.transport=rest

# --- Springdoc OpenAPI (Swagger) Configuration ---
# Settings for API documentation generation.
# app.launch-swagger-on-startup=true # Tries to open Swagger UI in browser on startup.
# springdoc.api-docs.path=/v3/api-docs # Path for the OpenAPI specification.
# springdoc.swagger-ui.path=/swagger-ui/index.html # Path for the Swagger UI interface.

# --- HTTP Error Response Details ---
# Configures what details are included in HTTP error responses.
server.error.include-stacktrace=always
server.error.include-message=always
server.error.include-exception=true

# --- Logging Levels ---
# Defines verbosity for different logging categories.
logging.level.root=INFO

# Spring Framework specific logging
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.data.jpa=DEBUG
logging.level.org.springframework.security=TRACE
logging.level.org.springframework.security.web=TRACE
logging.level.org.springframework.security.authentication=TRACE

# Hibernate specific logging
logging.level.org.hibernate.type.descriptor.sql=TRACE
logging.level.org.hibernate.engine.jdbc.spi.SqlExceptionHelper=DEBUG
logging.level.org.hibernate.tool.schema.internal.SchemaCreatorImpl=DEBUG
logging.level.org.hibernate.dialect.Dialect=DEBUG
logging.level.org.hibernate.resource.jdbc=DEBUG

# Application specific logging (adjust br.com.fiap.mottu to your main application package if different)
logging.level.br.com.fiap.mottu=DEBUG

# Database driver and connection pool logging
logging.level.oracle=DEBUG
logging.level.com.zaxxer.hikari=DEBUG

# ==================================================
# *** CORREÇÃO: AUMENTAR LIMITE DE UPLOAD ***
# ==================================================
# Define o tamanho máximo de um único ficheiro para 10MB
spring.servlet.multipart.max-file-size=10MB
# Define o tamanho máximo total da requisição (incluindo múltiplos ficheiros) para 10MB
spring.servlet.multipart.max-request-size=10MB


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\resources\application.properties   |   TIPO: Configuração Spring
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

# ==================================================
# Spring Boot Application Configuration
# ==================================================

# --- Application Name and .env Import ---
# Defines the application name and allows importing configurations from a .env file.
spring.application.name=mottu-gradle

# --- Server Configuration ---
# Configures the embedded server (e.g., Tomcat).
server.port=8080
# Sets the application context path to root (e.g., http://localhost:8080/)
server.servlet.context-path=/

# --- Oracle DataSource Configuration ---
# spring.datasource.url=jdbc:oracle:thin:@//oracle.fiap.com.br:1521/ORCL
# spring.datasource.username=rm557881
# spring.datasource.password=fiap25
# spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- HikariCP Connection Pool Settings ---
# spring.datasource.hikari.maximum-pool-size=2
# spring.datasource.hikari.minimum-idle=2
# spring.datasource.hikari.idle-timeout=30000
# spring.datasource.hikari.connection-timeout=30000
# spring.datasource.hikari.max-lifetime=1800000

spring.output.ansi.enabled=ALWAYS

spring.profiles.active=dev
spring.datasource.url=jdbc:oracle:thin:@//localhost:1521/XEPDB1
spring.datasource.username=challenge
spring.datasource.password=paulo1
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- JPA / Hibernate Configuration ---
# Settings for Java Persistence API and Hibernate ORM.
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.hibernate.ddl-auto=validate

# --- HTTP Error Response Details ---
# Configures what details are included in HTTP error responses.
server.error.include-stacktrace=always
server.error.include-message=always
server.error.include-exception=true

# --- Logging Levels ---
# Defines verbosity for different logging categories.
logging.level.root=INFO

# Spring Framework specific logging
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.data.jpa=DEBUG
logging.level.org.springframework.security=TRACE
logging.level.org.springframework.security.web=TRACE
logging.level.org.springframework.security.authentication=TRACE

# Hibernate specific logging
logging.level.org.hibernate.type.descriptor.sql=TRACE
logging.level.org.hibernate.engine.jdbc.spi.SqlExceptionHelper=DEBUG
logging.level.org.hibernate.tool.schema.internal.SchemaCreatorImpl=DEBUG
logging.level.org.hibernate.dialect.Dialect=DEBUG
logging.level.org.hibernate.resource.jdbc=DEBUG

# Application specific logging (adjust br.com.fiap.mottu to your main application package if different)
logging.level.br.com.fiap.mottu=DEBUG

# Database driver and connection pool logging
logging.level.oracle=DEBUG
logging.level.com.zaxxer.hikari=DEBUG

# ==================================================
# *** CORREÇÃO: AUMENTAR LIMITE DE UPLOAD ***
# ==================================================
# Define o tamanho máximo de um único ficheiro para 10MB
spring.servlet.multipart.max-file-size=10MB
# Define o tamanho máximo total da requisição (incluindo múltiplos ficheiros) para 10MB
spring.servlet.multipart.max-request-size=10MB


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build.gradle   |   TIPO: Gradle Build File
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

plugins {
    id 'java'
    id 'org.springframework.boot' version '3.5.4'
    id 'io.spring.dependency-management' version '1.1.7'
}

group = 'br.com.fiap.mottu'
version = '0.0.1-SNAPSHOT'
description = 'mottu-gradle'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
    developmentOnly
    runtimeClasspath {
        extendsFrom developmentOnly
    }
    // remove conflitos com spring-jcl
    all {
        exclude group: 'commons-logging', module: 'commons-logging'
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion    = '1.18.38'
    springdocVersion = '2.8.8'
}

dependencies {
    // === SPRING CORE ===
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'

    // === DEV TOOLS ===
    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    // === LOMBOK ===
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"

    // === MAPSTRUCT ===
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"

    // === DATABASE ===
    runtimeOnly 'com.oracle.database.jdbc:ojdbc11'

    // === OPENAPI / SWAGGER ===
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${springdocVersion}"

    // === OCR e Visão Computacional ===
    implementation 'net.sourceforge.tess4j:tess4j:5.11.0'
    implementation 'org.openpnp:opencv:4.9.0-0' // inclui nu.pattern.OpenCV para carregar nativos

    // === TESTES ===
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'io.projectreactor:reactor-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // Plugins ImageIO para formatos não suportados nativamente
    implementation 'com.twelvemonkeys.imageio:imageio-jpeg:3.12.0'
    implementation 'com.twelvemonkeys.imageio:imageio-tiff:3.12.0'
    implementation 'com.twelvemonkeys.imageio:imageio-webp:3.12.0'
    implementation 'com.twelvemonkeys.imageio:imageio-bmp:3.12.0'
    implementation 'com.twelvemonkeys.imageio:imageio-pnm:3.12.0'

    // (Opcional) JAI ImageIO Core — melhora suporte a alguns TIFF/JP2K
    implementation 'com.github.jai-imageio:jai-imageio-core:1.4.0'
}


tasks.named('test') {

    useJUnitPlatform()
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build\resources\main\application.properties   |   TIPO: Configuração Spring
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

# ==================================================
# Spring Boot Application Configuration
# ==================================================

# --- Application Name and .env Import ---
spring.application.name=mottu-gradle

# --- Server Configuration ---
server.port=8080
server.servlet.context-path=/

# --- Oracle DataSource Configuration (FIAP REMOTO - comentado) ---
# spring.datasource.url=jdbc:oracle:thin:@//oracle.fiap.com.br:1521/ORCL
# spring.datasource.username=rm557881
# spring.datasource.password=fiap25
# spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- HikariCP Connection Pool Settings (exemplo - comentado) ---
# spring.datasource.hikari.maximum-pool-size=2
# spring.datasource.hikari.minimum-idle=2
# spring.datasource.hikari.idle-timeout=30000
# spring.datasource.hikari.connection-timeout=30000
# spring.datasource.hikari.max-lifetime=1800000

spring.output.ansi.enabled=ALWAYS

# --- Perfil e banco LOCAL ---
spring.profiles.active=dev
spring.datasource.url=jdbc:oracle:thin:@//localhost:1521/XEPDB1
spring.datasource.username=challenge
spring.datasource.password=paulo1
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- JPA / Hibernate Configuration ---
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.hibernate.ddl-auto=validate

# --- HTTP Error Response Details ---
server.error.include-stacktrace=always
server.error.include-message=always
server.error.include-exception=true

# --- Logging Levels ---
logging.level.root=INFO
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.data.jpa=DEBUG
logging.level.org.springframework.security=TRACE
logging.level.org.springframework.security.web=TRACE
logging.level.org.springframework.security.authentication=TRACE
logging.level.org.hibernate.type.descriptor.sql=TRACE
logging.level.org.hibernate.engine.jdbc.spi.SqlExceptionHelper=DEBUG
logging.level.org.hibernate.tool.schema.internal.SchemaCreatorImpl=DEBUG
logging.level.org.hibernate.dialect.Dialect=DEBUG
logging.level.org.hibernate.resource.jdbc=DEBUG
logging.level.br.com.fiap.mottu=DEBUG
logging.level.oracle=DEBUG
logging.level.com.zaxxer.hikari=DEBUG

# ==================================================
# *** CORREÇÃO: AUMENTAR LIMITE DE UPLOAD ***
# ==================================================
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# ==================================================
# *** OpenALPR (Community) ***
# ==================================================
# Caminho ABSOLUTO do executável no Windows (use barras duplas!)
mottu.ocr.alpr.command=C:\\openalpr_64\\alpr.exe
# use EU enquanto não existir br.conf/br.xml
mottu.ocr.alpr.region=eu
mottu.ocr.alpr.topn=10
mottu.ocr.alpr.minConfidence=80
mottu.ocr.alpr.timeoutMs=15000
mottu.ocr.alpr.debugOutputDir=logs


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\resources\application.properties   |   TIPO: Configuração Spring
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

# ==================================================
# Spring Boot Application Configuration
# ==================================================

# --- Application Name and .env Import ---
spring.application.name=mottu-gradle

# --- Server Configuration ---
server.port=8080
server.servlet.context-path=/

# --- Oracle DataSource Configuration (FIAP REMOTO - comentado) ---
# spring.datasource.url=jdbc:oracle:thin:@//oracle.fiap.com.br:1521/ORCL
# spring.datasource.username=rm557881
# spring.datasource.password=fiap25
# spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- HikariCP Connection Pool Settings (exemplo - comentado) ---
# spring.datasource.hikari.maximum-pool-size=2
# spring.datasource.hikari.minimum-idle=2
# spring.datasource.hikari.idle-timeout=30000
# spring.datasource.hikari.connection-timeout=30000
# spring.datasource.hikari.max-lifetime=1800000

spring.output.ansi.enabled=ALWAYS

# --- Perfil e banco LOCAL ---
spring.profiles.active=dev
spring.datasource.url=jdbc:oracle:thin:@//localhost:1521/XEPDB1
spring.datasource.username=challenge
spring.datasource.password=paulo1
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- JPA / Hibernate Configuration ---
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.hibernate.ddl-auto=validate

# --- HTTP Error Response Details ---
server.error.include-stacktrace=always
server.error.include-message=always
server.error.include-exception=true

# --- Logging Levels ---
logging.level.root=INFO
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.data.jpa=DEBUG
logging.level.org.springframework.security=TRACE
logging.level.org.springframework.security.web=TRACE
logging.level.org.springframework.security.authentication=TRACE
logging.level.org.hibernate.type.descriptor.sql=TRACE
logging.level.org.hibernate.engine.jdbc.spi.SqlExceptionHelper=DEBUG
logging.level.org.hibernate.tool.schema.internal.SchemaCreatorImpl=DEBUG
logging.level.org.hibernate.dialect.Dialect=DEBUG
logging.level.org.hibernate.resource.jdbc=DEBUG
logging.level.br.com.fiap.mottu=DEBUG
logging.level.oracle=DEBUG
logging.level.com.zaxxer.hikari=DEBUG

# ==================================================
# *** CORREÇÃO: AUMENTAR LIMITE DE UPLOAD ***
# ==================================================
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# ==================================================
# *** OpenALPR (Community) ***
# ==================================================
# Caminho ABSOLUTO do executável no Windows (use barras duplas!)
mottu.ocr.alpr.command=C:\\openalpr_64\\alpr.exe
# use EU enquanto não existir br.conf/br.xml
mottu.ocr.alpr.region=eu
mottu.ocr.alpr.topn=10
mottu.ocr.alpr.minConfidence=80
mottu.ocr.alpr.timeoutMs=15000
mottu.ocr.alpr.debugOutputDir=logs


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\MottuApplication.java   |   PACOTE: br.com.fiap.mottu   |   CLASSE: MottuApplication
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.web.client.RestTemplate; // <-- Importar RestTemplate
import org.springframework.web.reactive.function.client.WebClient; // <-- Adicione esta importação AQUI!
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;


@EnableJpaRepositories
@SpringBootApplication
@EnableCaching
@EnableJpaAuditing
public class MottuApplication {

	public static void main(String[] args) {
		SpringApplication.run(MottuApplication.class, args);
	}

	@Bean
	public RestTemplate restTemplate(){
		return new RestTemplate();
	}

	// Adicionado para suportar WebClient no EnderecoService
	@Bean // <-- Adicione este Bean AQUI!
	public WebClient.Builder webClientBuilder() {
		return WebClient.builder();
	}
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\test\java\br\com\fiap\mottu\MottuGradleApplicationTests.java   |   PACOTE: br.com.fiap.mottu   |   CLASSE: MottuGradleApplicationTests
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MottuGradleApplicationTests {

    @Test
    void contextLoads() {
    }

}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\MottuApplication.java   |   PACOTE: br.com.fiap.mottu   |   CLASSE: MottuApplication
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.web.client.RestTemplate; // <-- Importar RestTemplate
import org.springframework.web.reactive.function.client.WebClient; // <-- Adicione esta importação AQUI!
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;


@EnableJpaRepositories
@SpringBootApplication
@EnableCaching
@EnableJpaAuditing
public class MottuApplication {

	public static void main(String[] args) {
		SpringApplication.run(MottuApplication.class, args);
	}

	@Bean
	public RestTemplate restTemplate(){
		return new RestTemplate();
	}

	// Adicionado para suportar WebClient no EnderecoService
	@Bean // <-- Adicione este Bean AQUI!
	public WebClient.Builder webClientBuilder() {
		return WebClient.builder();
	}
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\test\java\br\com\fiap\mottu\MottuGradleApplicationTests.java   |   PACOTE: br.com.fiap.mottu   |   CLASSE: MottuGradleApplicationTests
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MottuGradleApplicationTests {

    @Test
    void contextLoads() {
    }

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.config
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\config\CorsConfig.java   |   PACOTE: br.com.fiap.mottu.config   |   CLASSE: CorsConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import java.util.Arrays;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    private final Environment environment;

    @Value("${cors.production.allowed.origins:https://seu-dominio-de-producao.com}")
    private String[] productionAllowedOrigins;

    public CorsConfig(Environment environment) {
        this.environment = environment;
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");

        if (isProdProfileActive) {
            // PRODUÇÃO
            if (productionAllowedOrigins != null && productionAllowedOrigins.length > 0 &&
                    productionAllowedOrigins[0] != null && !productionAllowedOrigins[0].isEmpty() &&
                    !productionAllowedOrigins[0].equalsIgnoreCase("https://seu-dominio-de-producao.com")) {
                registry.addMapping("/**")
                        .allowedOrigins(productionAllowedOrigins)
                        .allowedMethods("GET", "POST", "DELETE", "PUT", "PATCH", "OPTIONS", "HEAD")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            } else {
                registry.addMapping("/**")
                        .allowedOrigins("https://fallback-seguro-obrigatorio.com")
                        .allowedMethods("GET", "POST", "PUT", "DELETE")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            }
        } else {
            // DESENVOLVIMENTO
            String[] developmentAllowedOrigins = new String[] {
                    "http://localhost:3000",
                    "http://127.0.0.1:3000",
                    "http://192.168.0.3:3000",
                    "http://10.199.82.137:3000", // <- seu IP na LAN/tethering
                    "https://app.local:3443"    // <- se usar Caddy HTTPS com hostname
            };

            registry.addMapping("/**")
                    .allowedOrigins(developmentAllowedOrigins)
                    .allowedMethods("GET", "POST", "DELETE", "PUT", "PATCH", "OPTIONS", "HEAD")
                    .allowedHeaders("*")
                    .allowCredentials(true);
        }
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\config\OpenApiConfig.java   |   PACOTE: br.com.fiap.mottu.config   |   CLASSE: OpenApiConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springdoc.core.models.GroupedOpenApi; // opcional
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class OpenApiConfig {

    private static final Logger log = LoggerFactory.getLogger(OpenApiConfig.class);

    @Bean
    public OpenAPI customOpenAPI() {
        log.info("🔧 Configuração personalizada do OpenAPI inicializada com dados completos.");

        return new OpenAPI()
                .info(new Info()
                        .title("Challenge-2025-FIAP-TEMMU-METAMIND SOLUTIONS")
                        .version("1.0")
                        .description("""
                                **CHALLENGE - SPRINT 3 - FIAP 2025**

                                API RESTful para o Challenge Mottu - Rastreamento e organização dos veículos!.

                                **Endereço do Projeto GitHub:** [GitHub - Mottu](https://github.com/carmipa/challenge_2025_2_semestre_mottu_parte_1)
                                
                                **Endereço do repositório da matéria no GitHub:** [GitHub - Mottu](https://github.com/carmipa/challenge_2025_2_semestre_mottu_parte_1/tree/main/Java_Advanced)
                                
                                **Matéria:** Java Advanced

                                **Turma:** 2TDSPV / 2TDSPZ

                                **Contatos da Equipe:**
                                
                                - Arthur Bispo de Lima - RM557568: RM557568@fiap.com.br - 2TDSPV - [GitHub - ArthurBispo00](https://github.com/ArthurBispo00)
                                
                                - João Paulo Moreira - RM557808: RM557808@fiap.com.br - 2TDSPV - [GitHub - joao1015](https://github.com/joao1015)
                                
                                - Paulo André Carminati - RM557881: RM557881@fiap.com.br - 2TDSPZ - [GitHub - carmipa](https://github.com/carmipa)
                                
                                """)
                        .contact(new Contact()
                                .name("Metamind Solution")
                                .email("RM557568@fiap.com.br")
                                .url("https://wa.me/5511912345678")

                )
                        .license(new License()
                                .name("Licença de Uso")
                                .url("https://github.com/carmipa/challenge_2025_1_semestre_mottu/tree/main/Java_Advanced")
                        )
                )
                // Use server relativo para não “grudar” localhost:8080 no contrato
                .servers(List.of(new Server().url("/").description("Servidor relativo")));
    }

    // OPCIONAL: só se quiser documentar/grupar um pacote específico
    @Bean
    public GroupedOpenApi apiGroup() {
        return GroupedOpenApi.builder()
                .group("mottu")
                .packagesToScan("br.com.fiap.mottu") // ajuste se necessário
                .build();
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\config\OpenCvLoader.java   |   PACOTE: br.com.fiap.mottu.config   |   CLASSE: OpenCvLoader
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import jakarta.annotation.PostConstruct;
import nu.pattern.OpenCV;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class OpenCvLoader {

    private static final Logger log = LoggerFactory.getLogger(OpenCvLoader.class);

    @PostConstruct
    public void init() {
        try {
            OpenCV.loadLocally(); // carrega nativos do pacote org.openpnp:opencv
            log.info("OpenCV nativo carregado com sucesso.");
        } catch (Throwable t) {
            log.warn("OpenCV não pôde ser carregado. A detecção de placa será ignorada. ({})", t.toString());
        }
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\config\SwaggerBrowserLauncher.java   |   PACOTE: br.com.fiap.mottu.config   |   CLASSE: SwaggerBrowserLauncher
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

@Component
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    @Value("${server.port:8080}")
    private String serverPort;

    // Pode vir "", "/", "/minhaapp" ou "/minhaapp/"
    @Value("${server.servlet.context-path:}")
    private String contextPath;

    // Deve ser um path, ex.: "/swagger-ui/index.html" ou "swagger-ui/index.html"
    @Value("${springdoc.swagger-ui.path:/swagger-ui/index.html}")
    private String swaggerUiPath;

    @Value("${app.launch-swagger-on-startup:true}")
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automática do Swagger no navegador está desabilitada.");
            return;
        }

        String normalizedContext = normalizeContextPath(contextPath);   // "" ou "/algo" (sem barra no fim)
        String normalizedSwagger = normalizeUiPath(swaggerUiPath);      // sempre "/algo/.."

        // Base SEM path; resolve lida com as barras corretamente
        URI base = URI.create("http://localhost:" + serverPort + "/");

        // Junta com segurança (sem gerar //)
        String joinedPath = (normalizedContext + normalizedSwagger).replaceAll("/{2,}", "/");
        String url = base.resolve(joinedPath).toString();

        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI.");
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI: {}", e.getMessage());
            }
        } else {
            log.warn("Abertura automática do navegador não é suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }

    /** ""  -> ""
     *  "/" -> ""
     *  "/app/" -> "/app"
     *  "app" -> "/app"
     */
    private static String normalizeContextPath(String cp) {
        if (cp == null) return "";
        cp = cp.trim();
        if (cp.isEmpty() || "/".equals(cp)) return "";
        if (!cp.startsWith("/")) cp = "/" + cp;
        if (cp.endsWith("/")) cp = cp.substring(0, cp.length() - 1);
        return cp;
    }

    /** null|"" -> "/swagger-ui/index.html" (default)
     *  "swagger-ui/index.html" -> "/swagger-ui/index.html"
     *  "/swagger-ui/index.html" -> "/swagger-ui/index.html"
     *  Remove barras duplicadas internas.
     */
    private static String normalizeUiPath(String p) {
        if (p == null || p.isBlank()) p = "/swagger-ui/index.html";
        p = p.trim();
        if (!p.startsWith("/")) p = "/" + p;
        return p.replaceAll("/{2,}", "/");
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\config\CorsConfig.java   |   PACOTE: br.com.fiap.mottu.config   |   CLASSE: CorsConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import java.util.Arrays;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    private final Environment environment;

    @Value("${cors.production.allowed.origins:https://seu-dominio-de-producao.com}")
    private String[] productionAllowedOrigins;

    public CorsConfig(Environment environment) {
        this.environment = environment;
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");

        if (isProdProfileActive) {
            // PRODUÇÃO
            if (productionAllowedOrigins != null && productionAllowedOrigins.length > 0 &&
                    productionAllowedOrigins[0] != null && !productionAllowedOrigins[0].isEmpty() &&
                    !productionAllowedOrigins[0].equalsIgnoreCase("https://seu-dominio-de-producao.com")) {
                registry.addMapping("/**")
                        .allowedOrigins(productionAllowedOrigins)
                        .allowedMethods("GET", "POST", "DELETE", "PUT", "PATCH", "OPTIONS", "HEAD")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            } else {
                registry.addMapping("/**")
                        .allowedOrigins("https://fallback-seguro-obrigatorio.com")
                        .allowedMethods("GET", "POST", "PUT", "DELETE")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            }
        } else {
            // DESENVOLVIMENTO
            String[] developmentAllowedOrigins = new String[] {
                    "http://localhost:3000",
                    "http://127.0.0.1:3000",
                    "http://192.168.0.3:3000",
                    "http://10.199.82.137:3000", // <- seu IP na LAN/tethering
                    "https://app.local:3443"    // <- se usar Caddy HTTPS com hostname
            };

            registry.addMapping("/**")
                    .allowedOrigins(developmentAllowedOrigins)
                    .allowedMethods("GET", "POST", "DELETE", "PUT", "PATCH", "OPTIONS", "HEAD")
                    .allowedHeaders("*")
                    .allowCredentials(true);
        }
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\config\OpenApiConfig.java   |   PACOTE: br.com.fiap.mottu.config   |   CLASSE: OpenApiConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springdoc.core.models.GroupedOpenApi; // opcional
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class OpenApiConfig {

    private static final Logger log = LoggerFactory.getLogger(OpenApiConfig.class);

    @Bean
    public OpenAPI customOpenAPI() {
        log.info("🔧 Configuração personalizada do OpenAPI inicializada com dados completos.");

        return new OpenAPI()
                .info(new Info()
                        .title("Challenge-2025-FIAP-TEMMU-METAMIND SOLUTIONS")
                        .version("1.0")
                        .description("""
                                **CHALLENGE - SPRINT 3 - FIAP 2025**

                                API RESTful para o Challenge Mottu - Rastreamento e organização dos veículos!.

                                **Endereço do Projeto GitHub:** [GitHub - Mottu](https://github.com/carmipa/challenge_2025_2_semestre_mottu_parte_1)
                                
                                **Endereço do repositório da matéria no GitHub:** [GitHub - Mottu](https://github.com/carmipa/challenge_2025_2_semestre_mottu_parte_1/tree/main/Java_Advanced)
                                
                                **Matéria:** Java Advanced

                                **Turma:** 2TDSPV / 2TDSPZ

                                **Contatos da Equipe:**
                                
                                - Arthur Bispo de Lima - RM557568: RM557568@fiap.com.br - 2TDSPV - [GitHub - ArthurBispo00](https://github.com/ArthurBispo00)
                                
                                - João Paulo Moreira - RM557808: RM557808@fiap.com.br - 2TDSPV - [GitHub - joao1015](https://github.com/joao1015)
                                
                                - Paulo André Carminati - RM557881: RM557881@fiap.com.br - 2TDSPZ - [GitHub - carmipa](https://github.com/carmipa)
                                
                                """)
                        .contact(new Contact()
                                .name("Metamind Solution")
                                .email("RM557568@fiap.com.br")
                                .url("https://wa.me/5511912345678")

                )
                        .license(new License()
                                .name("Licença de Uso")
                                .url("https://github.com/carmipa/challenge_2025_1_semestre_mottu/tree/main/Java_Advanced")
                        )
                )
                // Use server relativo para não “grudar” localhost:8080 no contrato
                .servers(List.of(new Server().url("/").description("Servidor relativo")));
    }

    // OPCIONAL: só se quiser documentar/grupar um pacote específico
    @Bean
    public GroupedOpenApi apiGroup() {
        return GroupedOpenApi.builder()
                .group("mottu")
                .packagesToScan("br.com.fiap.mottu") // ajuste se necessário
                .build();
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\config\OpenCvLoader.java   |   PACOTE: br.com.fiap.mottu.config   |   CLASSE: OpenCvLoader
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import jakarta.annotation.PostConstruct;
import nu.pattern.OpenCV;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class OpenCvLoader {

    private static final Logger log = LoggerFactory.getLogger(OpenCvLoader.class);

    @PostConstruct
    public void init() {
        try {
            OpenCV.loadLocally(); // carrega nativos do pacote org.openpnp:opencv
            log.info("OpenCV nativo carregado com sucesso.");
        } catch (Throwable t) {
            log.warn("OpenCV não pôde ser carregado. A detecção de placa será ignorada. ({})", t.toString());
        }
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\config\SwaggerBrowserLauncher.java   |   PACOTE: br.com.fiap.mottu.config   |   CLASSE: SwaggerBrowserLauncher
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

@Component
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    @Value("${server.port:8080}")
    private String serverPort;

    // Pode vir "", "/", "/minhaapp" ou "/minhaapp/"
    @Value("${server.servlet.context-path:}")
    private String contextPath;

    // Deve ser um path, ex.: "/swagger-ui/index.html" ou "swagger-ui/index.html"
    @Value("${springdoc.swagger-ui.path:/swagger-ui/index.html}")
    private String swaggerUiPath;

    @Value("${app.launch-swagger-on-startup:true}")
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automática do Swagger no navegador está desabilitada.");
            return;
        }

        String normalizedContext = normalizeContextPath(contextPath);   // "" ou "/algo" (sem barra no fim)
        String normalizedSwagger = normalizeUiPath(swaggerUiPath);      // sempre "/algo/.."

        // Base SEM path; resolve lida com as barras corretamente
        URI base = URI.create("http://localhost:" + serverPort + "/");

        // Junta com segurança (sem gerar //)
        String joinedPath = (normalizedContext + normalizedSwagger).replaceAll("/{2,}", "/");
        String url = base.resolve(joinedPath).toString();

        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI.");
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI: {}", e.getMessage());
            }
        } else {
            log.warn("Abertura automática do navegador não é suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }

    /** ""  -> ""
     *  "/" -> ""
     *  "/app/" -> "/app"
     *  "app" -> "/app"
     */
    private static String normalizeContextPath(String cp) {
        if (cp == null) return "";
        cp = cp.trim();
        if (cp.isEmpty() || "/".equals(cp)) return "";
        if (!cp.startsWith("/")) cp = "/" + cp;
        if (cp.endsWith("/")) cp = cp.substring(0, cp.length() - 1);
        return cp;
    }

    /** null|"" -> "/swagger-ui/index.html" (default)
     *  "swagger-ui/index.html" -> "/swagger-ui/index.html"
     *  "/swagger-ui/index.html" -> "/swagger-ui/index.html"
     *  Remove barras duplicadas internas.
     */
    private static String normalizeUiPath(String p) {
        if (p == null || p.isBlank()) p = "/swagger-ui/index.html";
        p = p.trim();
        if (!p.startsWith("/")) p = "/" + p;
        return p.replaceAll("/{2,}", "/");
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.controller
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\BoxController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: BoxController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.box.BoxRequestDto; // DTO para entrada de dados de Box
import br.com.fiap.mottu.dto.box.BoxResponseDto; // DTO para saída de dados de Box
import br.com.fiap.mottu.filter.BoxFilter; // Filtros para busca de Boxes
import br.com.fiap.mottu.service.BoxService; // Serviço com a lógica de negócio para Boxes
import br.com.fiap.mottu.mapper.BoxMapper; // Mapper para converter entre Entidade e DTOs de Box
import br.com.fiap.mottu.model.Box; // Entidade Box
// Exceções são tratadas pelo GlobalExceptionHandler
// import br.com.fiap.mottu.exception.DuplicatedResourceException;
// import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada

// import java.util.List; // Não mais usado para listagem principal
// import java.util.stream.Collectors; // Não mais usado para mapear lista manualmente

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/boxes") // Mapeia todas as requisições que começam com /api/boxes para este controller
@Tag(name = "Boxes", description = "Gerenciamento de Boxes") // Tag do Swagger
public class BoxController {

    private static final Logger log = LoggerFactory.getLogger(BoxController.class); // Logger para esta classe
    private final BoxService boxService; // Injeção do serviço de Box
    private final BoxMapper boxMapper; // Injeção do mapper de Box

    @Autowired // Construtor para injeção de dependências
    public BoxController(BoxService boxService, BoxMapper boxMapper) {
        this.boxService = boxService; //
        this.boxMapper = boxMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todos os boxes com paginação",
            description = "Retorna uma página de todos os boxes cadastrados.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: nome,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de boxes retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/boxes
    public ResponseEntity<Page<BoxResponseDto>> listarTodosBoxes(
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todos os boxes com paginação: {}", pageable); //
        Page<Box> boxesPage = boxService.listarTodosBoxes(pageable); // Chama o serviço para obter a página de entidades
        Page<BoxResponseDto> boxesDtoPage = boxesPage.map(boxMapper::toResponseDto); // Mapeia a Page de Entidades para Page de DTOs
        log.info("Retornando {} boxes na página {} de um total de {} elementos.", boxesDtoPage.getNumberOfElements(), boxesDtoPage.getNumber(), boxesDtoPage.getTotalElements());
        return ResponseEntity.ok(boxesDtoPage); // Retorna a página de DTOs com status 200 OK
    }

    @Operation(
            summary = "Buscar box por ID", //
            description = "Retorna um box específico com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Box encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Box não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Box com ID 1 não encontrado(a).\",\"path\":\"/api/boxes/1\"}"))) //
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/boxes/{id}
    public ResponseEntity<BoxResponseDto> buscarBoxPorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando box com ID: {}", id); //
        // A exceção ResourceNotFoundException será lançada pelo serviço e tratada pelo GlobalExceptionHandler
        BoxResponseDto box = boxMapper.toResponseDto(boxService.buscarBoxPorId(id)); //
        log.info("Box com ID {} encontrado com sucesso.", id); //
        return ResponseEntity.ok(box); // Retorna o DTO do box com status 200 OK
    }

    @Operation(
            summary = "Buscar boxes por filtro com paginação", //
            description = "Retorna uma lista de boxes que correspondem aos critérios de filtro fornecidos.", //
            parameters = { // Documentação dos parâmetros de paginação e filtro
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de boxes filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/boxes/search
    public ResponseEntity<Page<BoxResponseDto>> buscarBoxesPorFiltro(
            BoxFilter filter, // Os parâmetros do filtro são injetados automaticamente
            @PageableDefault(size = 10) Pageable pageable) { // Parâmetros de paginação
        log.info("Buscando boxes com filtro: {} e paginação: {}", filter, pageable); //
        Page<Box> boxesPage = boxService.buscarBoxesPorFiltro(filter, pageable); // Chama o serviço
        Page<BoxResponseDto> boxesDtoPage = boxesPage.map(boxMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} boxes filtrados na página {} de {} elementos.", boxesDtoPage.getNumberOfElements(), boxesDtoPage.getNumber(), boxesDtoPage.getTotalElements());
        return ResponseEntity.ok(boxesDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar novo box", //
            description = "Cria um novo box com os dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Box criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))), //
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/boxes\"}"))), //
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Box com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/boxes\"}"))) //
            }
    )
    @PostMapping // Mapeia requisições POST para /api/boxes
    public ResponseEntity<BoxResponseDto> criarBox(@Valid @RequestBody BoxRequestDto boxRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar box: {}", boxRequestDto); //
        // DuplicatedResourceException será tratada pelo GlobalExceptionHandler
        BoxResponseDto novoBox = boxMapper.toResponseDto(boxService.criarBox(boxRequestDto)); //
        log.info("Box criado com sucesso com ID: {}", novoBox.getIdBox()); //
        return ResponseEntity.status(HttpStatus.CREATED).body(novoBox); // Retorna 201 CREATED com o DTO do novo box
    }

    @Operation(
            summary = "Atualizar box existente", //
            description = "Atualiza um box existente com base no ID e nos dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Box atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))), //
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/boxes/1\"}"))), //
                    @ApiResponse(responseCode = "404", description = "Box não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Box com ID 1 não encontrado(a).\",\"path\":\"/api/boxes/1\"}"))), //
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Box com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/boxes/1\"}"))) //
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/boxes/{id}
    public ResponseEntity<BoxResponseDto> atualizarBox(@PathVariable Long id, @Valid @RequestBody BoxRequestDto boxRequestDto) { //
        log.info("Recebida requisição para atualizar box com ID {}: {}", id, boxRequestDto); //
        // ResourceNotFoundException e DuplicatedResourceException serão tratadas pelo GlobalExceptionHandler
        BoxResponseDto boxAtualizado = boxMapper.toResponseDto(boxService.atualizarBox(id, boxRequestDto)); //
        log.info("Box com ID {} atualizado com sucesso.", id); //
        return ResponseEntity.ok(boxAtualizado); // Retorna 200 OK com o DTO do box atualizado
    }

    @Operation(
            summary = "Deletar box", //
            description = "Exclui um box com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Box deletado com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Box não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Box com ID 1 não encontrado(a).\",\"path\":\"/api/boxes/1\"}"))) //
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/boxes/{id}
    public ResponseEntity<Void> deletarBox(@PathVariable Long id) {
        log.info("Recebida requisição para deletar box com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        boxService.deletarBox(id); //
        log.info("Box com ID {} deletado com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\ClienteController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: ClienteController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto; // DTO para entrada de dados de Cliente
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto; // DTO para saída de dados de Cliente
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // DTO para saída de dados de Veículo
import br.com.fiap.mottu.filter.ClienteFilter; // Filtros para busca de Clientes
import br.com.fiap.mottu.service.ClienteService; // Serviço com a lógica de negócio para Clientes
import br.com.fiap.mottu.mapper.ClienteMapper; // Mapper para converter entre Entidade e DTOs de Cliente
import br.com.fiap.mottu.mapper.VeiculoMapper; // Mapper para Veículo
import br.com.fiap.mottu.model.Cliente; // Entidade Cliente
import br.com.fiap.mottu.model.Veiculo; // Entidade Veículo
// Exceções customizadas são tratadas pelo GlobalExceptionHandler
import br.com.fiap.mottu.exception.DuplicatedResourceException; //
import br.com.fiap.mottu.exception.ResourceNotFoundException; //
import br.com.fiap.mottu.exception.InvalidInputException; //

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado


import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada
import org.springframework.web.server.ResponseStatusException;
import reactor.core.publisher.Mono; // Para programação reativa

import java.util.Set; // Para coleções de Veiculos
import java.util.stream.Collectors; // Para coletar resultados de streams

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/clientes") // Mapeia todas as requisições que começam com /api/clientes para este controller
@Tag(name = "Clientes", description = "Gerenciamento de Clientes") // Tag do Swagger
public class ClienteController {

    private static final Logger log = LoggerFactory.getLogger(ClienteController.class); // Logger para esta classe
    private final ClienteService clienteService; // Injeção do serviço de Cliente
    private final ClienteMapper clienteMapper; // Injeção do mapper de Cliente
    private final VeiculoMapper veiculoMapper; // Injeção do mapper de Veículo

    @Autowired // Construtor para injeção de dependências
    public ClienteController(ClienteService clienteService, ClienteMapper clienteMapper, VeiculoMapper veiculoMapper) {
        this.clienteService = clienteService; //
        this.clienteMapper = clienteMapper; //
        this.veiculoMapper = veiculoMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todos os clientes com paginação",
            description = "Retorna uma página de todos os clientes cadastrados.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: nome,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de clientes retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/clientes
    public ResponseEntity<Page<ClienteResponseDto>> listarTodosClientes(
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todos os clientes com paginação: {}", pageable); //
        Page<Cliente> clientesPage = clienteService.listarTodosClientes(pageable); // Chama o serviço
        Page<ClienteResponseDto> clientesDtoPage = clientesPage.map(clienteMapper::toResponseDto); // Mapeia Page de Entidade para Page de DTO
        log.info("Retornando {} clientes na página {} de um total de {} elementos.", clientesDtoPage.getNumberOfElements(), clientesDtoPage.getNumber(), clientesDtoPage.getTotalElements());
        return ResponseEntity.ok(clientesDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Buscar cliente por ID", //
            description = "Retorna um cliente específico com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Cliente encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Cliente não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Cliente com ID 1 não encontrado(a).\",\"path\":\"/api/clientes/1\"}"))) //
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/clientes/{id}
    public ResponseEntity<ClienteResponseDto> buscarClientePorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando cliente com ID: {}", id); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        ClienteResponseDto cliente = clienteMapper.toResponseDto(clienteService.buscarClientePorId(id)); //
        log.info("Cliente com ID {} encontrado com sucesso.", id); //
        return ResponseEntity.ok(cliente); // Retorna o DTO do cliente
    }

    @Operation(
            summary = "Buscar clientes por filtro com paginação", //
            description = "Retorna uma página de clientes que correspondem aos critérios de filtro fornecidos.", //
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
                    // Adicionar documentação dos filtros de ClienteFilter se desejado
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de clientes filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/clientes/search
    public ResponseEntity<Page<ClienteResponseDto>> buscarClientesPorFiltro(
            ClienteFilter filter, // Filtros injetados automaticamente
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // Paginação
        log.info("Buscando clientes com filtro: {} e paginação: {}", filter, pageable); //
        Page<Cliente> clientesPage = clienteService.buscarClientesPorFiltro(filter, pageable); // Chama o serviço
        Page<ClienteResponseDto> clientesDtoPage = clientesPage.map(clienteMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} clientes filtrados na página {} de {} elementos.", clientesDtoPage.getNumberOfElements(), clientesDtoPage.getNumber(), clientesDtoPage.getTotalElements());
        return ResponseEntity.ok(clientesDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar novo cliente", //
            description = "Cria um novo cliente com os dados fornecidos, incluindo endereço e contato. Pode criar novos ou associar existentes.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))), //
                    // Outras respostas (400, 404, 409) são tratadas pelo GlobalExceptionHandler com base nas exceções lançadas pelo serviço
            }
    )
    @PostMapping // Mapeia requisições POST para /api/clientes
    public Mono<ResponseEntity<ClienteResponseDto>> criarCliente(@Valid @RequestBody ClienteRequestDto clienteRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar cliente: {}", clienteRequestDto); //
        return clienteService.criarCliente(clienteRequestDto) // Chama o serviço (reativo)
                .map(clienteCriado -> {
                    log.info("Cliente criado com sucesso com ID: {}", clienteCriado.getIdCliente()); //
                    return ResponseEntity.status(HttpStatus.CREATED).body(clienteMapper.toResponseDto(clienteCriado)); //
                })
                // O tratamento de erro reativo no serviço já prepara as exceções para o GlobalExceptionHandler
                // ou retorna Mono.error(excecaoCustomizada)
                .onErrorResume(e -> { // Este onErrorResume é um fallback geral no controller caso o serviço não trate todas as exceções reativamente para o GlobalExceptionHandler
                    if (e instanceof ResourceNotFoundException || e instanceof DuplicatedResourceException || e instanceof InvalidInputException) {
                        // Deixa o GlobalExceptionHandler lidar com essas exceções customizadas específicas
                        return Mono.error(e); //
                    }
                    log.error("Erro inesperado no controller ao criar cliente: {}", e.getMessage(), e); //
                    // Para outras exceções não tratadas explicitamente, pode-se retornar um erro genérico 500 ou uma exceção que o GlobalExceptionHandler pegue
                    return Mono.error(new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro inesperado ao processar a requisição.", e));
                });
    }

    @Operation(
            summary = "Atualizar cliente existente", //
            description = "Atualiza um cliente existente com base no ID e nos dados fornecidos. Permite atualizar endereço e contato.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Cliente atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))), //
                    // Outras respostas (400, 404, 409) são tratadas pelo GlobalExceptionHandler
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/clientes/{id}
    public Mono<ResponseEntity<ClienteResponseDto>> atualizarCliente(@PathVariable Long id, @Valid @RequestBody ClienteRequestDto clienteRequestDto) {
        log.info("Recebida requisição para atualizar cliente com ID {}: {}", id, clienteRequestDto); //
        return clienteService.atualizarCliente(id, clienteRequestDto) // Chama o serviço (reativo)
                .map(clienteAtualizado -> {
                    log.info("Cliente com ID {} atualizado com sucesso.", id); //
                    return ResponseEntity.ok(clienteMapper.toResponseDto(clienteAtualizado)); //
                })
                .onErrorResume(e -> { // Fallback no controller
                    if (e instanceof ResourceNotFoundException || e instanceof DuplicatedResourceException || e instanceof InvalidInputException) {
                        return Mono.error(e); //
                    }
                    log.error("Erro inesperado no controller ao atualizar cliente com ID {}: {}", id, e.getMessage(), e); //
                    return Mono.error(new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro inesperado ao processar a requisição.", e));
                });
    }

    @Operation(
            summary = "Deletar cliente", //
            description = "Exclui um cliente com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Cliente deletado com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Cliente não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/clientes/{id}
    public ResponseEntity<Void> deletarCliente(@PathVariable Long id) {
        log.info("Recebida requisição para deletar cliente com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        clienteService.deletarCliente(id); //
        log.info("Cliente com ID {} deletado com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }

    @Operation(
            summary = "Associar veículo a um cliente", //
            description = "Associa um veículo existente a um cliente existente. Requer os IDs do cliente, seu endereço e contato atuais, e o ID do veículo.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Associação criada com sucesso", content = @Content(schema = @Schema(type="string"))), //
                    // 404 (Cliente, Veículo, Endereço ou Contato não encontrado) e 409 (Associação já existe) são tratados pelo GlobalExceptionHandler
            }
    )
    @PostMapping("/{clienteId}/enderecos/{enderecoId}/contatos/{contatoId}/veiculos/{veiculoId}/associar")
    public ResponseEntity<String> associarClienteVeiculo(
            @PathVariable Long clienteId,
            @PathVariable Long enderecoId, // ID do endereço ATUALMENTE associado ao cliente
            @PathVariable Long contatoId,  // ID do contato ATUALMENTE associado ao cliente
            @PathVariable Long veiculoId) {
        log.info("Associando veículo ID {} ao cliente ID {} (com Endereco ID: {}, Contato ID: {}).", veiculoId, clienteId, enderecoId, contatoId); //
        // Exceções são tratadas pelo GlobalExceptionHandler
        clienteService.associarClienteVeiculo(clienteId, enderecoId, contatoId, veiculoId); //
        log.info("Associação entre Cliente {}, Endereco {}, Contato {} e Veículo {} criada com sucesso.", clienteId, enderecoId, contatoId, veiculoId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(
            summary = "Desassociar veículo de um cliente", //
            description = "Remove a associação entre um veículo e um cliente. Requer os IDs do cliente, seu endereço e contato atuais, e o ID do veículo.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"), //
                    // 404 (Associação não encontrada) é tratada pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{clienteId}/enderecos/{enderecoId}/contatos/{contatoId}/veiculos/{veiculoId}/desassociar")
    public ResponseEntity<Void> desassociarClienteVeiculo(
            @PathVariable Long clienteId,
            @PathVariable Long enderecoId, // ID do endereço usado na chave da associação
            @PathVariable Long contatoId,  // ID do contato usado na chave da associação
            @PathVariable Long veiculoId) { //
        log.info("Desassociando veículo ID {} do cliente ID {} (com Endereco ID: {}, Contato ID: {}).", veiculoId, clienteId, enderecoId, contatoId); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        clienteService.desassociarClienteVeiculo(clienteId, enderecoId, contatoId, veiculoId); //
        log.info("Associação entre Cliente {}, Endereco {}, Contato {} e Veículo {} removida com sucesso.", clienteId, enderecoId, contatoId, veiculoId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(
            summary = "Listar veículos de um cliente", //
            description = "Retorna todos os veículos associados a um cliente específico.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículos do cliente retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))), // O Swagger pode mostrar um array aqui.
                    @ApiResponse(responseCode = "404", description = "Cliente não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @GetMapping("/{clienteId}/veiculos") // Mapeia GET para /api/clientes/{clienteId}/veiculos
    public ResponseEntity<Set<VeiculoResponseDto>> getVeiculosByClienteId(@PathVariable Long clienteId) {
        log.info("Buscando veículos associados ao cliente com ID: {}", clienteId); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        Set<Veiculo> veiculos = clienteService.getVeiculosByClienteId(clienteId); //
        Set<VeiculoResponseDto> veiculosDto = veiculos.stream()
                .map(veiculoMapper::toResponseDto) // Mapeia cada veículo para seu DTO
                .collect(Collectors.toSet()); //
        log.info("Retornando {} veículos para o cliente com ID {}.", veiculosDto.size(), clienteId); //
        return ResponseEntity.ok(veiculosDto); // Retorna o conjunto de DTOs de veículos
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\ContatoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: ContatoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto; // DTO para entrada de dados de Contato
import br.com.fiap.mottu.dto.contato.ContatoResponseDto; // DTO para saída de dados de Contato
import br.com.fiap.mottu.filter.ContatoFilter; // Filtros para busca de Contatos
import br.com.fiap.mottu.service.ContatoService; // Serviço com a lógica de negócio para Contatos
import br.com.fiap.mottu.mapper.ContatoMapper; // Mapper para converter entre Entidade e DTOs de Contato
import br.com.fiap.mottu.model.Contato; // Entidade Contato
// Exceções são tratadas pelo GlobalExceptionHandler
// import br.com.fiap.mottu.exception.DuplicatedResourceException;
// import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada

// import java.util.List; // Não mais usado para listagem principal
// import java.util.stream.Collectors; // Não mais usado para mapear lista manualmente

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/contatos") // Mapeia todas as requisições que começam com /api/contatos para este controller
@Tag(name = "Contatos", description = "Gerenciamento de Contatos") // Tag do Swagger
public class ContatoController {

    private static final Logger log = LoggerFactory.getLogger(ContatoController.class); // Logger para esta classe
    private final ContatoService contatoService; // Injeção do serviço de Contato
    private final ContatoMapper contatoMapper; // Injeção do mapper de Contato

    @Autowired // Construtor para injeção de dependências
    public ContatoController(ContatoService contatoService, ContatoMapper contatoMapper) {
        this.contatoService = contatoService; //
        this.contatoMapper = contatoMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todos os contatos com paginação",
            description = "Retorna uma página de todos os contatos cadastrados.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: email,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de contatos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/contatos
    public ResponseEntity<Page<ContatoResponseDto>> listarTodosContatos(
            @PageableDefault(size = 10, sort = "email") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todos os contatos com paginação: {}", pageable); //
        Page<Contato> contatosPage = contatoService.listarTodosContatos(pageable); // Chama o serviço
        Page<ContatoResponseDto> contatosDtoPage = contatosPage.map(contatoMapper::toResponseDto); // Mapeia Page de Entidade para Page de DTO
        log.info("Retornando {} contatos na página {} de um total de {} elementos.", contatosDtoPage.getNumberOfElements(), contatosDtoPage.getNumber(), contatosDtoPage.getTotalElements());
        return ResponseEntity.ok(contatosDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Buscar contato por ID", //
            description = "Retorna um contato específico com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contato encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Contato não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Contato com ID 1 não encontrado(a).\",\"path\":\"/api/contatos/1\"}"))) //
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/contatos/{id}
    public ResponseEntity<ContatoResponseDto> buscarContatoPorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando contato com ID: {}", id); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        ContatoResponseDto contato = contatoMapper.toResponseDto(contatoService.buscarContatoPorId(id)); //
        log.info("Contato com ID {} encontrado com sucesso.", id); //
        return ResponseEntity.ok(contato); // Retorna o DTO do contato
    }

    @Operation(
            summary = "Buscar contatos por filtro com paginação", //
            description = "Retorna uma página de contatos que correspondem aos critérios de filtro fornecidos.", //
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de contatos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/contatos/search
    public ResponseEntity<Page<ContatoResponseDto>> buscarContatosPorFiltro(
            ContatoFilter filter, // Filtros injetados automaticamente
            @PageableDefault(size = 10, sort = "email") Pageable pageable) { // Paginação
        log.info("Buscando contatos com filtro: {} e paginação: {}", filter, pageable); //
        Page<Contato> contatosPage = contatoService.buscarContatosPorFiltro(filter, pageable); // Chama o serviço
        Page<ContatoResponseDto> contatosDtoPage = contatosPage.map(contatoMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} contatos filtrados na página {} de {} elementos.", contatosDtoPage.getNumberOfElements(), contatosDtoPage.getNumber(), contatosDtoPage.getTotalElements());
        return ResponseEntity.ok(contatosDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar novo contato", //
            description = "Cria um novo contato com os dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Contato criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))), //
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"), // Tratado pelo GlobalExceptionHandler (Bean Validation)
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (email duplicado)") // Tratado pelo GlobalExceptionHandler
            }
    )
    @PostMapping // Mapeia requisições POST para /api/contatos
    public ResponseEntity<ContatoResponseDto> criarContato(@Valid @RequestBody ContatoRequestDto contatoRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar contato: {}", contatoRequestDto); //
        // DuplicatedResourceException é tratada pelo GlobalExceptionHandler
        ContatoResponseDto novoContato = contatoMapper.toResponseDto(contatoService.criarContato(contatoRequestDto)); //
        log.info("Contato criado com sucesso com ID: {}", novoContato.getIdContato()); //
        return ResponseEntity.status(HttpStatus.CREATED).body(novoContato); // Retorna 201 CREATED com o DTO do novo contato
    }

    @Operation(
            summary = "Atualizar contato existente", //
            description = "Atualiza um contato existente com base no ID e nos dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contato atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))), //
                    // 400, 404, 409 são tratados pelo GlobalExceptionHandler
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/contatos/{id}
    public ResponseEntity<ContatoResponseDto> atualizarContato(@PathVariable Long id, @Valid @RequestBody ContatoRequestDto contatoRequestDto) { //
        log.info("Recebida requisição para atualizar contato com ID {}: {}", id, contatoRequestDto); //
        // ResourceNotFoundException e DuplicatedResourceException são tratadas pelo GlobalExceptionHandler
        ContatoResponseDto contatoAtualizado = contatoMapper.toResponseDto(contatoService.atualizarContato(id, contatoRequestDto)); //
        log.info("Contato com ID {} atualizado com sucesso.", id); //
        return ResponseEntity.ok(contatoAtualizado); // Retorna 200 OK com o DTO do contato atualizado
    }

    @Operation(
            summary = "Deletar contato", //
            description = "Exclui um contato com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Contato deletado com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Contato não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/contatos/{id}
    public ResponseEntity<Void> deletarContato(@PathVariable Long id) {
        log.info("Recebida requisição para deletar contato com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        contatoService.deletarContato(id); //
        log.info("Contato com ID {} deletado com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\EnderecoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: EnderecoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto; // DTO para entrada de dados de Endereço
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto; // DTO para saída de dados de Endereço
import br.com.fiap.mottu.filter.EnderecoFilter; // Filtros para busca de Endereços
import br.com.fiap.mottu.service.EnderecoService; // Serviço com a lógica de negócio para Endereços
import br.com.fiap.mottu.mapper.EnderecoMapper; // Mapper para converter entre Entidade e DTOs de Endereço
import br.com.fiap.mottu.model.Endereco; // Entidade Endereco
// Exceções customizadas
import br.com.fiap.mottu.exception.ResourceNotFoundException; //
import br.com.fiap.mottu.exception.InvalidInputException; //


import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import org.springframework.web.server.ResponseStatusException; // Para lançar exceções HTTP específicas
import jakarta.validation.Valid; // Para validar DTOs de entrada
import reactor.core.publisher.Mono; // Para programação reativa (ViaCEP)

// import java.util.List; // Não mais usado para listagem principal
// import java.util.stream.Collectors; // Não mais usado para mapear lista manualmente

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/enderecos") // Mapeia todas as requisições que começam com /api/enderecos para este controller
@Tag(name = "Enderecos", description = "Gerenciamento de Endereços") // Tag do Swagger
public class EnderecoController {

    private static final Logger log = LoggerFactory.getLogger(EnderecoController.class); // Logger para esta classe
    private final EnderecoService enderecoService; // Injeção do serviço de Endereço
    private final EnderecoMapper enderecoMapper; // Injeção do mapper de Endereço

    @Autowired // Construtor para injeção de dependências
    public EnderecoController(EnderecoService enderecoService, EnderecoMapper enderecoMapper) {
        this.enderecoService = enderecoService; //
        this.enderecoMapper = enderecoMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todos os endereços com paginação",
            description = "Retorna uma página de todos os endereços cadastrados.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: cep,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de endereços retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/enderecos
    public ResponseEntity<Page<EnderecoResponseDto>> listarTodosEnderecos(
            @PageableDefault(size = 10, sort = "cep") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todos os endereços com paginação: {}", pageable); //
        Page<Endereco> enderecosPage = enderecoService.listarTodosEnderecos(pageable); // Chama o serviço
        Page<EnderecoResponseDto> enderecosDtoPage = enderecosPage.map(enderecoMapper::toResponseDto); // Mapeia Page de Entidade para Page de DTO
        log.info("Retornando {} endereços na página {} de um total de {} elementos.", enderecosDtoPage.getNumberOfElements(), enderecosDtoPage.getNumber(), enderecosDtoPage.getTotalElements());
        return ResponseEntity.ok(enderecosDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Buscar endereço por ID", //
            description = "Retorna um endereço específico com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Endereço encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Endereço não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/enderecos/{id}
    public ResponseEntity<EnderecoResponseDto> buscarEnderecoPorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando endereço com ID: {}", id); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        EnderecoResponseDto endereco = enderecoMapper.toResponseDto(enderecoService.buscarEnderecoPorId(id)); //
        log.info("Endereço com ID {} encontrado com sucesso.", id); //
        return ResponseEntity.ok(endereco); // Retorna o DTO do endereço
    }

    @Operation(
            summary = "Buscar endereços por filtro com paginação", //
            description = "Retorna uma página de endereços que correspondem aos critérios de filtro fornecidos.", //
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de endereços filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/enderecos/search
    public ResponseEntity<Page<EnderecoResponseDto>> buscarEnderecosPorFiltro(
            EnderecoFilter filter, // Filtros injetados automaticamente
            @PageableDefault(size = 10, sort = "cep") Pageable pageable) { // Paginação
        log.info("Buscando endereços com filtro: {} e paginação: {}", filter, pageable); //
        Page<Endereco> enderecosPage = enderecoService.buscarEnderecosPorFiltro(filter, pageable); // Chama o serviço (método adicionado no service)
        Page<EnderecoResponseDto> enderecosDtoPage = enderecosPage.map(enderecoMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} endereços filtrados na página {} de {} elementos.", enderecosDtoPage.getNumberOfElements(), enderecosDtoPage.getNumber(), enderecosDtoPage.getTotalElements());
        return ResponseEntity.ok(enderecosDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar novo endereço", //
            description = "Cria um novo endereço com os dados fornecidos, buscando informações de CEP na ViaCEP.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Endereço criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))), //
                    // 400 (CEP inválido/não fornecido) e 404 (CEP não encontrado no ViaCEP) são tratados pelo serviço/GlobalExceptionHandler
            }
    )
    @PostMapping // Mapeia requisições POST para /api/enderecos
    public Mono<ResponseEntity<EnderecoResponseDto>> criarEndereco(@Valid @RequestBody EnderecoRequestDto enderecoRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar endereço: {}", enderecoRequestDto); //
        return enderecoService.criarEndereco(enderecoRequestDto) // Chama o serviço (reativo)
                .map(enderecoCriado -> {
                    log.info("Endereço criado com sucesso com ID: {}", enderecoCriado.getIdEndereco()); //
                    return ResponseEntity.status(HttpStatus.CREATED).body(enderecoMapper.toResponseDto(enderecoCriado)); //
                })
                .onErrorResume(e -> { // Tratamento de erro reativo no controller
                    if (e instanceof ResourceNotFoundException || e instanceof InvalidInputException) {
                        return Mono.error(e); // Deixa o GlobalExceptionHandler lidar
                    }
                    log.error("Erro inesperado no controller ao criar endereço: {}", e.getMessage(), e); //
                    return Mono.error(new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro inesperado ao processar a requisição.", e));
                });
    }

    @Operation(
            summary = "Atualizar endereço existente", //
            description = "Atualiza um endereço existente com base no ID e nos dados fornecidos. Pode buscar informações de CEP na ViaCEP se o CEP for alterado.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Endereço atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))), //
                    // 400, 404 são tratados pelo serviço/GlobalExceptionHandler
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/enderecos/{id}
    public Mono<ResponseEntity<EnderecoResponseDto>> atualizarEndereco(@PathVariable Long id, @Valid @RequestBody EnderecoRequestDto enderecoRequestDto) { //
        log.info("Recebida requisição para atualizar endereço com ID {}: {}", id, enderecoRequestDto); //
        return enderecoService.atualizarEndereco(id, enderecoRequestDto) // Chama o serviço (reativo)
                .map(enderecoAtualizado -> {
                    log.info("Endereço com ID {} atualizado com sucesso.", id); //
                    return ResponseEntity.ok(enderecoMapper.toResponseDto(enderecoAtualizado)); //
                })
                .onErrorResume(e -> { // Tratamento de erro reativo no controller
                    if (e instanceof ResourceNotFoundException || e instanceof InvalidInputException) {
                        return Mono.error(e); // Deixa o GlobalExceptionHandler lidar
                    }
                    log.error("Erro inesperado no controller ao atualizar endereço com ID {}: {}", id, e.getMessage(), e); //
                    return Mono.error(new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro inesperado ao processar a requisição.", e));
                });
    }

    @Operation(
            summary = "Deletar endereço", //
            description = "Exclui um endereço com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Endereço deletado com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Endereço não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/enderecos/{id}
    public ResponseEntity<Void> deletarEndereco(@PathVariable Long id) {
        log.info("Recebida requisição para deletar endereço com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        enderecoService.deletarEndereco(id); //
        log.info("Endereço com ID {} deletado com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\EstacionamentoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: EstacionamentoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/mottu/controller/EstacionamentoController.java
package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.mapper.BoxMapper;
import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.service.EstacionamentoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/estacionamento")
@Tag(name = "Estacionamento", description = "Operações de estacionar e liberar vagas")
public class EstacionamentoController {

    private final EstacionamentoService estacionamentoService;
    private final BoxMapper boxMapper;

    @Autowired
    public EstacionamentoController(EstacionamentoService estacionamentoService, BoxMapper boxMapper) {
        this.estacionamentoService = estacionamentoService;
        this.boxMapper = boxMapper;
    }

    @Operation(summary = "Armazenar Moto", description = "Encontra uma vaga livre e estaciona a moto correspondente à placa.")
    @PostMapping("/estacionar")
    public ResponseEntity<BoxResponseDto> estacionarMoto(@RequestParam String placa) {
        Box vaga = estacionamentoService.parkMoto(placa);
        return ResponseEntity.ok(boxMapper.toResponseDto(vaga));
    }

    @Operation(summary = "Liberar Vaga", description = "Libera a vaga ocupada pela moto correspondente à placa.")
    @PostMapping("/liberar")
    public ResponseEntity<Void> liberarVaga(@RequestParam String placa) {
        estacionamentoService.releaseSpot(placa);
        return ResponseEntity.noContent().build();
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\PatioController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: PatioController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

// DTOs de Requisição e Resposta
import br.com.fiap.mottu.dto.patio.PatioRequestDto; //
import br.com.fiap.mottu.dto.patio.PatioResponseDto; //
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; //
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;       //
import br.com.fiap.mottu.dto.box.BoxResponseDto;         //
import br.com.fiap.mottu.dto.contato.ContatoResponseDto; //
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto; //
// Filtro
import br.com.fiap.mottu.filter.PatioFilter; //
// Serviço e Mappers
import br.com.fiap.mottu.service.PatioService; //
import br.com.fiap.mottu.mapper.PatioMapper; //
import br.com.fiap.mottu.mapper.VeiculoMapper; //
import br.com.fiap.mottu.mapper.ZonaMapper;    //
import br.com.fiap.mottu.mapper.BoxMapper;      //
import br.com.fiap.mottu.mapper.ContatoMapper;  //
import br.com.fiap.mottu.mapper.EnderecoMapper; //
import br.com.fiap.mottu.model.Patio; // Entidade Pátio
// Exceções (tratadas globalmente)
// import br.com.fiap.mottu.exception.DuplicatedResourceException;
// import br.com.fiap.mottu.exception.ResourceNotFoundException;

// Swagger/OpenAPI
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;

// Logging
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
// Spring Framework
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus; //
import org.springframework.http.ResponseEntity; //
import org.springframework.web.bind.annotation.*;
// Validation
import jakarta.validation.Valid;

import java.util.Set; //
import java.util.stream.Collectors; //

@RestController // Controller REST
@RequestMapping("/api/patios") // Mapeamento base para este controller
@Tag(name = "Patios", description = "Gerenciamento de Pátios e Suas Associações") // Tag Swagger
public class PatioController {

    private static final Logger log = LoggerFactory.getLogger(PatioController.class); // Logger
    // Injeção de Serviços e Mappers
    private final PatioService patioService; //
    private final PatioMapper patioMapper; //
    private final VeiculoMapper veiculoMapper; //
    private final ZonaMapper zonaMapper; //
    private final BoxMapper boxMapper; //
    private final ContatoMapper contatoMapper; //
    private final EnderecoMapper enderecoMapper; //

    @Autowired // Construtor para injeção de dependências
    public PatioController(PatioService patioService, PatioMapper patioMapper,
                           VeiculoMapper veiculoMapper, ZonaMapper zonaMapper,
                           ContatoMapper contatoMapper, EnderecoMapper enderecoMapper,
                           BoxMapper boxMapper) { //
        this.patioService = patioService;
        this.patioMapper = patioMapper;
        this.veiculoMapper = veiculoMapper; //
        this.zonaMapper = zonaMapper; //
        this.boxMapper = boxMapper; //
        this.contatoMapper = contatoMapper; //
        this.enderecoMapper = enderecoMapper; //
    }

    // Operações CRUD para Pátio

    @Operation(summary = "Listar todos os pátios com paginação", description = "Retorna uma página de todos os pátios cadastrados.") //
    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0"))
    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10"))
    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string", defaultValue = "nomePatio,asc"))
    @ApiResponse(responseCode = "200", description = "Página de pátios retornada com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class))) //
    @GetMapping // Mapeia GET para /api/patios
    public ResponseEntity<Page<PatioResponseDto>> listarTodosPatios(
            @PageableDefault(size = 10, sort = "nomePatio") Pageable pageable) {
        log.info("Buscando todos os pátios com paginação: {}", pageable); //
        Page<Patio> patiosPage = patioService.listarTodosPatios(pageable); // Chama o serviço
        Page<PatioResponseDto> patiosDtoPage = patiosPage.map(patioMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} pátios na página {} de {} elementos.", patiosDtoPage.getNumberOfElements(), patiosDtoPage.getNumber(), patiosDtoPage.getTotalElements());
        return ResponseEntity.ok(patiosDtoPage); // Retorna a página
    }

    @Operation(summary = "Buscar pátio por ID", description = "Retorna um pátio específico com base no ID fornecido.") //
    @ApiResponse(responseCode = "200", description = "Pátio encontrado", content = @Content(mediaType = "application/json", schema = @Schema(implementation = PatioResponseDto.class))) //
    @ApiResponse(responseCode = "404", description = "Pátio não encontrado") // Tratado globalmente
    @GetMapping("/{id}")
    public ResponseEntity<PatioResponseDto> buscarPatioPorId(@PathVariable Long id) {
        log.info("Buscando pátio com ID: {}", id); //
        PatioResponseDto patioDto = patioMapper.toResponseDto(patioService.buscarPatioPorId(id)); //
        log.info("Pátio com ID {} encontrado.", id); //
        return ResponseEntity.ok(patioDto);
    }

    @Operation(summary = "Buscar pátios por filtro com paginação", description = "Retorna uma página de pátios que correspondem aos critérios de filtro.") //
    @Parameter(name = "page", description = "Número da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0"))
    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10"))
    @Parameter(name = "sort", description = "Ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
    @ApiResponse(responseCode = "200", description = "Página de pátios filtrada", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class))) //
    @GetMapping("/search")
    public ResponseEntity<Page<PatioResponseDto>> buscarPatiosPorFiltro(
            PatioFilter filter, @PageableDefault(size = 10) Pageable pageable) {
        log.info("Buscando pátios com filtro: {} e paginação: {}", filter, pageable); //
        Page<Patio> patiosPage = patioService.buscarPatiosPorFiltro(filter, pageable); //
        Page<PatioResponseDto> patiosDtoPage = patiosPage.map(patioMapper::toResponseDto);
        log.info("Retornando {} pátios filtrados.", patiosDtoPage.getNumberOfElements()); //
        return ResponseEntity.ok(patiosDtoPage);
    }

    @Operation(summary = "Criar novo pátio", description = "Cria um novo pátio.") //
    @ApiResponse(responseCode = "201", description = "Pátio criado", content = @Content(mediaType = "application/json", schema = @Schema(implementation = PatioResponseDto.class))) //
    @ApiResponse(responseCode = "400", description = "Dados inválidos") // Tratado globalmente (Bean Validation)
    @ApiResponse(responseCode = "409", description = "Pátio já existe") // Tratado globalmente
    @PostMapping
    public ResponseEntity<PatioResponseDto> criarPatio(@Valid @RequestBody PatioRequestDto patioRequestDto) { //
        log.info("Criando pátio: {}", patioRequestDto); //
        PatioResponseDto novoPatio = patioMapper.toResponseDto(patioService.criarPatio(patioRequestDto)); //
        log.info("Pátio criado com ID: {}", novoPatio.getIdPatio()); //
        return ResponseEntity.status(HttpStatus.CREATED).body(novoPatio); //
    }

    @Operation(summary = "Atualizar pátio existente", description = "Atualiza dados de um pátio.") //
    @ApiResponse(responseCode = "200", description = "Pátio atualizado", content = @Content(mediaType = "application/json", schema = @Schema(implementation = PatioResponseDto.class))) //
    @ApiResponse(responseCode = "404", description = "Pátio não encontrado") // Tratado globalmente
    @ApiResponse(responseCode = "409", description = "Conflito de dados (ex: nome duplicado)") // Tratado globalmente
    @PutMapping("/{id}")
    public ResponseEntity<PatioResponseDto> atualizarPatio(@PathVariable Long id, @Valid @RequestBody PatioRequestDto patioRequestDto) { //
        log.info("Atualizando pátio ID {}: {}", id, patioRequestDto); //
        PatioResponseDto patioAtualizado = patioMapper.toResponseDto(patioService.atualizarPatio(id, patioRequestDto)); //
        log.info("Pátio ID {} atualizado.", id); //
        return ResponseEntity.ok(patioAtualizado);
    }

    @Operation(summary = "Deletar pátio", description = "Exclui um pátio.") //
    @ApiResponse(responseCode = "204", description = "Pátio deletado") //
    @ApiResponse(responseCode = "404", description = "Pátio não encontrado") // Tratado globalmente
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarPatio(@PathVariable Long id) {
        log.info("Deletando pátio ID: {}", id); //
        patioService.deletarPatio(id); //
        log.info("Pátio ID {} deletado.", id); //
        return ResponseEntity.noContent().build(); //
    }

    // --- Endpoints de Associação de Veículos com Pátio ---
    @Operation(summary = "Associar veículo a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/veiculos/{veiculoId}/associar")
    public ResponseEntity<String> associarPatioVeiculo(@PathVariable Long patioId, @PathVariable Long veiculoId) { //
        log.info("Associando veículo ID {} ao pátio ID {}.", veiculoId, patioId); //
        patioService.associarPatioVeiculo(patioId, veiculoId); //
        log.info("Associação Pátio {} e Veículo {} criada.", patioId, veiculoId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar veículo de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/veiculos/{veiculoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioVeiculo(@PathVariable Long patioId, @PathVariable Long veiculoId) {
        log.info("Desassociando veículo ID {} do pátio ID {}.", veiculoId, patioId); //
        patioService.desassociarPatioVeiculo(patioId, veiculoId); //
        log.info("Associação Pátio {} e Veículo {} removida.", patioId, veiculoId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar veículos de um pátio") //
    @ApiResponse(responseCode = "200", description = "Veículos do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/veiculos")
    public ResponseEntity<Set<VeiculoResponseDto>> getVeiculosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando veículos do pátio ID: {}", patioId); //
        Set<VeiculoResponseDto> veiculos = patioService.getVeiculosByPatioId(patioId) //
                .stream().map(veiculoMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} veículos para o pátio ID {}.", veiculos.size(), patioId); //
        return ResponseEntity.ok(veiculos);
    }

    // --- Endpoints de Associação de Zonas com Pátio ---
    @Operation(summary = "Associar zona a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/zonas/{zonaId}/associar")
    public ResponseEntity<String> associarPatioZona(@PathVariable Long patioId, @PathVariable Long zonaId) { //
        log.info("Associando zona ID {} ao pátio ID {}.", zonaId, patioId); //
        patioService.associarPatioZona(patioId, zonaId); //
        log.info("Associação Pátio {} e Zona {} criada.", patioId, zonaId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar zona de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/zonas/{zonaId}/desassociar")
    public ResponseEntity<Void> desassociarPatioZona(@PathVariable Long patioId, @PathVariable Long zonaId) {
        log.info("Desassociando zona ID {} do pátio ID {}.", zonaId, patioId); //
        patioService.desassociarPatioZona(patioId, zonaId); //
        log.info("Associação Pátio {} e Zona {} removida.", patioId, zonaId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar zonas de um pátio") //
    @ApiResponse(responseCode = "200", description = "Zonas do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/zonas")
    public ResponseEntity<Set<ZonaResponseDto>> getZonasByPatioId(@PathVariable Long patioId) {
        log.info("Buscando zonas do pátio ID: {}", patioId); //
        Set<ZonaResponseDto> zonas = patioService.getZonasByPatioId(patioId) //
                .stream().map(zonaMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} zonas para o pátio ID {}.", zonas.size(), patioId); //
        return ResponseEntity.ok(zonas);
    }

    // --- Endpoints de Associação de Contatos com Pátio ---
    @Operation(summary = "Associar contato a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/contatos/{contatoId}/associar")
    public ResponseEntity<String> associarPatioContato(@PathVariable Long patioId, @PathVariable Long contatoId) { //
        log.info("Associando contato ID {} ao pátio ID {}.", contatoId, patioId); //
        patioService.associarPatioContato(patioId, contatoId); //
        log.info("Associação Pátio {} e Contato {} criada.", patioId, contatoId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar contato de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/contatos/{contatoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioContato(@PathVariable Long patioId, @PathVariable Long contatoId) {
        log.info("Desassociando contato ID {} do pátio ID {}.", contatoId, patioId); //
        patioService.desassociarPatioContato(patioId, contatoId); //
        log.info("Associação Pátio {} e Contato {} removida.", patioId, contatoId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar contatos de um pátio") //
    @ApiResponse(responseCode = "200", description = "Contatos do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/contatos")
    public ResponseEntity<Set<ContatoResponseDto>> getContatosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando contatos do pátio ID: {}", patioId); //
        Set<ContatoResponseDto> contatos = patioService.getContatosByPatioId(patioId) //
                .stream().map(contatoMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} contatos para o pátio ID {}.", contatos.size(), patioId); //
        return ResponseEntity.ok(contatos);
    }

    // --- Endpoints de Associação de Endereços com Pátio ---
    @Operation(summary = "Associar endereço a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/enderecos/{enderecoId}/associar")
    public ResponseEntity<String> associarPatioEndereco(@PathVariable Long patioId, @PathVariable Long enderecoId) { //
        log.info("Associando endereço ID {} ao pátio ID {}.", enderecoId, patioId); //
        patioService.associarPatioEndereco(patioId, enderecoId); //
        log.info("Associação Pátio {} e Endereço {} criada.", patioId, enderecoId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar endereço de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/enderecos/{enderecoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioEndereco(@PathVariable Long patioId, @PathVariable Long enderecoId) {
        log.info("Desassociando endereço ID {} do pátio ID {}.", enderecoId, patioId); //
        patioService.desassociarPatioEndereco(patioId, enderecoId); //
        log.info("Associação Pátio {} e Endereço {} removida.", patioId, enderecoId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar endereços de um pátio") //
    @ApiResponse(responseCode = "200", description = "Endereços do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/enderecos")
    public ResponseEntity<Set<EnderecoResponseDto>> getEnderecosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando endereços do pátio ID: {}", patioId); //
        Set<EnderecoResponseDto> enderecos = patioService.getEnderecosByPatioId(patioId) //
                .stream().map(enderecoMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} endereços para o pátio ID {}.", enderecos.size(), patioId); //
        return ResponseEntity.ok(enderecos);
    }

    // --- Endpoints de Associação de Boxes com Pátio ---
    @Operation(summary = "Associar box a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/boxes/{boxId}/associar")
    public ResponseEntity<String> associarPatioBox(@PathVariable Long patioId, @PathVariable Long boxId) { //
        log.info("Associando box ID {} ao pátio ID {}.", boxId, patioId); //
        patioService.associarPatioBox(patioId, boxId); //
        log.info("Associação Pátio {} e Box {} criada.", patioId, boxId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar box de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/boxes/{boxId}/desassociar")
    public ResponseEntity<Void> desassociarPatioBox(@PathVariable Long patioId, @PathVariable Long boxId) {
        log.info("Desassociando box ID {} do pátio ID {}.", boxId, patioId); //
        patioService.desassociarPatioBox(patioId, boxId); //
        log.info("Associação Pátio {} e Box {} removida.", patioId, boxId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar boxes de um pátio") //
    @ApiResponse(responseCode = "200", description = "Boxes do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/boxes")
    public ResponseEntity<Set<BoxResponseDto>> getBoxesByPatioId(@PathVariable Long patioId) {
        log.info("Buscando boxes do pátio ID: {}", patioId); //
        Set<BoxResponseDto> boxes = patioService.getBoxesByPatioId(patioId) //
                .stream().map(boxMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} boxes para o pátio ID {}.", boxes.size(), patioId); //
        return ResponseEntity.ok(boxes);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\RadarController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: RadarController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.exception.InvalidInputException;
import br.com.fiap.mottu.service.ocr.OcrSession;
import br.com.fiap.mottu.service.ocr.OcrSession.Status;
import br.com.fiap.mottu.service.ocr.OcrSessionManager;
import br.com.fiap.mottu.service.ocr.TesseractService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/radar")
@Tag(name = "Radar", description = "Operações de OCR com Celular")
public class RadarController {

    private static final Logger log = LoggerFactory.getLogger(RadarController.class);

    private final OcrSessionManager sessionManager;
    private final TesseractService tesseractService;

    public RadarController(OcrSessionManager sessionManager, TesseractService tesseractService) {
        this.sessionManager = sessionManager;
        this.tesseractService = tesseractService;
    }

    @Operation(summary = "Iniciar Sessão de OCR")
    @PostMapping("/iniciar-sessao")
    public ResponseEntity<Map<String, String>> iniciarSessao() {
        OcrSession session = sessionManager.createSession();
        log.info("Nova sessão de OCR criada: {}", session.getId());
        return ResponseEntity.ok(Map.of("sessionId", session.getId()));
    }

    @Operation(summary = "Verificar Status da Sessão")
    @GetMapping("/status-sessao/{sessionId}")
    public ResponseEntity<OcrSession> getStatusSessao(@PathVariable String sessionId) {
        return sessionManager.getSession(sessionId)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @Operation(summary = "Upload de Imagem da Placa")
    @PostMapping(
            value = "/upload-imagem/{sessionId}",
            consumes = MediaType.MULTIPART_FORM_DATA_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public ResponseEntity<Map<String, String>> uploadImagem(
            @PathVariable String sessionId,
            @RequestPart(value = "image", required = false) MultipartFile image,
            @RequestPart(value = "file", required = false) MultipartFile file) {

        log.info("Recebida requisição de upload para a sessão: {}", sessionId);

        Optional<OcrSession> optSession = sessionManager.getSession(sessionId);
        if (optSession.isEmpty()) {
            return ResponseEntity.status(404).body(Map.of("error", "Sessão inválida ou expirada."));
        }
        OcrSession session = optSession.get();

        MultipartFile mainPart = (image != null && !image.isEmpty()) ? image : file;

        if (mainPart == null || mainPart.isEmpty()) {
            log.warn("Sessão {}: Multipart sem 'image' nem 'file', ou vazio.", sessionId);
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Arquivo ausente. Envie o campo 'image' (ou 'file') em multipart/form-data."
            ));
        }

        try {
            byte[] imageBytes = mainPart.getBytes();
            log.info("Sessão {}: Imagem lida com {} bytes.", sessionId, imageBytes.length);

            // Dispara o processamento assíncrono. O serviço agora é void e atualiza a sessão.
            tesseractService.extractPlate(sessionId, imageBytes);

            return ResponseEntity.accepted().body(Map.of("status", "Processamento da imagem iniciado."));

        } catch (IOException e) {
            log.error("Sessão {}: Falha crítica ao ler os bytes da imagem.", sessionId, e);
            sessionManager.updateSessionError(sessionId, "Erro ao ler o arquivo de imagem.");
            return ResponseEntity.status(500).body(Map.of("error", "Erro interno ao ler o arquivo enviado."));

        } catch (Throwable ex) { // Captura Exception e Error (como Invalid memory access)
            log.error("Erro inesperado no controller (sessão {}): {}", sessionId, ex.toString(), ex);
            sessionManager.updateSessionError(sessionId, "Erro interno ao processar a imagem.");
            return ResponseEntity.status(500).body(Map.of("error", "Erro interno ao processar a imagem."));
        }
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\RastreamentoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: RastreamentoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.service.RastreamentoService;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.model.Rastreamento;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/rastreamentos")
@Tag(name = "Rastreamentos", description = "Gerenciamento de Rastreamentos")
public class RastreamentoController {

    private static final Logger log = LoggerFactory.getLogger(RastreamentoController.class);
    private final RastreamentoService rastreamentoService;
    private final RastreamentoMapper rastreamentoMapper;

    @Autowired
    public RastreamentoController(RastreamentoService rastreamentoService, RastreamentoMapper rastreamentoMapper) {
        this.rastreamentoService = rastreamentoService;
        this.rastreamentoMapper = rastreamentoMapper;
    }

    @Operation(
            summary = "Listar todos os rastreamentos com paginação",
            description = "Retorna uma página de todos os rastreamentos cadastrados.",
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: dataHoraRegistro,desc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de rastreamentos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)))
            }
    )
    @GetMapping
    public ResponseEntity<Page<RastreamentoResponseDto>> listarTodosRastreamentos(
            @PageableDefault(size = 10, sort = "dataHoraRegistro") Pageable pageable) {
        log.info("Buscando todos os rastreamentos com paginação: {}", pageable);
        Page<Rastreamento> rastreamentosPage = rastreamentoService.listarTodosRastreamentos(pageable);
        Page<RastreamentoResponseDto> rastreamentosDtoPage = rastreamentosPage.map(rastreamentoMapper::toResponseDto);
        log.info("Retornando {} rastreamentos na página {} de um total de {} elementos.", rastreamentosDtoPage.getNumberOfElements(), rastreamentosDtoPage.getNumber(), rastreamentosDtoPage.getTotalElements());
        return ResponseEntity.ok(rastreamentosDtoPage);
    }

    @Operation(
            summary = "Buscar rastreamento por ID",
            description = "Retorna um rastreamento específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Rastreamento encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Rastreamento não encontrado")
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<RastreamentoResponseDto> buscarRastreamentoPorId(@PathVariable Long id) {
        log.info("Buscando rastreamento com ID: {}", id);
        RastreamentoResponseDto rastreamento = rastreamentoMapper.toResponseDto(rastreamentoService.buscarRastreamentoPorId(id));
        log.info("Rastreamento com ID {} encontrado com sucesso.", id);
        return ResponseEntity.ok(rastreamento);
    }

    @Operation(
            summary = "Buscar rastreamentos por filtro com paginação",
            description = "Retorna uma página de rastreamentos que correspondem aos critérios de filtro fornecidos.",
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string", defaultValue = "dataHoraRegistro,desc"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de rastreamentos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<Page<RastreamentoResponseDto>> buscarRastreamentosPorFiltro(
            RastreamentoFilter filter,
            @PageableDefault(size = 10, sort = "dataHoraRegistro") Pageable pageable) {
        log.info("Buscando rastreamentos com filtro: {} e paginação: {}", filter, pageable);
        Page<Rastreamento> rastreamentosPage = rastreamentoService.buscarRastreamentosPorFiltro(filter, pageable);
        Page<RastreamentoResponseDto> rastreamentosDtoPage = rastreamentosPage.map(rastreamentoMapper::toResponseDto);
        log.info("Retornando {} rastreamentos filtrados na página {} de {} elementos.", rastreamentosDtoPage.getNumberOfElements(), rastreamentosDtoPage.getNumber(), rastreamentosDtoPage.getTotalElements());
        return ResponseEntity.ok(rastreamentosDtoPage);
    }

    @Operation(
            summary = "Criar novo rastreamento",
            description = "Cria um novo rastreamento com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Rastreamento criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos (coordenadas ausentes)")
            }
    )
    @PostMapping
    public ResponseEntity<RastreamentoResponseDto> criarRastreamento(@Valid @RequestBody RastreamentoRequestDto rastreamentoRequestDto) {
        log.info("Recebida requisição para criar rastreamento: {}", rastreamentoRequestDto);
        RastreamentoResponseDto novoRastreamento = rastreamentoMapper.toResponseDto(rastreamentoService.criarRastreamento(rastreamentoRequestDto));
        log.info("Rastreamento criado com sucesso com ID: {}", novoRastreamento.getIdRastreamento());
        return ResponseEntity.status(HttpStatus.CREATED).body(novoRastreamento);
    }

    @Operation(
            summary = "Atualizar rastreamento existente",
            description = "Atualiza um rastreamento existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Rastreamento atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<RastreamentoResponseDto> atualizarRastreamento(@PathVariable Long id, @Valid @RequestBody RastreamentoRequestDto rastreamentoRequestDto) {
        log.info("Recebida requisição para atualizar rastreamento com ID {}: {}", id, rastreamentoRequestDto);
        RastreamentoResponseDto rastreamentoAtualizado = rastreamentoMapper.toResponseDto(rastreamentoService.atualizarRastreamento(id, rastreamentoRequestDto));
        log.info("Rastreamento com ID {} atualizado com sucesso.", id);
        return ResponseEntity.ok(rastreamentoAtualizado);
    }

    @Operation(
            summary = "Deletar rastreamento",
            description = "Exclui um rastreamento com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Rastreamento deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Rastreamento não encontrado")
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarRastreamento(@PathVariable Long id) {
        log.info("Recebida requisição para deletar rastreamento com ID: {}", id);
        rastreamentoService.deletarRastreamento(id);
        log.info("Rastreamento com ID {} deletado com sucesso.", id);
        return ResponseEntity.noContent().build();
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\VeiculoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: VeiculoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto; // DTO para entrada de dados de Veículo
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // DTO para saída de dados de Veículo
import br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto; // DTO para resposta de localização de Veículo
import br.com.fiap.mottu.filter.VeiculoFilter; // Filtros para busca de Veículos
import br.com.fiap.mottu.service.VeiculoService; // Serviço com a lógica de negócio para Veículos
import br.com.fiap.mottu.mapper.VeiculoMapper; // Mapper para converter entre Entidade e DTOs de Veículo
import br.com.fiap.mottu.model.Veiculo; // Entidade Veiculo
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada

@RestController
@RequestMapping("/api/veiculos")
@Tag(name = "Veiculos", description = "Gerenciamento de Veículos, incluindo Rastreamento e Localização")
public class VeiculoController {

    private static final Logger log = LoggerFactory.getLogger(VeiculoController.class);
    private final VeiculoService veiculoService;
    private final VeiculoMapper veiculoMapper;
    private final VeiculoRepository veiculoRepository; // Injetado para o novo endpoint

    @Autowired
    public VeiculoController(VeiculoService veiculoService, VeiculoMapper veiculoMapper, VeiculoRepository veiculoRepository) {
        this.veiculoService = veiculoService;
        this.veiculoMapper = veiculoMapper;
        this.veiculoRepository = veiculoRepository;
    }

    @Operation(
            summary = "Listar todos os veículos com paginação",
            description = "Retorna uma página de todos os veículos cadastrados.",
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "20")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: placa,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de veículos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)))
            }
    )
    @GetMapping
    public ResponseEntity<Page<VeiculoResponseDto>> listarTodosVeiculos(
            @PageableDefault(size = 10, sort = "placa") Pageable pageable) {
        log.info("Buscando todos os veículos com paginação: {}", pageable);
        Page<Veiculo> veiculosPage = veiculoService.listarTodosVeiculos(pageable);
        Page<VeiculoResponseDto> veiculosDtoPage = veiculosPage.map(veiculoMapper::toResponseDto);
        log.info("Retornando {} veículos na página {} de um total de {} elementos.", veiculosDtoPage.getNumberOfElements(), veiculosDtoPage.getNumber(), veiculosDtoPage.getTotalElements());
        return ResponseEntity.ok(veiculosDtoPage);
    }

    @Operation(
            summary = "Buscar veículo por ID",
            description = "Retorna um veículo específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículo encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Veículo com ID 1 não encontrado(a).\",\"path\":\"/api/veiculos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<VeiculoResponseDto> buscarVeiculoPorId(@PathVariable Long id) {
        log.info("Buscando veículo com ID: {}", id);
        VeiculoResponseDto veiculo = veiculoMapper.toResponseDto(veiculoService.buscarVeiculoPorId(id));
        log.info("Veículo com ID {} encontrado com sucesso.", id);
        return ResponseEntity.ok(veiculo);
    }

    @Operation(
            summary = "Buscar veículos por filtro com paginação",
            description = "Retorna uma página de veículos que correspondem aos critérios de filtro fornecidos.",
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de veículos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<Page<VeiculoResponseDto>> buscarVeiculosPorFiltro(
            VeiculoFilter filter,
            @PageableDefault(size = 10) Pageable pageable) {
        log.info("Buscando veículos com filtro: {} e paginação: {}", filter, pageable);
        Page<Veiculo> veiculosPage = veiculoService.buscarVeiculosPorFiltro(filter, pageable);
        Page<VeiculoResponseDto> veiculosDtoPage = veiculosPage.map(veiculoMapper::toResponseDto);
        log.info("Retornando {} veículos filtrados na página {} de {} elementos.", veiculosDtoPage.getNumberOfElements(), veiculosDtoPage.getNumber(), veiculosDtoPage.getTotalElements());
        return ResponseEntity.ok(veiculosDtoPage);
    }

    @Operation(
            summary = "Criar novo veículo",
            description = "Cria um novo veículo com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Veículo criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/veiculos\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (placa, RENAVAM ou chassi duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Veículo com placa 'ABC1234' já existe.\",\"path\":\"/api/veiculos\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<VeiculoResponseDto> criarVeiculo(@Valid @RequestBody VeiculoRequestDto veiculoRequestDto) {
        log.info("Recebida requisição para criar veículo: {}", veiculoRequestDto);
        VeiculoResponseDto novoVeiculo = veiculoMapper.toResponseDto(veiculoService.criarVeiculo(veiculoRequestDto));
        log.info("Veículo criado com sucesso com ID: {}", novoVeiculo.getIdVeiculo());
        return ResponseEntity.status(HttpStatus.CREATED).body(novoVeiculo);
    }

    @Operation(
            summary = "Atualizar veículo existente",
            description = "Atualiza um veículo existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículo atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado"),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (placa, RENAVAM ou chassi duplicado)")
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<VeiculoResponseDto> atualizarVeiculo(@PathVariable Long id, @Valid @RequestBody VeiculoRequestDto veiculoRequestDto) {
        log.info("Recebida requisição para atualizar veículo com ID {}: {}", id, veiculoRequestDto);
        VeiculoResponseDto veiculoAtualizado = veiculoMapper.toResponseDto(veiculoService.atualizarVeiculo(id, veiculoRequestDto));
        log.info("Veículo com ID {} atualizado com sucesso.", id);
        return ResponseEntity.ok(veiculoAtualizado);
    }

    @Operation(
            summary = "Deletar veículo",
            description = "Exclui um veículo com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Veículo deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado")
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarVeiculo(@PathVariable Long id) {
        log.info("Recebida requisição para deletar veículo com ID: {}", id);
        veiculoService.deletarVeiculo(id);
        log.info("Veículo com ID {} deletado com sucesso.", id);
        return ResponseEntity.noContent().build();
    }

    @Operation(
            summary = "Obter localização de um veículo por ID",
            description = "Retorna o último ponto de rastreamento de um veículo e suas associações atuais com Pátio, Zona e Box.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Localização do veículo retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoLocalizacaoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado")
            }
    )
    @GetMapping("/{id}/localizacao")
    public ResponseEntity<VeiculoLocalizacaoResponseDto> getLocalizacaoVeiculo(@PathVariable Long id) {
        log.info("Buscando localização para o veículo com ID: {}", id);
        VeiculoLocalizacaoResponseDto localizacao = veiculoService.getLocalizacaoVeiculo(id);
        log.info("Localização do veículo com ID {} encontrada com sucesso.", id);
        return ResponseEntity.ok(localizacao);
    }

    // NOVO ENDPOINT
    @Operation(
            summary = "Obter localização de um veículo por PLACA",
            description = "Busca um veículo pela placa e retorna seu último ponto de rastreamento e associações atuais.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Localização do veículo retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoLocalizacaoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo com a placa fornecida não encontrado")
            }
    )
    @GetMapping("/localizacao-por-placa")
    public ResponseEntity<VeiculoLocalizacaoResponseDto> getLocalizacaoPorPlaca(@RequestParam String placa) {
        log.info("Buscando localização para o veículo com PLACA: {}", placa);
        Veiculo veiculo = veiculoRepository.findByPlaca(placa)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", "placa", placa));
        VeiculoLocalizacaoResponseDto localizacao = veiculoService.getLocalizacaoVeiculo(veiculo.getIdVeiculo());
        log.info("Localização do veículo com PLACA {} encontrada com sucesso.", placa);
        return ResponseEntity.ok(localizacao);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\ZonaController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: ZonaController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto; // DTO para entrada de dados de Zona
import br.com.fiap.mottu.dto.zona.ZonaResponseDto; // DTO para saída de dados de Zona
import br.com.fiap.mottu.filter.ZonaFilter; // Filtros para busca de Zonas
import br.com.fiap.mottu.service.ZonaService; // Serviço com a lógica de negócio para Zonas
import br.com.fiap.mottu.mapper.ZonaMapper; // Mapper para converter entre Entidade e DTOs de Zona
import br.com.fiap.mottu.model.Zona; // Entidade Zona
// Exceções são tratadas pelo GlobalExceptionHandler
// import br.com.fiap.mottu.exception.DuplicatedResourceException;
// import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada

// import java.util.List; // Não mais usado para listagem principal
// import java.util.stream.Collectors; // Não mais usado para mapear lista manualmente

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/zonas") // Mapeia todas as requisições que começam com /api/zonas para este controller
@Tag(name = "Zonas", description = "Gerenciamento de Zonas") // Tag do Swagger
public class ZonaController {

    private static final Logger log = LoggerFactory.getLogger(ZonaController.class); // Logger para esta classe
    private final ZonaService zonaService; // Injeção do serviço de Zona
    private final ZonaMapper zonaMapper; // Injeção do mapper de Zona

    @Autowired // Construtor para injeção de dependências
    public ZonaController(ZonaService zonaService, ZonaMapper zonaMapper) {
        this.zonaService = zonaService; //
        this.zonaMapper = zonaMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todas as zonas com paginação",
            description = "Retorna uma página de todas as zonas cadastradas.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: nome,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de zonas retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/zonas
    public ResponseEntity<Page<ZonaResponseDto>> listarTodasZonas(
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todas as zonas com paginação: {}", pageable); //
        Page<Zona> zonasPage = zonaService.listarTodasZonas(pageable); // Chama o serviço
        Page<ZonaResponseDto> zonasDtoPage = zonasPage.map(zonaMapper::toResponseDto); // Mapeia Page de Entidade para Page de DTO
        log.info("Retornando {} zonas na página {} de um total de {} elementos.", zonasDtoPage.getNumberOfElements(), zonasDtoPage.getNumber(), zonasDtoPage.getTotalElements());
        return ResponseEntity.ok(zonasDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Buscar zona por ID", //
            description = "Retorna uma zona específica com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zona encontrada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Zona não encontrada") // Tratado pelo GlobalExceptionHandler
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/zonas/{id}
    public ResponseEntity<ZonaResponseDto> buscarZonaPorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando zona com ID: {}", id); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        ZonaResponseDto zona = zonaMapper.toResponseDto(zonaService.buscarZonaPorId(id)); //
        log.info("Zona com ID {} encontrada com sucesso.", id); //
        return ResponseEntity.ok(zona); // Retorna o DTO da zona
    }

    @Operation(
            summary = "Buscar zonas por filtro com paginação", //
            description = "Retorna uma página de zonas que correspondem aos critérios de filtro fornecidos.", //
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de zonas filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/zonas/search
    public ResponseEntity<Page<ZonaResponseDto>> buscarZonasPorFiltro(
            ZonaFilter filter, // Filtros injetados automaticamente
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // Paginação
        log.info("Buscando zonas com filtro: {} e paginação: {}", filter, pageable); //
        Page<Zona> zonasPage = zonaService.buscarZonasPorFiltro(filter, pageable); // Chama o serviço
        Page<ZonaResponseDto> zonasDtoPage = zonasPage.map(zonaMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} zonas filtradas na página {} de {} elementos.", zonasDtoPage.getNumberOfElements(), zonasDtoPage.getNumber(), zonasDtoPage.getTotalElements());
        return ResponseEntity.ok(zonasDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar nova zona", //
            description = "Cria uma nova zona com os dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Zona criada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))), //
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"), // Tratado pelo GlobalExceptionHandler (Bean Validation)
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)") // Tratado pelo GlobalExceptionHandler
            }
    )
    @PostMapping // Mapeia requisições POST para /api/zonas
    public ResponseEntity<ZonaResponseDto> criarZona(@Valid @RequestBody ZonaRequestDto zonaRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar zona: {}", zonaRequestDto); //
        // DuplicatedResourceException é tratada pelo GlobalExceptionHandler
        ZonaResponseDto novaZona = zonaMapper.toResponseDto(zonaService.criarZona(zonaRequestDto)); //
        log.info("Zona criada com sucesso com ID: {}", novaZona.getIdZona()); //
        return ResponseEntity.status(HttpStatus.CREATED).body(novaZona); // Retorna 201 CREATED com o DTO da nova zona
    }

    @Operation(
            summary = "Atualizar zona existente", //
            description = "Atualiza uma zona existente com base no ID e nos dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zona atualizada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))), //
                    // 400, 404, 409 são tratados pelo GlobalExceptionHandler
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/zonas/{id}
    public ResponseEntity<ZonaResponseDto> atualizarZona(@PathVariable Long id, @Valid @RequestBody ZonaRequestDto zonaRequestDto) { //
        log.info("Recebida requisição para atualizar zona com ID {}: {}", id, zonaRequestDto); //
        // ResourceNotFoundException e DuplicatedResourceException são tratadas pelo GlobalExceptionHandler
        ZonaResponseDto zonaAtualizada = zonaMapper.toResponseDto(zonaService.atualizarZona(id, zonaRequestDto)); //
        log.info("Zona com ID {} atualizada com sucesso.", id); //
        return ResponseEntity.ok(zonaAtualizada); // Retorna 200 OK com o DTO da zona atualizada
    }

    @Operation(
            summary = "Deletar zona", //
            description = "Exclui uma zona com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Zona deletada com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Zona não encontrada") // Tratado pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/zonas/{id}
    public ResponseEntity<Void> deletarZona(@PathVariable Long id) {
        log.info("Recebida requisição para deletar zona com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        zonaService.deletarZona(id); //
        log.info("Zona com ID {} deletada com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\BoxController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: BoxController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.box.BoxRequestDto; // DTO para entrada de dados de Box
import br.com.fiap.mottu.dto.box.BoxResponseDto; // DTO para saída de dados de Box
import br.com.fiap.mottu.filter.BoxFilter; // Filtros para busca de Boxes
import br.com.fiap.mottu.service.BoxService; // Serviço com a lógica de negócio para Boxes
import br.com.fiap.mottu.mapper.BoxMapper; // Mapper para converter entre Entidade e DTOs de Box
import br.com.fiap.mottu.model.Box; // Entidade Box
// Exceções são tratadas pelo GlobalExceptionHandler
// import br.com.fiap.mottu.exception.DuplicatedResourceException;
// import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada

// import java.util.List; // Não mais usado para listagem principal
// import java.util.stream.Collectors; // Não mais usado para mapear lista manualmente

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/boxes") // Mapeia todas as requisições que começam com /api/boxes para este controller
@Tag(name = "Boxes", description = "Gerenciamento de Boxes") // Tag do Swagger
public class BoxController {

    private static final Logger log = LoggerFactory.getLogger(BoxController.class); // Logger para esta classe
    private final BoxService boxService; // Injeção do serviço de Box
    private final BoxMapper boxMapper; // Injeção do mapper de Box

    @Autowired // Construtor para injeção de dependências
    public BoxController(BoxService boxService, BoxMapper boxMapper) {
        this.boxService = boxService; //
        this.boxMapper = boxMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todos os boxes com paginação",
            description = "Retorna uma página de todos os boxes cadastrados.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: nome,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de boxes retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/boxes
    public ResponseEntity<Page<BoxResponseDto>> listarTodosBoxes(
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todos os boxes com paginação: {}", pageable); //
        Page<Box> boxesPage = boxService.listarTodosBoxes(pageable); // Chama o serviço para obter a página de entidades
        Page<BoxResponseDto> boxesDtoPage = boxesPage.map(boxMapper::toResponseDto); // Mapeia a Page de Entidades para Page de DTOs
        log.info("Retornando {} boxes na página {} de um total de {} elementos.", boxesDtoPage.getNumberOfElements(), boxesDtoPage.getNumber(), boxesDtoPage.getTotalElements());
        return ResponseEntity.ok(boxesDtoPage); // Retorna a página de DTOs com status 200 OK
    }

    @Operation(
            summary = "Buscar box por ID", //
            description = "Retorna um box específico com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Box encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Box não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Box com ID 1 não encontrado(a).\",\"path\":\"/api/boxes/1\"}"))) //
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/boxes/{id}
    public ResponseEntity<BoxResponseDto> buscarBoxPorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando box com ID: {}", id); //
        // A exceção ResourceNotFoundException será lançada pelo serviço e tratada pelo GlobalExceptionHandler
        BoxResponseDto box = boxMapper.toResponseDto(boxService.buscarBoxPorId(id)); //
        log.info("Box com ID {} encontrado com sucesso.", id); //
        return ResponseEntity.ok(box); // Retorna o DTO do box com status 200 OK
    }

    @Operation(
            summary = "Buscar boxes por filtro com paginação", //
            description = "Retorna uma lista de boxes que correspondem aos critérios de filtro fornecidos.", //
            parameters = { // Documentação dos parâmetros de paginação e filtro
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de boxes filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/boxes/search
    public ResponseEntity<Page<BoxResponseDto>> buscarBoxesPorFiltro(
            BoxFilter filter, // Os parâmetros do filtro são injetados automaticamente
            @PageableDefault(size = 10) Pageable pageable) { // Parâmetros de paginação
        log.info("Buscando boxes com filtro: {} e paginação: {}", filter, pageable); //
        Page<Box> boxesPage = boxService.buscarBoxesPorFiltro(filter, pageable); // Chama o serviço
        Page<BoxResponseDto> boxesDtoPage = boxesPage.map(boxMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} boxes filtrados na página {} de {} elementos.", boxesDtoPage.getNumberOfElements(), boxesDtoPage.getNumber(), boxesDtoPage.getTotalElements());
        return ResponseEntity.ok(boxesDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar novo box", //
            description = "Cria um novo box com os dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Box criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))), //
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/boxes\"}"))), //
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Box com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/boxes\"}"))) //
            }
    )
    @PostMapping // Mapeia requisições POST para /api/boxes
    public ResponseEntity<BoxResponseDto> criarBox(@Valid @RequestBody BoxRequestDto boxRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar box: {}", boxRequestDto); //
        // DuplicatedResourceException será tratada pelo GlobalExceptionHandler
        BoxResponseDto novoBox = boxMapper.toResponseDto(boxService.criarBox(boxRequestDto)); //
        log.info("Box criado com sucesso com ID: {}", novoBox.getIdBox()); //
        return ResponseEntity.status(HttpStatus.CREATED).body(novoBox); // Retorna 201 CREATED com o DTO do novo box
    }

    @Operation(
            summary = "Atualizar box existente", //
            description = "Atualiza um box existente com base no ID e nos dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Box atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))), //
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/boxes/1\"}"))), //
                    @ApiResponse(responseCode = "404", description = "Box não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Box com ID 1 não encontrado(a).\",\"path\":\"/api/boxes/1\"}"))), //
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Box com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/boxes/1\"}"))) //
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/boxes/{id}
    public ResponseEntity<BoxResponseDto> atualizarBox(@PathVariable Long id, @Valid @RequestBody BoxRequestDto boxRequestDto) { //
        log.info("Recebida requisição para atualizar box com ID {}: {}", id, boxRequestDto); //
        // ResourceNotFoundException e DuplicatedResourceException serão tratadas pelo GlobalExceptionHandler
        BoxResponseDto boxAtualizado = boxMapper.toResponseDto(boxService.atualizarBox(id, boxRequestDto)); //
        log.info("Box com ID {} atualizado com sucesso.", id); //
        return ResponseEntity.ok(boxAtualizado); // Retorna 200 OK com o DTO do box atualizado
    }

    @Operation(
            summary = "Deletar box", //
            description = "Exclui um box com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Box deletado com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Box não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Box com ID 1 não encontrado(a).\",\"path\":\"/api/boxes/1\"}"))) //
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/boxes/{id}
    public ResponseEntity<Void> deletarBox(@PathVariable Long id) {
        log.info("Recebida requisição para deletar box com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        boxService.deletarBox(id); //
        log.info("Box com ID {} deletado com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\ClienteController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: ClienteController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto; // DTO para entrada de dados de Cliente
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto; // DTO para saída de dados de Cliente
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // DTO para saída de dados de Veículo
import br.com.fiap.mottu.filter.ClienteFilter; // Filtros para busca de Clientes
import br.com.fiap.mottu.service.ClienteService; // Serviço com a lógica de negócio para Clientes
import br.com.fiap.mottu.mapper.ClienteMapper; // Mapper para converter entre Entidade e DTOs de Cliente
import br.com.fiap.mottu.mapper.VeiculoMapper; // Mapper para Veículo
import br.com.fiap.mottu.model.Cliente; // Entidade Cliente
import br.com.fiap.mottu.model.Veiculo; // Entidade Veículo
// Exceções customizadas são tratadas pelo GlobalExceptionHandler
import br.com.fiap.mottu.exception.DuplicatedResourceException; //
import br.com.fiap.mottu.exception.ResourceNotFoundException; //
import br.com.fiap.mottu.exception.InvalidInputException; //

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado


import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada
import org.springframework.web.server.ResponseStatusException;
import reactor.core.publisher.Mono; // Para programação reativa

import java.util.Set; // Para coleções de Veiculos
import java.util.stream.Collectors; // Para coletar resultados de streams

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/clientes") // Mapeia todas as requisições que começam com /api/clientes para este controller
@Tag(name = "Clientes", description = "Gerenciamento de Clientes") // Tag do Swagger
public class ClienteController {

    private static final Logger log = LoggerFactory.getLogger(ClienteController.class); // Logger para esta classe
    private final ClienteService clienteService; // Injeção do serviço de Cliente
    private final ClienteMapper clienteMapper; // Injeção do mapper de Cliente
    private final VeiculoMapper veiculoMapper; // Injeção do mapper de Veículo

    @Autowired // Construtor para injeção de dependências
    public ClienteController(ClienteService clienteService, ClienteMapper clienteMapper, VeiculoMapper veiculoMapper) {
        this.clienteService = clienteService; //
        this.clienteMapper = clienteMapper; //
        this.veiculoMapper = veiculoMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todos os clientes com paginação",
            description = "Retorna uma página de todos os clientes cadastrados.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: nome,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de clientes retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/clientes
    public ResponseEntity<Page<ClienteResponseDto>> listarTodosClientes(
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todos os clientes com paginação: {}", pageable); //
        Page<Cliente> clientesPage = clienteService.listarTodosClientes(pageable); // Chama o serviço
        Page<ClienteResponseDto> clientesDtoPage = clientesPage.map(clienteMapper::toResponseDto); // Mapeia Page de Entidade para Page de DTO
        log.info("Retornando {} clientes na página {} de um total de {} elementos.", clientesDtoPage.getNumberOfElements(), clientesDtoPage.getNumber(), clientesDtoPage.getTotalElements());
        return ResponseEntity.ok(clientesDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Buscar cliente por ID", //
            description = "Retorna um cliente específico com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Cliente encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Cliente não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Cliente com ID 1 não encontrado(a).\",\"path\":\"/api/clientes/1\"}"))) //
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/clientes/{id}
    public ResponseEntity<ClienteResponseDto> buscarClientePorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando cliente com ID: {}", id); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        ClienteResponseDto cliente = clienteMapper.toResponseDto(clienteService.buscarClientePorId(id)); //
        log.info("Cliente com ID {} encontrado com sucesso.", id); //
        return ResponseEntity.ok(cliente); // Retorna o DTO do cliente
    }

    @Operation(
            summary = "Buscar clientes por filtro com paginação", //
            description = "Retorna uma página de clientes que correspondem aos critérios de filtro fornecidos.", //
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
                    // Adicionar documentação dos filtros de ClienteFilter se desejado
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de clientes filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/clientes/search
    public ResponseEntity<Page<ClienteResponseDto>> buscarClientesPorFiltro(
            ClienteFilter filter, // Filtros injetados automaticamente
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // Paginação
        log.info("Buscando clientes com filtro: {} e paginação: {}", filter, pageable); //
        Page<Cliente> clientesPage = clienteService.buscarClientesPorFiltro(filter, pageable); // Chama o serviço
        Page<ClienteResponseDto> clientesDtoPage = clientesPage.map(clienteMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} clientes filtrados na página {} de {} elementos.", clientesDtoPage.getNumberOfElements(), clientesDtoPage.getNumber(), clientesDtoPage.getTotalElements());
        return ResponseEntity.ok(clientesDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar novo cliente", //
            description = "Cria um novo cliente com os dados fornecidos, incluindo endereço e contato. Pode criar novos ou associar existentes.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))), //
                    // Outras respostas (400, 404, 409) são tratadas pelo GlobalExceptionHandler com base nas exceções lançadas pelo serviço
            }
    )
    @PostMapping // Mapeia requisições POST para /api/clientes
    public Mono<ResponseEntity<ClienteResponseDto>> criarCliente(@Valid @RequestBody ClienteRequestDto clienteRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar cliente: {}", clienteRequestDto); //
        return clienteService.criarCliente(clienteRequestDto) // Chama o serviço (reativo)
                .map(clienteCriado -> {
                    log.info("Cliente criado com sucesso com ID: {}", clienteCriado.getIdCliente()); //
                    return ResponseEntity.status(HttpStatus.CREATED).body(clienteMapper.toResponseDto(clienteCriado)); //
                })
                // O tratamento de erro reativo no serviço já prepara as exceções para o GlobalExceptionHandler
                // ou retorna Mono.error(excecaoCustomizada)
                .onErrorResume(e -> { // Este onErrorResume é um fallback geral no controller caso o serviço não trate todas as exceções reativamente para o GlobalExceptionHandler
                    if (e instanceof ResourceNotFoundException || e instanceof DuplicatedResourceException || e instanceof InvalidInputException) {
                        // Deixa o GlobalExceptionHandler lidar com essas exceções customizadas específicas
                        return Mono.error(e); //
                    }
                    log.error("Erro inesperado no controller ao criar cliente: {}", e.getMessage(), e); //
                    // Para outras exceções não tratadas explicitamente, pode-se retornar um erro genérico 500 ou uma exceção que o GlobalExceptionHandler pegue
                    return Mono.error(new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro inesperado ao processar a requisição.", e));
                });
    }

    @Operation(
            summary = "Atualizar cliente existente", //
            description = "Atualiza um cliente existente com base no ID e nos dados fornecidos. Permite atualizar endereço e contato.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Cliente atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))), //
                    // Outras respostas (400, 404, 409) são tratadas pelo GlobalExceptionHandler
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/clientes/{id}
    public Mono<ResponseEntity<ClienteResponseDto>> atualizarCliente(@PathVariable Long id, @Valid @RequestBody ClienteRequestDto clienteRequestDto) {
        log.info("Recebida requisição para atualizar cliente com ID {}: {}", id, clienteRequestDto); //
        return clienteService.atualizarCliente(id, clienteRequestDto) // Chama o serviço (reativo)
                .map(clienteAtualizado -> {
                    log.info("Cliente com ID {} atualizado com sucesso.", id); //
                    return ResponseEntity.ok(clienteMapper.toResponseDto(clienteAtualizado)); //
                })
                .onErrorResume(e -> { // Fallback no controller
                    if (e instanceof ResourceNotFoundException || e instanceof DuplicatedResourceException || e instanceof InvalidInputException) {
                        return Mono.error(e); //
                    }
                    log.error("Erro inesperado no controller ao atualizar cliente com ID {}: {}", id, e.getMessage(), e); //
                    return Mono.error(new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro inesperado ao processar a requisição.", e));
                });
    }

    @Operation(
            summary = "Deletar cliente", //
            description = "Exclui um cliente com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Cliente deletado com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Cliente não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/clientes/{id}
    public ResponseEntity<Void> deletarCliente(@PathVariable Long id) {
        log.info("Recebida requisição para deletar cliente com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        clienteService.deletarCliente(id); //
        log.info("Cliente com ID {} deletado com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }

    @Operation(
            summary = "Associar veículo a um cliente", //
            description = "Associa um veículo existente a um cliente existente. Requer os IDs do cliente, seu endereço e contato atuais, e o ID do veículo.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Associação criada com sucesso", content = @Content(schema = @Schema(type="string"))), //
                    // 404 (Cliente, Veículo, Endereço ou Contato não encontrado) e 409 (Associação já existe) são tratados pelo GlobalExceptionHandler
            }
    )
    @PostMapping("/{clienteId}/enderecos/{enderecoId}/contatos/{contatoId}/veiculos/{veiculoId}/associar")
    public ResponseEntity<String> associarClienteVeiculo(
            @PathVariable Long clienteId,
            @PathVariable Long enderecoId, // ID do endereço ATUALMENTE associado ao cliente
            @PathVariable Long contatoId,  // ID do contato ATUALMENTE associado ao cliente
            @PathVariable Long veiculoId) {
        log.info("Associando veículo ID {} ao cliente ID {} (com Endereco ID: {}, Contato ID: {}).", veiculoId, clienteId, enderecoId, contatoId); //
        // Exceções são tratadas pelo GlobalExceptionHandler
        clienteService.associarClienteVeiculo(clienteId, enderecoId, contatoId, veiculoId); //
        log.info("Associação entre Cliente {}, Endereco {}, Contato {} e Veículo {} criada com sucesso.", clienteId, enderecoId, contatoId, veiculoId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(
            summary = "Desassociar veículo de um cliente", //
            description = "Remove a associação entre um veículo e um cliente. Requer os IDs do cliente, seu endereço e contato atuais, e o ID do veículo.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"), //
                    // 404 (Associação não encontrada) é tratada pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{clienteId}/enderecos/{enderecoId}/contatos/{contatoId}/veiculos/{veiculoId}/desassociar")
    public ResponseEntity<Void> desassociarClienteVeiculo(
            @PathVariable Long clienteId,
            @PathVariable Long enderecoId, // ID do endereço usado na chave da associação
            @PathVariable Long contatoId,  // ID do contato usado na chave da associação
            @PathVariable Long veiculoId) { //
        log.info("Desassociando veículo ID {} do cliente ID {} (com Endereco ID: {}, Contato ID: {}).", veiculoId, clienteId, enderecoId, contatoId); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        clienteService.desassociarClienteVeiculo(clienteId, enderecoId, contatoId, veiculoId); //
        log.info("Associação entre Cliente {}, Endereco {}, Contato {} e Veículo {} removida com sucesso.", clienteId, enderecoId, contatoId, veiculoId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(
            summary = "Listar veículos de um cliente", //
            description = "Retorna todos os veículos associados a um cliente específico.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículos do cliente retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))), // O Swagger pode mostrar um array aqui.
                    @ApiResponse(responseCode = "404", description = "Cliente não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @GetMapping("/{clienteId}/veiculos") // Mapeia GET para /api/clientes/{clienteId}/veiculos
    public ResponseEntity<Set<VeiculoResponseDto>> getVeiculosByClienteId(@PathVariable Long clienteId) {
        log.info("Buscando veículos associados ao cliente com ID: {}", clienteId); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        Set<Veiculo> veiculos = clienteService.getVeiculosByClienteId(clienteId); //
        Set<VeiculoResponseDto> veiculosDto = veiculos.stream()
                .map(veiculoMapper::toResponseDto) // Mapeia cada veículo para seu DTO
                .collect(Collectors.toSet()); //
        log.info("Retornando {} veículos para o cliente com ID {}.", veiculosDto.size(), clienteId); //
        return ResponseEntity.ok(veiculosDto); // Retorna o conjunto de DTOs de veículos
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\ContatoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: ContatoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto; // DTO para entrada de dados de Contato
import br.com.fiap.mottu.dto.contato.ContatoResponseDto; // DTO para saída de dados de Contato
import br.com.fiap.mottu.filter.ContatoFilter; // Filtros para busca de Contatos
import br.com.fiap.mottu.service.ContatoService; // Serviço com a lógica de negócio para Contatos
import br.com.fiap.mottu.mapper.ContatoMapper; // Mapper para converter entre Entidade e DTOs de Contato
import br.com.fiap.mottu.model.Contato; // Entidade Contato
// Exceções são tratadas pelo GlobalExceptionHandler
// import br.com.fiap.mottu.exception.DuplicatedResourceException;
// import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada

// import java.util.List; // Não mais usado para listagem principal
// import java.util.stream.Collectors; // Não mais usado para mapear lista manualmente

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/contatos") // Mapeia todas as requisições que começam com /api/contatos para este controller
@Tag(name = "Contatos", description = "Gerenciamento de Contatos") // Tag do Swagger
public class ContatoController {

    private static final Logger log = LoggerFactory.getLogger(ContatoController.class); // Logger para esta classe
    private final ContatoService contatoService; // Injeção do serviço de Contato
    private final ContatoMapper contatoMapper; // Injeção do mapper de Contato

    @Autowired // Construtor para injeção de dependências
    public ContatoController(ContatoService contatoService, ContatoMapper contatoMapper) {
        this.contatoService = contatoService; //
        this.contatoMapper = contatoMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todos os contatos com paginação",
            description = "Retorna uma página de todos os contatos cadastrados.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: email,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de contatos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/contatos
    public ResponseEntity<Page<ContatoResponseDto>> listarTodosContatos(
            @PageableDefault(size = 10, sort = "email") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todos os contatos com paginação: {}", pageable); //
        Page<Contato> contatosPage = contatoService.listarTodosContatos(pageable); // Chama o serviço
        Page<ContatoResponseDto> contatosDtoPage = contatosPage.map(contatoMapper::toResponseDto); // Mapeia Page de Entidade para Page de DTO
        log.info("Retornando {} contatos na página {} de um total de {} elementos.", contatosDtoPage.getNumberOfElements(), contatosDtoPage.getNumber(), contatosDtoPage.getTotalElements());
        return ResponseEntity.ok(contatosDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Buscar contato por ID", //
            description = "Retorna um contato específico com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contato encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Contato não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Contato com ID 1 não encontrado(a).\",\"path\":\"/api/contatos/1\"}"))) //
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/contatos/{id}
    public ResponseEntity<ContatoResponseDto> buscarContatoPorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando contato com ID: {}", id); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        ContatoResponseDto contato = contatoMapper.toResponseDto(contatoService.buscarContatoPorId(id)); //
        log.info("Contato com ID {} encontrado com sucesso.", id); //
        return ResponseEntity.ok(contato); // Retorna o DTO do contato
    }

    @Operation(
            summary = "Buscar contatos por filtro com paginação", //
            description = "Retorna uma página de contatos que correspondem aos critérios de filtro fornecidos.", //
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de contatos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/contatos/search
    public ResponseEntity<Page<ContatoResponseDto>> buscarContatosPorFiltro(
            ContatoFilter filter, // Filtros injetados automaticamente
            @PageableDefault(size = 10, sort = "email") Pageable pageable) { // Paginação
        log.info("Buscando contatos com filtro: {} e paginação: {}", filter, pageable); //
        Page<Contato> contatosPage = contatoService.buscarContatosPorFiltro(filter, pageable); // Chama o serviço
        Page<ContatoResponseDto> contatosDtoPage = contatosPage.map(contatoMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} contatos filtrados na página {} de {} elementos.", contatosDtoPage.getNumberOfElements(), contatosDtoPage.getNumber(), contatosDtoPage.getTotalElements());
        return ResponseEntity.ok(contatosDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar novo contato", //
            description = "Cria um novo contato com os dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Contato criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))), //
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"), // Tratado pelo GlobalExceptionHandler (Bean Validation)
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (email duplicado)") // Tratado pelo GlobalExceptionHandler
            }
    )
    @PostMapping // Mapeia requisições POST para /api/contatos
    public ResponseEntity<ContatoResponseDto> criarContato(@Valid @RequestBody ContatoRequestDto contatoRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar contato: {}", contatoRequestDto); //
        // DuplicatedResourceException é tratada pelo GlobalExceptionHandler
        ContatoResponseDto novoContato = contatoMapper.toResponseDto(contatoService.criarContato(contatoRequestDto)); //
        log.info("Contato criado com sucesso com ID: {}", novoContato.getIdContato()); //
        return ResponseEntity.status(HttpStatus.CREATED).body(novoContato); // Retorna 201 CREATED com o DTO do novo contato
    }

    @Operation(
            summary = "Atualizar contato existente", //
            description = "Atualiza um contato existente com base no ID e nos dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contato atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))), //
                    // 400, 404, 409 são tratados pelo GlobalExceptionHandler
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/contatos/{id}
    public ResponseEntity<ContatoResponseDto> atualizarContato(@PathVariable Long id, @Valid @RequestBody ContatoRequestDto contatoRequestDto) { //
        log.info("Recebida requisição para atualizar contato com ID {}: {}", id, contatoRequestDto); //
        // ResourceNotFoundException e DuplicatedResourceException são tratadas pelo GlobalExceptionHandler
        ContatoResponseDto contatoAtualizado = contatoMapper.toResponseDto(contatoService.atualizarContato(id, contatoRequestDto)); //
        log.info("Contato com ID {} atualizado com sucesso.", id); //
        return ResponseEntity.ok(contatoAtualizado); // Retorna 200 OK com o DTO do contato atualizado
    }

    @Operation(
            summary = "Deletar contato", //
            description = "Exclui um contato com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Contato deletado com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Contato não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/contatos/{id}
    public ResponseEntity<Void> deletarContato(@PathVariable Long id) {
        log.info("Recebida requisição para deletar contato com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        contatoService.deletarContato(id); //
        log.info("Contato com ID {} deletado com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\EnderecoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: EnderecoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto; // DTO para entrada de dados de Endereço
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto; // DTO para saída de dados de Endereço
import br.com.fiap.mottu.filter.EnderecoFilter; // Filtros para busca de Endereços
import br.com.fiap.mottu.service.EnderecoService; // Serviço com a lógica de negócio para Endereços
import br.com.fiap.mottu.mapper.EnderecoMapper; // Mapper para converter entre Entidade e DTOs de Endereço
import br.com.fiap.mottu.model.Endereco; // Entidade Endereco
// Exceções customizadas
import br.com.fiap.mottu.exception.ResourceNotFoundException; //
import br.com.fiap.mottu.exception.InvalidInputException; //


import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import org.springframework.web.server.ResponseStatusException; // Para lançar exceções HTTP específicas
import jakarta.validation.Valid; // Para validar DTOs de entrada
import reactor.core.publisher.Mono; // Para programação reativa (ViaCEP)

// import java.util.List; // Não mais usado para listagem principal
// import java.util.stream.Collectors; // Não mais usado para mapear lista manualmente

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/enderecos") // Mapeia todas as requisições que começam com /api/enderecos para este controller
@Tag(name = "Enderecos", description = "Gerenciamento de Endereços") // Tag do Swagger
public class EnderecoController {

    private static final Logger log = LoggerFactory.getLogger(EnderecoController.class); // Logger para esta classe
    private final EnderecoService enderecoService; // Injeção do serviço de Endereço
    private final EnderecoMapper enderecoMapper; // Injeção do mapper de Endereço

    @Autowired // Construtor para injeção de dependências
    public EnderecoController(EnderecoService enderecoService, EnderecoMapper enderecoMapper) {
        this.enderecoService = enderecoService; //
        this.enderecoMapper = enderecoMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todos os endereços com paginação",
            description = "Retorna uma página de todos os endereços cadastrados.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: cep,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de endereços retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/enderecos
    public ResponseEntity<Page<EnderecoResponseDto>> listarTodosEnderecos(
            @PageableDefault(size = 10, sort = "cep") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todos os endereços com paginação: {}", pageable); //
        Page<Endereco> enderecosPage = enderecoService.listarTodosEnderecos(pageable); // Chama o serviço
        Page<EnderecoResponseDto> enderecosDtoPage = enderecosPage.map(enderecoMapper::toResponseDto); // Mapeia Page de Entidade para Page de DTO
        log.info("Retornando {} endereços na página {} de um total de {} elementos.", enderecosDtoPage.getNumberOfElements(), enderecosDtoPage.getNumber(), enderecosDtoPage.getTotalElements());
        return ResponseEntity.ok(enderecosDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Buscar endereço por ID", //
            description = "Retorna um endereço específico com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Endereço encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Endereço não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/enderecos/{id}
    public ResponseEntity<EnderecoResponseDto> buscarEnderecoPorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando endereço com ID: {}", id); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        EnderecoResponseDto endereco = enderecoMapper.toResponseDto(enderecoService.buscarEnderecoPorId(id)); //
        log.info("Endereço com ID {} encontrado com sucesso.", id); //
        return ResponseEntity.ok(endereco); // Retorna o DTO do endereço
    }

    @Operation(
            summary = "Buscar endereços por filtro com paginação", //
            description = "Retorna uma página de endereços que correspondem aos critérios de filtro fornecidos.", //
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de endereços filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/enderecos/search
    public ResponseEntity<Page<EnderecoResponseDto>> buscarEnderecosPorFiltro(
            EnderecoFilter filter, // Filtros injetados automaticamente
            @PageableDefault(size = 10, sort = "cep") Pageable pageable) { // Paginação
        log.info("Buscando endereços com filtro: {} e paginação: {}", filter, pageable); //
        Page<Endereco> enderecosPage = enderecoService.buscarEnderecosPorFiltro(filter, pageable); // Chama o serviço (método adicionado no service)
        Page<EnderecoResponseDto> enderecosDtoPage = enderecosPage.map(enderecoMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} endereços filtrados na página {} de {} elementos.", enderecosDtoPage.getNumberOfElements(), enderecosDtoPage.getNumber(), enderecosDtoPage.getTotalElements());
        return ResponseEntity.ok(enderecosDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar novo endereço", //
            description = "Cria um novo endereço com os dados fornecidos, buscando informações de CEP na ViaCEP.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Endereço criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))), //
                    // 400 (CEP inválido/não fornecido) e 404 (CEP não encontrado no ViaCEP) são tratados pelo serviço/GlobalExceptionHandler
            }
    )
    @PostMapping // Mapeia requisições POST para /api/enderecos
    public Mono<ResponseEntity<EnderecoResponseDto>> criarEndereco(@Valid @RequestBody EnderecoRequestDto enderecoRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar endereço: {}", enderecoRequestDto); //
        return enderecoService.criarEndereco(enderecoRequestDto) // Chama o serviço (reativo)
                .map(enderecoCriado -> {
                    log.info("Endereço criado com sucesso com ID: {}", enderecoCriado.getIdEndereco()); //
                    return ResponseEntity.status(HttpStatus.CREATED).body(enderecoMapper.toResponseDto(enderecoCriado)); //
                })
                .onErrorResume(e -> { // Tratamento de erro reativo no controller
                    if (e instanceof ResourceNotFoundException || e instanceof InvalidInputException) {
                        return Mono.error(e); // Deixa o GlobalExceptionHandler lidar
                    }
                    log.error("Erro inesperado no controller ao criar endereço: {}", e.getMessage(), e); //
                    return Mono.error(new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro inesperado ao processar a requisição.", e));
                });
    }

    @Operation(
            summary = "Atualizar endereço existente", //
            description = "Atualiza um endereço existente com base no ID e nos dados fornecidos. Pode buscar informações de CEP na ViaCEP se o CEP for alterado.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Endereço atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))), //
                    // 400, 404 são tratados pelo serviço/GlobalExceptionHandler
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/enderecos/{id}
    public Mono<ResponseEntity<EnderecoResponseDto>> atualizarEndereco(@PathVariable Long id, @Valid @RequestBody EnderecoRequestDto enderecoRequestDto) { //
        log.info("Recebida requisição para atualizar endereço com ID {}: {}", id, enderecoRequestDto); //
        return enderecoService.atualizarEndereco(id, enderecoRequestDto) // Chama o serviço (reativo)
                .map(enderecoAtualizado -> {
                    log.info("Endereço com ID {} atualizado com sucesso.", id); //
                    return ResponseEntity.ok(enderecoMapper.toResponseDto(enderecoAtualizado)); //
                })
                .onErrorResume(e -> { // Tratamento de erro reativo no controller
                    if (e instanceof ResourceNotFoundException || e instanceof InvalidInputException) {
                        return Mono.error(e); // Deixa o GlobalExceptionHandler lidar
                    }
                    log.error("Erro inesperado no controller ao atualizar endereço com ID {}: {}", id, e.getMessage(), e); //
                    return Mono.error(new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro inesperado ao processar a requisição.", e));
                });
    }

    @Operation(
            summary = "Deletar endereço", //
            description = "Exclui um endereço com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Endereço deletado com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Endereço não encontrado") // Tratado pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/enderecos/{id}
    public ResponseEntity<Void> deletarEndereco(@PathVariable Long id) {
        log.info("Recebida requisição para deletar endereço com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        enderecoService.deletarEndereco(id); //
        log.info("Endereço com ID {} deletado com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\EstacionamentoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: EstacionamentoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/mottu/controller/EstacionamentoController.java
package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.mapper.BoxMapper;
import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.service.EstacionamentoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/estacionamento")
@Tag(name = "Estacionamento", description = "Operações de estacionar e liberar vagas")
public class EstacionamentoController {

    private final EstacionamentoService estacionamentoService;
    private final BoxMapper boxMapper;

    @Autowired
    public EstacionamentoController(EstacionamentoService estacionamentoService, BoxMapper boxMapper) {
        this.estacionamentoService = estacionamentoService;
        this.boxMapper = boxMapper;
    }

    @Operation(summary = "Armazenar Moto", description = "Encontra uma vaga livre e estaciona a moto correspondente à placa.")
    @PostMapping("/estacionar")
    public ResponseEntity<BoxResponseDto> estacionarMoto(@RequestParam String placa) {
        Box vaga = estacionamentoService.parkMoto(placa);
        return ResponseEntity.ok(boxMapper.toResponseDto(vaga));
    }

    @Operation(summary = "Liberar Vaga", description = "Libera a vaga ocupada pela moto correspondente à placa.")
    @PostMapping("/liberar")
    public ResponseEntity<Void> liberarVaga(@RequestParam String placa) {
        estacionamentoService.releaseSpot(placa);
        return ResponseEntity.noContent().build();
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\PatioController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: PatioController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

// DTOs de Requisição e Resposta
import br.com.fiap.mottu.dto.patio.PatioRequestDto; //
import br.com.fiap.mottu.dto.patio.PatioResponseDto; //
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; //
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;       //
import br.com.fiap.mottu.dto.box.BoxResponseDto;         //
import br.com.fiap.mottu.dto.contato.ContatoResponseDto; //
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto; //
// Filtro
import br.com.fiap.mottu.filter.PatioFilter; //
// Serviço e Mappers
import br.com.fiap.mottu.service.PatioService; //
import br.com.fiap.mottu.mapper.PatioMapper; //
import br.com.fiap.mottu.mapper.VeiculoMapper; //
import br.com.fiap.mottu.mapper.ZonaMapper;    //
import br.com.fiap.mottu.mapper.BoxMapper;      //
import br.com.fiap.mottu.mapper.ContatoMapper;  //
import br.com.fiap.mottu.mapper.EnderecoMapper; //
import br.com.fiap.mottu.model.Patio; // Entidade Pátio
// Exceções (tratadas globalmente)
// import br.com.fiap.mottu.exception.DuplicatedResourceException;
// import br.com.fiap.mottu.exception.ResourceNotFoundException;

// Swagger/OpenAPI
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;

// Logging
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
// Spring Framework
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus; //
import org.springframework.http.ResponseEntity; //
import org.springframework.web.bind.annotation.*;
// Validation
import jakarta.validation.Valid;

import java.util.Set; //
import java.util.stream.Collectors; //

@RestController // Controller REST
@RequestMapping("/api/patios") // Mapeamento base para este controller
@Tag(name = "Patios", description = "Gerenciamento de Pátios e Suas Associações") // Tag Swagger
public class PatioController {

    private static final Logger log = LoggerFactory.getLogger(PatioController.class); // Logger
    // Injeção de Serviços e Mappers
    private final PatioService patioService; //
    private final PatioMapper patioMapper; //
    private final VeiculoMapper veiculoMapper; //
    private final ZonaMapper zonaMapper; //
    private final BoxMapper boxMapper; //
    private final ContatoMapper contatoMapper; //
    private final EnderecoMapper enderecoMapper; //

    @Autowired // Construtor para injeção de dependências
    public PatioController(PatioService patioService, PatioMapper patioMapper,
                           VeiculoMapper veiculoMapper, ZonaMapper zonaMapper,
                           ContatoMapper contatoMapper, EnderecoMapper enderecoMapper,
                           BoxMapper boxMapper) { //
        this.patioService = patioService;
        this.patioMapper = patioMapper;
        this.veiculoMapper = veiculoMapper; //
        this.zonaMapper = zonaMapper; //
        this.boxMapper = boxMapper; //
        this.contatoMapper = contatoMapper; //
        this.enderecoMapper = enderecoMapper; //
    }

    // Operações CRUD para Pátio

    @Operation(summary = "Listar todos os pátios com paginação", description = "Retorna uma página de todos os pátios cadastrados.") //
    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0"))
    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10"))
    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string", defaultValue = "nomePatio,asc"))
    @ApiResponse(responseCode = "200", description = "Página de pátios retornada com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class))) //
    @GetMapping // Mapeia GET para /api/patios
    public ResponseEntity<Page<PatioResponseDto>> listarTodosPatios(
            @PageableDefault(size = 10, sort = "nomePatio") Pageable pageable) {
        log.info("Buscando todos os pátios com paginação: {}", pageable); //
        Page<Patio> patiosPage = patioService.listarTodosPatios(pageable); // Chama o serviço
        Page<PatioResponseDto> patiosDtoPage = patiosPage.map(patioMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} pátios na página {} de {} elementos.", patiosDtoPage.getNumberOfElements(), patiosDtoPage.getNumber(), patiosDtoPage.getTotalElements());
        return ResponseEntity.ok(patiosDtoPage); // Retorna a página
    }

    @Operation(summary = "Buscar pátio por ID", description = "Retorna um pátio específico com base no ID fornecido.") //
    @ApiResponse(responseCode = "200", description = "Pátio encontrado", content = @Content(mediaType = "application/json", schema = @Schema(implementation = PatioResponseDto.class))) //
    @ApiResponse(responseCode = "404", description = "Pátio não encontrado") // Tratado globalmente
    @GetMapping("/{id}")
    public ResponseEntity<PatioResponseDto> buscarPatioPorId(@PathVariable Long id) {
        log.info("Buscando pátio com ID: {}", id); //
        PatioResponseDto patioDto = patioMapper.toResponseDto(patioService.buscarPatioPorId(id)); //
        log.info("Pátio com ID {} encontrado.", id); //
        return ResponseEntity.ok(patioDto);
    }

    @Operation(summary = "Buscar pátios por filtro com paginação", description = "Retorna uma página de pátios que correspondem aos critérios de filtro.") //
    @Parameter(name = "page", description = "Número da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0"))
    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10"))
    @Parameter(name = "sort", description = "Ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
    @ApiResponse(responseCode = "200", description = "Página de pátios filtrada", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class))) //
    @GetMapping("/search")
    public ResponseEntity<Page<PatioResponseDto>> buscarPatiosPorFiltro(
            PatioFilter filter, @PageableDefault(size = 10) Pageable pageable) {
        log.info("Buscando pátios com filtro: {} e paginação: {}", filter, pageable); //
        Page<Patio> patiosPage = patioService.buscarPatiosPorFiltro(filter, pageable); //
        Page<PatioResponseDto> patiosDtoPage = patiosPage.map(patioMapper::toResponseDto);
        log.info("Retornando {} pátios filtrados.", patiosDtoPage.getNumberOfElements()); //
        return ResponseEntity.ok(patiosDtoPage);
    }

    @Operation(summary = "Criar novo pátio", description = "Cria um novo pátio.") //
    @ApiResponse(responseCode = "201", description = "Pátio criado", content = @Content(mediaType = "application/json", schema = @Schema(implementation = PatioResponseDto.class))) //
    @ApiResponse(responseCode = "400", description = "Dados inválidos") // Tratado globalmente (Bean Validation)
    @ApiResponse(responseCode = "409", description = "Pátio já existe") // Tratado globalmente
    @PostMapping
    public ResponseEntity<PatioResponseDto> criarPatio(@Valid @RequestBody PatioRequestDto patioRequestDto) { //
        log.info("Criando pátio: {}", patioRequestDto); //
        PatioResponseDto novoPatio = patioMapper.toResponseDto(patioService.criarPatio(patioRequestDto)); //
        log.info("Pátio criado com ID: {}", novoPatio.getIdPatio()); //
        return ResponseEntity.status(HttpStatus.CREATED).body(novoPatio); //
    }

    @Operation(summary = "Atualizar pátio existente", description = "Atualiza dados de um pátio.") //
    @ApiResponse(responseCode = "200", description = "Pátio atualizado", content = @Content(mediaType = "application/json", schema = @Schema(implementation = PatioResponseDto.class))) //
    @ApiResponse(responseCode = "404", description = "Pátio não encontrado") // Tratado globalmente
    @ApiResponse(responseCode = "409", description = "Conflito de dados (ex: nome duplicado)") // Tratado globalmente
    @PutMapping("/{id}")
    public ResponseEntity<PatioResponseDto> atualizarPatio(@PathVariable Long id, @Valid @RequestBody PatioRequestDto patioRequestDto) { //
        log.info("Atualizando pátio ID {}: {}", id, patioRequestDto); //
        PatioResponseDto patioAtualizado = patioMapper.toResponseDto(patioService.atualizarPatio(id, patioRequestDto)); //
        log.info("Pátio ID {} atualizado.", id); //
        return ResponseEntity.ok(patioAtualizado);
    }

    @Operation(summary = "Deletar pátio", description = "Exclui um pátio.") //
    @ApiResponse(responseCode = "204", description = "Pátio deletado") //
    @ApiResponse(responseCode = "404", description = "Pátio não encontrado") // Tratado globalmente
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarPatio(@PathVariable Long id) {
        log.info("Deletando pátio ID: {}", id); //
        patioService.deletarPatio(id); //
        log.info("Pátio ID {} deletado.", id); //
        return ResponseEntity.noContent().build(); //
    }

    // --- Endpoints de Associação de Veículos com Pátio ---
    @Operation(summary = "Associar veículo a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/veiculos/{veiculoId}/associar")
    public ResponseEntity<String> associarPatioVeiculo(@PathVariable Long patioId, @PathVariable Long veiculoId) { //
        log.info("Associando veículo ID {} ao pátio ID {}.", veiculoId, patioId); //
        patioService.associarPatioVeiculo(patioId, veiculoId); //
        log.info("Associação Pátio {} e Veículo {} criada.", patioId, veiculoId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar veículo de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/veiculos/{veiculoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioVeiculo(@PathVariable Long patioId, @PathVariable Long veiculoId) {
        log.info("Desassociando veículo ID {} do pátio ID {}.", veiculoId, patioId); //
        patioService.desassociarPatioVeiculo(patioId, veiculoId); //
        log.info("Associação Pátio {} e Veículo {} removida.", patioId, veiculoId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar veículos de um pátio") //
    @ApiResponse(responseCode = "200", description = "Veículos do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/veiculos")
    public ResponseEntity<Set<VeiculoResponseDto>> getVeiculosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando veículos do pátio ID: {}", patioId); //
        Set<VeiculoResponseDto> veiculos = patioService.getVeiculosByPatioId(patioId) //
                .stream().map(veiculoMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} veículos para o pátio ID {}.", veiculos.size(), patioId); //
        return ResponseEntity.ok(veiculos);
    }

    // --- Endpoints de Associação de Zonas com Pátio ---
    @Operation(summary = "Associar zona a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/zonas/{zonaId}/associar")
    public ResponseEntity<String> associarPatioZona(@PathVariable Long patioId, @PathVariable Long zonaId) { //
        log.info("Associando zona ID {} ao pátio ID {}.", zonaId, patioId); //
        patioService.associarPatioZona(patioId, zonaId); //
        log.info("Associação Pátio {} e Zona {} criada.", patioId, zonaId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar zona de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/zonas/{zonaId}/desassociar")
    public ResponseEntity<Void> desassociarPatioZona(@PathVariable Long patioId, @PathVariable Long zonaId) {
        log.info("Desassociando zona ID {} do pátio ID {}.", zonaId, patioId); //
        patioService.desassociarPatioZona(patioId, zonaId); //
        log.info("Associação Pátio {} e Zona {} removida.", patioId, zonaId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar zonas de um pátio") //
    @ApiResponse(responseCode = "200", description = "Zonas do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/zonas")
    public ResponseEntity<Set<ZonaResponseDto>> getZonasByPatioId(@PathVariable Long patioId) {
        log.info("Buscando zonas do pátio ID: {}", patioId); //
        Set<ZonaResponseDto> zonas = patioService.getZonasByPatioId(patioId) //
                .stream().map(zonaMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} zonas para o pátio ID {}.", zonas.size(), patioId); //
        return ResponseEntity.ok(zonas);
    }

    // --- Endpoints de Associação de Contatos com Pátio ---
    @Operation(summary = "Associar contato a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/contatos/{contatoId}/associar")
    public ResponseEntity<String> associarPatioContato(@PathVariable Long patioId, @PathVariable Long contatoId) { //
        log.info("Associando contato ID {} ao pátio ID {}.", contatoId, patioId); //
        patioService.associarPatioContato(patioId, contatoId); //
        log.info("Associação Pátio {} e Contato {} criada.", patioId, contatoId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar contato de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/contatos/{contatoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioContato(@PathVariable Long patioId, @PathVariable Long contatoId) {
        log.info("Desassociando contato ID {} do pátio ID {}.", contatoId, patioId); //
        patioService.desassociarPatioContato(patioId, contatoId); //
        log.info("Associação Pátio {} e Contato {} removida.", patioId, contatoId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar contatos de um pátio") //
    @ApiResponse(responseCode = "200", description = "Contatos do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/contatos")
    public ResponseEntity<Set<ContatoResponseDto>> getContatosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando contatos do pátio ID: {}", patioId); //
        Set<ContatoResponseDto> contatos = patioService.getContatosByPatioId(patioId) //
                .stream().map(contatoMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} contatos para o pátio ID {}.", contatos.size(), patioId); //
        return ResponseEntity.ok(contatos);
    }

    // --- Endpoints de Associação de Endereços com Pátio ---
    @Operation(summary = "Associar endereço a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/enderecos/{enderecoId}/associar")
    public ResponseEntity<String> associarPatioEndereco(@PathVariable Long patioId, @PathVariable Long enderecoId) { //
        log.info("Associando endereço ID {} ao pátio ID {}.", enderecoId, patioId); //
        patioService.associarPatioEndereco(patioId, enderecoId); //
        log.info("Associação Pátio {} e Endereço {} criada.", patioId, enderecoId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar endereço de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/enderecos/{enderecoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioEndereco(@PathVariable Long patioId, @PathVariable Long enderecoId) {
        log.info("Desassociando endereço ID {} do pátio ID {}.", enderecoId, patioId); //
        patioService.desassociarPatioEndereco(patioId, enderecoId); //
        log.info("Associação Pátio {} e Endereço {} removida.", patioId, enderecoId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar endereços de um pátio") //
    @ApiResponse(responseCode = "200", description = "Endereços do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/enderecos")
    public ResponseEntity<Set<EnderecoResponseDto>> getEnderecosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando endereços do pátio ID: {}", patioId); //
        Set<EnderecoResponseDto> enderecos = patioService.getEnderecosByPatioId(patioId) //
                .stream().map(enderecoMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} endereços para o pátio ID {}.", enderecos.size(), patioId); //
        return ResponseEntity.ok(enderecos);
    }

    // --- Endpoints de Associação de Boxes com Pátio ---
    @Operation(summary = "Associar box a um pátio") //
    @ApiResponse(responseCode = "201", description = "Associação criada") //
    @PostMapping("/{patioId}/boxes/{boxId}/associar")
    public ResponseEntity<String> associarPatioBox(@PathVariable Long patioId, @PathVariable Long boxId) { //
        log.info("Associando box ID {} ao pátio ID {}.", boxId, patioId); //
        patioService.associarPatioBox(patioId, boxId); //
        log.info("Associação Pátio {} e Box {} criada.", patioId, boxId); //
        return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso."); //
    }

    @Operation(summary = "Desassociar box de um pátio") //
    @ApiResponse(responseCode = "204", description = "Associação removida") //
    @DeleteMapping("/{patioId}/boxes/{boxId}/desassociar")
    public ResponseEntity<Void> desassociarPatioBox(@PathVariable Long patioId, @PathVariable Long boxId) {
        log.info("Desassociando box ID {} do pátio ID {}.", boxId, patioId); //
        patioService.desassociarPatioBox(patioId, boxId); //
        log.info("Associação Pátio {} e Box {} removida.", patioId, boxId); //
        return ResponseEntity.noContent().build(); //
    }

    @Operation(summary = "Listar boxes de um pátio") //
    @ApiResponse(responseCode = "200", description = "Boxes do pátio", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Set.class))) //
    @GetMapping("/{patioId}/boxes")
    public ResponseEntity<Set<BoxResponseDto>> getBoxesByPatioId(@PathVariable Long patioId) {
        log.info("Buscando boxes do pátio ID: {}", patioId); //
        Set<BoxResponseDto> boxes = patioService.getBoxesByPatioId(patioId) //
                .stream().map(boxMapper::toResponseDto).collect(Collectors.toSet());
        log.info("Retornando {} boxes para o pátio ID {}.", boxes.size(), patioId); //
        return ResponseEntity.ok(boxes);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\RadarController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: RadarController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.service.ocr.OcrSession;
import br.com.fiap.mottu.service.ocr.OcrSessionManager;
import br.com.fiap.mottu.service.ocr.PlateRecognizer;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/radar")
@Tag(name = "Radar", description = "Operações de OCR com Celular")
public class RadarController {

    private static final Logger log = LoggerFactory.getLogger(RadarController.class);

    private final OcrSessionManager sessionManager;
    private final PlateRecognizer plateRecognizer;

    public RadarController(OcrSessionManager sessionManager, PlateRecognizer plateRecognizer) {
        this.sessionManager = sessionManager;
        this.plateRecognizer = plateRecognizer;
    }

    @Operation(summary = "Iniciar Sessão de OCR")
    @PostMapping("/iniciar-sessao")
    public ResponseEntity<Map<String, String>> iniciarSessao() {
        OcrSession session = sessionManager.createSession(); // id gerado e status PENDING  :contentReference[oaicite:12]{index=12}
        log.info("Nova sessão de OCR criada: {}", session.getId());
        return ResponseEntity.ok(Map.of("sessionId", session.getId()));
    }

    @Operation(summary = "Verificar Status da Sessão")
    @GetMapping("/status-sessao/{sessionId}")
    public ResponseEntity<OcrSession> getStatusSessao(@PathVariable String sessionId) {
        return sessionManager.getSession(sessionId)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @Operation(summary = "Upload de Imagem da Placa")
    @PostMapping(
            value = "/upload-imagem/{sessionId}",
            consumes = MediaType.MULTIPART_FORM_DATA_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public ResponseEntity<Map<String, String>> uploadImagem(
            @PathVariable String sessionId,
            @RequestPart(value = "image", required = false) MultipartFile image,
            @RequestPart(value = "file", required = false) MultipartFile file) {

        log.info("Recebida requisição de upload para a sessão: {}", sessionId);

        Optional<OcrSession> optSession = sessionManager.getSession(sessionId);
        if (optSession.isEmpty()) {
            return ResponseEntity.status(404).body(Map.of("error", "Sessão inválida ou expirada."));
        }

        MultipartFile mainPart = (image != null && !image.isEmpty()) ? image : file;

        if (mainPart == null || mainPart.isEmpty()) {
            log.warn("Sessão {}: Multipart sem 'image' nem 'file', ou vazio.", sessionId);
            return ResponseEntity.badRequest().body(Map.of(
                    "error", "Arquivo ausente. Envie o campo 'image' (ou 'file') em multipart/form-data."
            ));
        }

        try {
            byte[] imageBytes = mainPart.getBytes();
            log.info("Sessão {}: Imagem lida com {} bytes.", sessionId, imageBytes.length);

            // Dispara processamento assíncrono no motor configurado (OpenALPR @Primary por padrão).
            plateRecognizer.extractPlate(sessionId, imageBytes); // compatível com o fluxo anterior  :contentReference[oaicite:13]{index=13}

            return ResponseEntity.accepted().body(Map.of("status", "Processamento da imagem iniciado."));

        } catch (IOException e) {
            log.error("Sessão {}: Falha ao ler os bytes da imagem.", sessionId, e);
            sessionManager.updateSessionError(sessionId, "Erro ao ler o arquivo de imagem.");
            return ResponseEntity.status(500).body(Map.of("error", "Erro interno ao ler o arquivo enviado."));

        } catch (Throwable ex) { // captura erros inesperados (ex.: JNI nativo, etc.)
            log.error("Erro inesperado no controller (sessão {}): {}", sessionId, ex.toString(), ex);
            sessionManager.updateSessionError(sessionId, "Erro interno ao processar a imagem.");
            return ResponseEntity.status(500).body(Map.of("error", "Erro interno ao processar a imagem."));
        }
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\RastreamentoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: RastreamentoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.service.RastreamentoService;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.model.Rastreamento;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/rastreamentos")
@Tag(name = "Rastreamentos", description = "Gerenciamento de Rastreamentos")
public class RastreamentoController {

    private static final Logger log = LoggerFactory.getLogger(RastreamentoController.class);
    private final RastreamentoService rastreamentoService;
    private final RastreamentoMapper rastreamentoMapper;

    @Autowired
    public RastreamentoController(RastreamentoService rastreamentoService, RastreamentoMapper rastreamentoMapper) {
        this.rastreamentoService = rastreamentoService;
        this.rastreamentoMapper = rastreamentoMapper;
    }

    @Operation(
            summary = "Listar todos os rastreamentos com paginação",
            description = "Retorna uma página de todos os rastreamentos cadastrados.",
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: dataHoraRegistro,desc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de rastreamentos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)))
            }
    )
    @GetMapping
    public ResponseEntity<Page<RastreamentoResponseDto>> listarTodosRastreamentos(
            @PageableDefault(size = 10, sort = "dataHoraRegistro") Pageable pageable) {
        log.info("Buscando todos os rastreamentos com paginação: {}", pageable);
        Page<Rastreamento> rastreamentosPage = rastreamentoService.listarTodosRastreamentos(pageable);
        Page<RastreamentoResponseDto> rastreamentosDtoPage = rastreamentosPage.map(rastreamentoMapper::toResponseDto);
        log.info("Retornando {} rastreamentos na página {} de um total de {} elementos.", rastreamentosDtoPage.getNumberOfElements(), rastreamentosDtoPage.getNumber(), rastreamentosDtoPage.getTotalElements());
        return ResponseEntity.ok(rastreamentosDtoPage);
    }

    @Operation(
            summary = "Buscar rastreamento por ID",
            description = "Retorna um rastreamento específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Rastreamento encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Rastreamento não encontrado")
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<RastreamentoResponseDto> buscarRastreamentoPorId(@PathVariable Long id) {
        log.info("Buscando rastreamento com ID: {}", id);
        RastreamentoResponseDto rastreamento = rastreamentoMapper.toResponseDto(rastreamentoService.buscarRastreamentoPorId(id));
        log.info("Rastreamento com ID {} encontrado com sucesso.", id);
        return ResponseEntity.ok(rastreamento);
    }

    @Operation(
            summary = "Buscar rastreamentos por filtro com paginação",
            description = "Retorna uma página de rastreamentos que correspondem aos critérios de filtro fornecidos.",
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string", defaultValue = "dataHoraRegistro,desc"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de rastreamentos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<Page<RastreamentoResponseDto>> buscarRastreamentosPorFiltro(
            RastreamentoFilter filter,
            @PageableDefault(size = 10, sort = "dataHoraRegistro") Pageable pageable) {
        log.info("Buscando rastreamentos com filtro: {} e paginação: {}", filter, pageable);
        Page<Rastreamento> rastreamentosPage = rastreamentoService.buscarRastreamentosPorFiltro(filter, pageable);
        Page<RastreamentoResponseDto> rastreamentosDtoPage = rastreamentosPage.map(rastreamentoMapper::toResponseDto);
        log.info("Retornando {} rastreamentos filtrados na página {} de {} elementos.", rastreamentosDtoPage.getNumberOfElements(), rastreamentosDtoPage.getNumber(), rastreamentosDtoPage.getTotalElements());
        return ResponseEntity.ok(rastreamentosDtoPage);
    }

    @Operation(
            summary = "Criar novo rastreamento",
            description = "Cria um novo rastreamento com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Rastreamento criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos (coordenadas ausentes)")
            }
    )
    @PostMapping
    public ResponseEntity<RastreamentoResponseDto> criarRastreamento(@Valid @RequestBody RastreamentoRequestDto rastreamentoRequestDto) {
        log.info("Recebida requisição para criar rastreamento: {}", rastreamentoRequestDto);
        RastreamentoResponseDto novoRastreamento = rastreamentoMapper.toResponseDto(rastreamentoService.criarRastreamento(rastreamentoRequestDto));
        log.info("Rastreamento criado com sucesso com ID: {}", novoRastreamento.getIdRastreamento());
        return ResponseEntity.status(HttpStatus.CREATED).body(novoRastreamento);
    }

    @Operation(
            summary = "Atualizar rastreamento existente",
            description = "Atualiza um rastreamento existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Rastreamento atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<RastreamentoResponseDto> atualizarRastreamento(@PathVariable Long id, @Valid @RequestBody RastreamentoRequestDto rastreamentoRequestDto) {
        log.info("Recebida requisição para atualizar rastreamento com ID {}: {}", id, rastreamentoRequestDto);
        RastreamentoResponseDto rastreamentoAtualizado = rastreamentoMapper.toResponseDto(rastreamentoService.atualizarRastreamento(id, rastreamentoRequestDto));
        log.info("Rastreamento com ID {} atualizado com sucesso.", id);
        return ResponseEntity.ok(rastreamentoAtualizado);
    }

    @Operation(
            summary = "Deletar rastreamento",
            description = "Exclui um rastreamento com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Rastreamento deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Rastreamento não encontrado")
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarRastreamento(@PathVariable Long id) {
        log.info("Recebida requisição para deletar rastreamento com ID: {}", id);
        rastreamentoService.deletarRastreamento(id);
        log.info("Rastreamento com ID {} deletado com sucesso.", id);
        return ResponseEntity.noContent().build();
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\VagaController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: VagaController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.service.vaga.VagaOracleService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.*;

/**
 * Endpoints para ocupação de boxes.
 * Sem DTOs extras de "mapa": retornos em JSON simples para a UI.
 */
@RestController
@RequestMapping("/api/vagas")
@Tag(name = "Vagas", description = "Mapa 2D e alocação de boxes (Oracle)")
public class VagaController {

    private final VagaOracleService service;

    public VagaController(VagaOracleService service) {
        this.service = service;
    }

    /**
     * Mapa 2D atual.
     * Retorna um JSON no formato:
     * {
     *   "rows": 4,
     *   "cols": 5,
     *   "boxes": [
     *     { "box": <BoxResponseDto>, "placa": "ABC1D23" | null }
     *   ]
     * }
     */
    @Operation(summary = "Mapa 2D (rows, cols, boxes). Cada item contém { box: BoxResponseDto, placa }")
    @GetMapping("/mapa")
    public ResponseEntity<Map<String, Object>> mapa() {
        // Se tiver layout dinâmico no futuro, troque rows/cols para virem do banco.
        final int rows = 4;
        final int cols = 5;

        var rowsDb = service.listarBoxesComPlaca();

        List<Map<String, Object>> boxes = new ArrayList<>(rowsDb.size());
        for (var r : rowsDb) {
            BoxResponseDto dto = new BoxResponseDto(
                    r.idBox(),
                    r.nome(),
                    r.status(),
                    r.dataEntrada(),
                    r.dataSaida(),
                    r.observacao()
            );
            Map<String, Object> item = new LinkedHashMap<>();
            item.put("box", dto);
            item.put("placa", r.placa()); // null se livre
            boxes.add(item);
        }

        Map<String, Object> body = new LinkedHashMap<>();
        body.put("rows", rows);
        body.put("cols", cols);
        body.put("boxes", boxes);

        return ResponseEntity.ok(body);
    }

    /**
     * Armazena (aloca) uma placa em um box.
     * body:
     * { "placa": "ABC1D23", "boxId": 12 (opcional) }
     *
     * resposta: { ok, message, placa, boxId }
     */
    @Operation(summary = "Armazenar placa (aloca box). Se não informar boxId, usa primeiro livre.")
    @PostMapping("/armazenar")
    public ResponseEntity<Map<String, Object>> armazenar(@RequestBody Map<String, String> body) {
        String placa = Objects.toString(body.get("placa"), "").trim().toUpperCase();
        String boxIdStr = body.get("boxId");
        Long preferido = (boxIdStr == null || boxIdStr.isBlank()) ? null : Long.valueOf(boxIdStr);

        var res = service.alocarPlaca(placa, preferido);

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("ok", true);
        out.put("message", "Vaga cadastrada");
        out.put("placa", res.placa());
        out.put("boxId", res.boxId());
        return ResponseEntity.status(201).body(out);
    }

    /**
     * Libera um box (remove vínculo e marca STATUS='L').
     * resposta: { ok, boxId }
     */
    @Operation(summary = "Liberar box (remove vínculo e marca STATUS='L')")
    @PostMapping("/liberar/{boxId}")
    public ResponseEntity<Map<String, Object>> liberar(@PathVariable Long boxId) {
        service.liberarBox(boxId);
        return ResponseEntity.ok(Map.of("ok", true, "boxId", boxId));
    }

    /**
     * Busca a placa e diz em qual box está.
     * resposta, quando encontrado:
     * { found: true, placa, boxId, boxNome, status }
     * caso contrário:
     * { found: false, placa }
     */
    @Operation(summary = "Buscar placa e retornar box atual")
    @GetMapping("/buscar-placa/{placa}")
    public ResponseEntity<Map<String, Object>> buscarPlaca(@PathVariable String placa) {
        return service.buscarBoxPorPlaca(placa)
                .<ResponseEntity<Map<String, Object>>>map(b -> ResponseEntity.ok(Map.of(
                        "found", true,
                        "placa", placa.toUpperCase(),
                        "boxId", b.idBox(),
                        "boxNome", b.nomeBox(),
                        "status", b.status()
                )))
                .orElse(ResponseEntity.ok(Map.of("found", false, "placa", placa.toUpperCase())));
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\VeiculoController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: VeiculoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto; // DTO para entrada de dados de Veículo
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // DTO para saída de dados de Veículo
import br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto; // DTO para resposta de localização de Veículo
import br.com.fiap.mottu.filter.VeiculoFilter; // Filtros para busca de Veículos
import br.com.fiap.mottu.service.VeiculoService; // Serviço com a lógica de negócio para Veículos
import br.com.fiap.mottu.mapper.VeiculoMapper; // Mapper para converter entre Entidade e DTOs de Veículo
import br.com.fiap.mottu.model.Veiculo; // Entidade Veiculo
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada

@RestController
@RequestMapping("/api/veiculos")
@Tag(name = "Veiculos", description = "Gerenciamento de Veículos, incluindo Rastreamento e Localização")
public class VeiculoController {

    private static final Logger log = LoggerFactory.getLogger(VeiculoController.class);
    private final VeiculoService veiculoService;
    private final VeiculoMapper veiculoMapper;
    private final VeiculoRepository veiculoRepository; // Injetado para o novo endpoint

    @Autowired
    public VeiculoController(VeiculoService veiculoService, VeiculoMapper veiculoMapper, VeiculoRepository veiculoRepository) {
        this.veiculoService = veiculoService;
        this.veiculoMapper = veiculoMapper;
        this.veiculoRepository = veiculoRepository;
    }

    @Operation(
            summary = "Listar todos os veículos com paginação",
            description = "Retorna uma página de todos os veículos cadastrados.",
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "20")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: placa,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de veículos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)))
            }
    )
    @GetMapping
    public ResponseEntity<Page<VeiculoResponseDto>> listarTodosVeiculos(
            @PageableDefault(size = 10, sort = "placa") Pageable pageable) {
        log.info("Buscando todos os veículos com paginação: {}", pageable);
        Page<Veiculo> veiculosPage = veiculoService.listarTodosVeiculos(pageable);
        Page<VeiculoResponseDto> veiculosDtoPage = veiculosPage.map(veiculoMapper::toResponseDto);
        log.info("Retornando {} veículos na página {} de um total de {} elementos.", veiculosDtoPage.getNumberOfElements(), veiculosDtoPage.getNumber(), veiculosDtoPage.getTotalElements());
        return ResponseEntity.ok(veiculosDtoPage);
    }

    @Operation(
            summary = "Buscar veículo por ID",
            description = "Retorna um veículo específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículo encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Veículo com ID 1 não encontrado(a).\",\"path\":\"/api/veiculos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<VeiculoResponseDto> buscarVeiculoPorId(@PathVariable Long id) {
        log.info("Buscando veículo com ID: {}", id);
        VeiculoResponseDto veiculo = veiculoMapper.toResponseDto(veiculoService.buscarVeiculoPorId(id));
        log.info("Veículo com ID {} encontrado com sucesso.", id);
        return ResponseEntity.ok(veiculo);
    }

    @Operation(
            summary = "Buscar veículos por filtro com paginação",
            description = "Retorna uma página de veículos que correspondem aos critérios de filtro fornecidos.",
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de veículos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<Page<VeiculoResponseDto>> buscarVeiculosPorFiltro(
            VeiculoFilter filter,
            @PageableDefault(size = 10) Pageable pageable) {
        log.info("Buscando veículos com filtro: {} e paginação: {}", filter, pageable);
        Page<Veiculo> veiculosPage = veiculoService.buscarVeiculosPorFiltro(filter, pageable);
        Page<VeiculoResponseDto> veiculosDtoPage = veiculosPage.map(veiculoMapper::toResponseDto);
        log.info("Retornando {} veículos filtrados na página {} de {} elementos.", veiculosDtoPage.getNumberOfElements(), veiculosDtoPage.getNumber(), veiculosDtoPage.getTotalElements());
        return ResponseEntity.ok(veiculosDtoPage);
    }

    @Operation(
            summary = "Criar novo veículo",
            description = "Cria um novo veículo com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Veículo criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/veiculos\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (placa, RENAVAM ou chassi duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Veículo com placa 'ABC1234' já existe.\",\"path\":\"/api/veiculos\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<VeiculoResponseDto> criarVeiculo(@Valid @RequestBody VeiculoRequestDto veiculoRequestDto) {
        log.info("Recebida requisição para criar veículo: {}", veiculoRequestDto);
        VeiculoResponseDto novoVeiculo = veiculoMapper.toResponseDto(veiculoService.criarVeiculo(veiculoRequestDto));
        log.info("Veículo criado com sucesso com ID: {}", novoVeiculo.getIdVeiculo());
        return ResponseEntity.status(HttpStatus.CREATED).body(novoVeiculo);
    }

    @Operation(
            summary = "Atualizar veículo existente",
            description = "Atualiza um veículo existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículo atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado"),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (placa, RENAVAM ou chassi duplicado)")
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<VeiculoResponseDto> atualizarVeiculo(@PathVariable Long id, @Valid @RequestBody VeiculoRequestDto veiculoRequestDto) {
        log.info("Recebida requisição para atualizar veículo com ID {}: {}", id, veiculoRequestDto);
        VeiculoResponseDto veiculoAtualizado = veiculoMapper.toResponseDto(veiculoService.atualizarVeiculo(id, veiculoRequestDto));
        log.info("Veículo com ID {} atualizado com sucesso.", id);
        return ResponseEntity.ok(veiculoAtualizado);
    }

    @Operation(
            summary = "Deletar veículo",
            description = "Exclui um veículo com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Veículo deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado")
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarVeiculo(@PathVariable Long id) {
        log.info("Recebida requisição para deletar veículo com ID: {}", id);
        veiculoService.deletarVeiculo(id);
        log.info("Veículo com ID {} deletado com sucesso.", id);
        return ResponseEntity.noContent().build();
    }

    @Operation(
            summary = "Obter localização de um veículo por ID",
            description = "Retorna o último ponto de rastreamento de um veículo e suas associações atuais com Pátio, Zona e Box.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Localização do veículo retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoLocalizacaoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado")
            }
    )
    @GetMapping("/{id}/localizacao")
    public ResponseEntity<VeiculoLocalizacaoResponseDto> getLocalizacaoVeiculo(@PathVariable Long id) {
        log.info("Buscando localização para o veículo com ID: {}", id);
        VeiculoLocalizacaoResponseDto localizacao = veiculoService.getLocalizacaoVeiculo(id);
        log.info("Localização do veículo com ID {} encontrada com sucesso.", id);
        return ResponseEntity.ok(localizacao);
    }

    // NOVO ENDPOINT
    @Operation(
            summary = "Obter localização de um veículo por PLACA",
            description = "Busca um veículo pela placa e retorna seu último ponto de rastreamento e associações atuais.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Localização do veículo retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoLocalizacaoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo com a placa fornecida não encontrado")
            }
    )
    @GetMapping("/localizacao-por-placa")
    public ResponseEntity<VeiculoLocalizacaoResponseDto> getLocalizacaoPorPlaca(@RequestParam String placa) {
        log.info("Buscando localização para o veículo com PLACA: {}", placa);
        Veiculo veiculo = veiculoRepository.findByPlaca(placa)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", "placa", placa));
        VeiculoLocalizacaoResponseDto localizacao = veiculoService.getLocalizacaoVeiculo(veiculo.getIdVeiculo());
        log.info("Localização do veículo com PLACA {} encontrada com sucesso.", placa);
        return ResponseEntity.ok(localizacao);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\ZonaController.java   |   PACOTE: br.com.fiap.mottu.controller   |   CLASSE: ZonaController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto; // DTO para entrada de dados de Zona
import br.com.fiap.mottu.dto.zona.ZonaResponseDto; // DTO para saída de dados de Zona
import br.com.fiap.mottu.filter.ZonaFilter; // Filtros para busca de Zonas
import br.com.fiap.mottu.service.ZonaService; // Serviço com a lógica de negócio para Zonas
import br.com.fiap.mottu.mapper.ZonaMapper; // Mapper para converter entre Entidade e DTOs de Zona
import br.com.fiap.mottu.model.Zona; // Entidade Zona
// Exceções são tratadas pelo GlobalExceptionHandler
// import br.com.fiap.mottu.exception.DuplicatedResourceException;
// import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation; // Anotação do Swagger para descrever a operação
import io.swagger.v3.oas.annotations.media.Content; // Anotação do Swagger para descrever o conteúdo da resposta
import io.swagger.v3.oas.annotations.media.Schema; // Anotação do Swagger para descrever o schema de dados
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Anotação do Swagger para descrever as respostas da API
import io.swagger.v3.oas.annotations.tags.Tag; // Anotação do Swagger para agrupar endpoints
import io.swagger.v3.oas.annotations.Parameter; // Anotação do Swagger para descrever parâmetros
import io.swagger.v3.oas.annotations.enums.ParameterIn; // Enum para especificar onde o parâmetro é passado

import org.slf4j.Logger; // Para logging
import org.slf4j.LoggerFactory; // Para instanciar o Logger
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para controle de paginação e ordenação
import org.springframework.data.web.PageableDefault; // Para valores padrão de Pageable
import org.springframework.http.HttpStatus; // Enum para códigos de status HTTP
import org.springframework.http.ResponseEntity; // Classe para construir respostas HTTP
import org.springframework.web.bind.annotation.*; // Anotações para mapeamento de requisições web
import jakarta.validation.Valid; // Para validar DTOs de entrada

// import java.util.List; // Não mais usado para listagem principal
// import java.util.stream.Collectors; // Não mais usado para mapear lista manualmente

@RestController // Marca esta classe como um controller REST
@RequestMapping("/api/zonas") // Mapeia todas as requisições que começam com /api/zonas para este controller
@Tag(name = "Zonas", description = "Gerenciamento de Zonas") // Tag do Swagger
public class ZonaController {

    private static final Logger log = LoggerFactory.getLogger(ZonaController.class); // Logger para esta classe
    private final ZonaService zonaService; // Injeção do serviço de Zona
    private final ZonaMapper zonaMapper; // Injeção do mapper de Zona

    @Autowired // Construtor para injeção de dependências
    public ZonaController(ZonaService zonaService, ZonaMapper zonaMapper) {
        this.zonaService = zonaService; //
        this.zonaMapper = zonaMapper; //
    }

    @Operation( // Documentação da operação via Swagger
            summary = "Listar todas as zonas com paginação",
            description = "Retorna uma página de todas as zonas cadastradas.", //
            parameters = { // Documentação dos parâmetros de paginação
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação no formato: propriedade,(asc|desc). Ex: nome,asc", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de zonas retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) // O schema agora é Page
            }
    )
    @GetMapping // Mapeia requisições GET para /api/zonas
    public ResponseEntity<Page<ZonaResponseDto>> listarTodasZonas(
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // @PageableDefault define valores padrão
        log.info("Buscando todas as zonas com paginação: {}", pageable); //
        Page<Zona> zonasPage = zonaService.listarTodasZonas(pageable); // Chama o serviço
        Page<ZonaResponseDto> zonasDtoPage = zonasPage.map(zonaMapper::toResponseDto); // Mapeia Page de Entidade para Page de DTO
        log.info("Retornando {} zonas na página {} de um total de {} elementos.", zonasDtoPage.getNumberOfElements(), zonasDtoPage.getNumber(), zonasDtoPage.getTotalElements());
        return ResponseEntity.ok(zonasDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Buscar zona por ID", //
            description = "Retorna uma zona específica com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zona encontrada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))), //
                    @ApiResponse(responseCode = "404", description = "Zona não encontrada") // Tratado pelo GlobalExceptionHandler
            }
    )
    @GetMapping("/{id}") // Mapeia requisições GET para /api/zonas/{id}
    public ResponseEntity<ZonaResponseDto> buscarZonaPorId(@PathVariable Long id) { // @PathVariable extrai o ID da URL
        log.info("Buscando zona com ID: {}", id); //
        // ResourceNotFoundException é tratada pelo GlobalExceptionHandler
        ZonaResponseDto zona = zonaMapper.toResponseDto(zonaService.buscarZonaPorId(id)); //
        log.info("Zona com ID {} encontrada com sucesso.", id); //
        return ResponseEntity.ok(zona); // Retorna o DTO da zona
    }

    @Operation(
            summary = "Buscar zonas por filtro com paginação", //
            description = "Retorna uma página de zonas que correspondem aos critérios de filtro fornecidos.", //
            parameters = {
                    @Parameter(name = "page", description = "Número da página (0..N)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
                    @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
                    @Parameter(name = "sort", description = "Critério de ordenação (propriedade,[asc|desc])", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
            },
            responses = {
                    @ApiResponse(responseCode = "200", description = "Página de zonas filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class))) //
            }
    )
    @GetMapping("/search") // Mapeia requisições GET para /api/zonas/search
    public ResponseEntity<Page<ZonaResponseDto>> buscarZonasPorFiltro(
            ZonaFilter filter, // Filtros injetados automaticamente
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) { // Paginação
        log.info("Buscando zonas com filtro: {} e paginação: {}", filter, pageable); //
        Page<Zona> zonasPage = zonaService.buscarZonasPorFiltro(filter, pageable); // Chama o serviço
        Page<ZonaResponseDto> zonasDtoPage = zonasPage.map(zonaMapper::toResponseDto); // Mapeia para DTOs
        log.info("Retornando {} zonas filtradas na página {} de {} elementos.", zonasDtoPage.getNumberOfElements(), zonasDtoPage.getNumber(), zonasDtoPage.getTotalElements());
        return ResponseEntity.ok(zonasDtoPage); // Retorna a página de DTOs
    }

    @Operation(
            summary = "Criar nova zona", //
            description = "Cria uma nova zona com os dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "201", description = "Zona criada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))), //
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"), // Tratado pelo GlobalExceptionHandler (Bean Validation)
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)") // Tratado pelo GlobalExceptionHandler
            }
    )
    @PostMapping // Mapeia requisições POST para /api/zonas
    public ResponseEntity<ZonaResponseDto> criarZona(@Valid @RequestBody ZonaRequestDto zonaRequestDto) { // @Valid valida o DTO
        log.info("Recebida requisição para criar zona: {}", zonaRequestDto); //
        // DuplicatedResourceException é tratada pelo GlobalExceptionHandler
        ZonaResponseDto novaZona = zonaMapper.toResponseDto(zonaService.criarZona(zonaRequestDto)); //
        log.info("Zona criada com sucesso com ID: {}", novaZona.getIdZona()); //
        return ResponseEntity.status(HttpStatus.CREATED).body(novaZona); // Retorna 201 CREATED com o DTO da nova zona
    }

    @Operation(
            summary = "Atualizar zona existente", //
            description = "Atualiza uma zona existente com base no ID e nos dados fornecidos.", //
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zona atualizada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))), //
                    // 400, 404, 409 são tratados pelo GlobalExceptionHandler
            }
    )
    @PutMapping("/{id}") // Mapeia requisições PUT para /api/zonas/{id}
    public ResponseEntity<ZonaResponseDto> atualizarZona(@PathVariable Long id, @Valid @RequestBody ZonaRequestDto zonaRequestDto) { //
        log.info("Recebida requisição para atualizar zona com ID {}: {}", id, zonaRequestDto); //
        // ResourceNotFoundException e DuplicatedResourceException são tratadas pelo GlobalExceptionHandler
        ZonaResponseDto zonaAtualizada = zonaMapper.toResponseDto(zonaService.atualizarZona(id, zonaRequestDto)); //
        log.info("Zona com ID {} atualizada com sucesso.", id); //
        return ResponseEntity.ok(zonaAtualizada); // Retorna 200 OK com o DTO da zona atualizada
    }

    @Operation(
            summary = "Deletar zona", //
            description = "Exclui uma zona com base no ID fornecido.", //
            responses = {
                    @ApiResponse(responseCode = "204", description = "Zona deletada com sucesso"), //
                    @ApiResponse(responseCode = "404", description = "Zona não encontrada") // Tratado pelo GlobalExceptionHandler
            }
    )
    @DeleteMapping("/{id}") // Mapeia requisições DELETE para /api/zonas/{id}
    public ResponseEntity<Void> deletarZona(@PathVariable Long id) {
        log.info("Recebida requisição para deletar zona com ID: {}", id); //
        // ResourceNotFoundException será tratada pelo GlobalExceptionHandler
        zonaService.deletarZona(id); //
        log.info("Zona com ID {} deletada com sucesso.", id); //
        return ResponseEntity.noContent().build(); // Retorna 204 NO CONTENT
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dashboard.controller
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\controller\DashboardController.java   |   PACOTE: br.com.fiap.mottu.dashboard.controller   |   CLASSE: DashboardController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dashboard.controller;

import br.com.fiap.mottu.dto.dashboard.OcupacaoDiaDto;
import br.com.fiap.mottu.dto.dashboard.ResumoOcupacaoDto;
import br.com.fiap.mottu.service.DashboardService;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/dashboard")
@CrossOrigin
public class DashboardController {

    private final DashboardService service;

    public DashboardController(DashboardService service) {
        this.service = service;
    }

    @GetMapping("/resumo")
    public ResumoOcupacaoDto resumo() {
        return service.getResumoAtual();
    }

    @GetMapping("/ocupacao-por-dia")
    public List<OcupacaoDiaDto> ocupacaoPorDia(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate ini,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate fim) {
        return service.getOcupacaoPorDia(ini, fim);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\controller\DashboardController.java   |   PACOTE: br.com.fiap.mottu.dashboard.controller   |   CLASSE: DashboardController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dashboard.controller;

import br.com.fiap.mottu.dto.dashboard.OcupacaoDiaDto;
import br.com.fiap.mottu.dto.dashboard.ResumoOcupacaoDto;
import br.com.fiap.mottu.service.DashboardService;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/dashboard")
@CrossOrigin
public class DashboardController {

    private final DashboardService service;

    public DashboardController(DashboardService service) {
        this.service = service;
    }

    @GetMapping("/resumo")
    public ResumoOcupacaoDto resumo() {
        return service.getResumoAtual();
    }

    @GetMapping("/ocupacao-por-dia")
    public List<OcupacaoDiaDto> ocupacaoPorDia(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate ini,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate fim) {
        return service.getOcupacaoPorDia(ini, fim);
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.box
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\box\BoxRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.box   |   CLASSE: BoxRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\box\BoxRequestDto.java
package br.com.fiap.mottu.dto.box;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Box}
 */
@Value
public class BoxRequestDto implements Serializable {
    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(max = 50, message = "O nome deve ter no máximo 50 caracteres.")
    String nome;

    @NotBlank(message = "O status não pode estar em branco.")
    @Size(max = 1, message = "O status deve ter 1 caracter.")
    @Pattern(regexp = "[LO]", message = "O status deve ser 'L' (Livre) ou 'O' (Ocupado).")
    String status;

    @NotNull(message = "A data de entrada não pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saída não pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observação deve ter no máximo 100 caracteres.")
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\box\BoxResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.box   |   CLASSE: BoxResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\box\BoxResponseDto.java
package br.com.fiap.mottu.dto.box;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Box}
 */
@Value
public class BoxResponseDto implements Serializable {
    Long idBox;
    String nome;
    String status;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\box\BoxRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.box   |   CLASSE: BoxRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\box\BoxRequestDto.java
package br.com.fiap.mottu.dto.box;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Box}
 */
@Value
public class BoxRequestDto implements Serializable {
    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(max = 50, message = "O nome deve ter no máximo 50 caracteres.")
    String nome;

    @NotBlank(message = "O status não pode estar em branco.")
    @Size(max = 1, message = "O status deve ter 1 caracter.")
    @Pattern(regexp = "[LO]", message = "O status deve ser 'L' (Livre) ou 'O' (Ocupado).")
    String status;

    @NotNull(message = "A data de entrada não pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saída não pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observação deve ter no máximo 100 caracteres.")
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\box\BoxResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.box   |   CLASSE: BoxResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\box\BoxResponseDto.java
package br.com.fiap.mottu.dto.box;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Box}
 */
@Value
public class BoxResponseDto implements Serializable {
    Long idBox;
    String nome;
    String status;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.cliente
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.cliente   |   CLASSE: ClienteRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java
package br.com.fiap.mottu.dto.cliente;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import lombok.Value;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Cliente}
 */
@Value
public class ClienteRequestDto implements Serializable {
    @NotBlank(message = "O sexo não pode estar em branco.")
    @Size(min = 1, max = 2, message = "O sexo deve ter 1 ou 2 caracteres.")
    @Pattern(regexp = "^[MH]$", message = "O sexo deve ser 'M' (Masculino) ou 'H' (Feminino).")
    String sexo;

    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(max = 100, message = "O nome deve ter no máximo 100 caracteres.")
    String nome;

    @NotBlank(message = "O sobrenome não pode estar em branco.")
    @Size(max = 100, message = "O sobrenome deve ter no máximo 100 caracteres.")
    String sobrenome;

    @NotNull(message = "A data de nascimento não pode ser nula.")
    @Past(message = "A data de nascimento deve ser no passado.")
    LocalDate dataNascimento;

    @NotBlank(message = "O CPF não pode estar em branco.")
    @Size(min = 11, max = 11, message = "O CPF deve ter 11 caracteres.")
    @Pattern(regexp = "^\\d{11}$", message = "O CPF deve conter apenas dígitos.")
    String cpf;

    @NotBlank(message = "A profissão não pode estar em branco.")
    @Size(max = 50, message = "A profissão deve ter no máximo 50 caracteres.")
    String profissao;

    @NotBlank(message = "O estado civil não pode estar em branco.")
    @Size(max = 50, message = "O estado civil deve ter no máximo 50 caracteres.")
    @Pattern(regexp = "^(Solteiro|Casado|Divorciado|Viúvo|Separado|União Estável)$", message = "Estado civil inválido.")
    String estadoCivil;

    @NotNull(message = "O endereço não pode ser nulo.")
    @Valid
    EnderecoRequestDto enderecoRequestDto;

    @NotNull(message = "O contato não pode ser nulo.")
    @Valid
    ContatoRequestDto contatoRequestDto;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.cliente   |   CLASSE: ClienteResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java
package br.com.fiap.mottu.dto.cliente;

import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import lombok.Value;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.Set;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;

/**
 * DTO for {@link br.com.fiap.mottu.model.Cliente}
 */
@Value
public class ClienteResponseDto implements Serializable {
    Long idCliente;
    LocalDate dataCadastro;
    String sexo;
    String nome;
    String sobrenome;
    LocalDate dataNascimento;
    String cpf;
    String profissao;
    String estadoCivil;
    EnderecoResponseDto enderecoResponseDto;
    ContatoResponseDto contatoResponseDto;

    // Set<VeiculoResponseDto> veiculos; // Necessita de mapeamento customizado no ClienteMapper
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.cliente   |   CLASSE: ClienteRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java
package br.com.fiap.mottu.dto.cliente;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import lombok.Value;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Cliente}
 */
@Value
public class ClienteRequestDto implements Serializable {
    @NotBlank(message = "O sexo não pode estar em branco.")
    @Size(min = 1, max = 2, message = "O sexo deve ter 1 ou 2 caracteres.")
    @Pattern(regexp = "^[MH]$", message = "O sexo deve ser 'M' (Masculino) ou 'H' (Feminino).")
    String sexo;

    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(max = 100, message = "O nome deve ter no máximo 100 caracteres.")
    String nome;

    @NotBlank(message = "O sobrenome não pode estar em branco.")
    @Size(max = 100, message = "O sobrenome deve ter no máximo 100 caracteres.")
    String sobrenome;

    @NotNull(message = "A data de nascimento não pode ser nula.")
    @Past(message = "A data de nascimento deve ser no passado.")
    LocalDate dataNascimento;

    @NotBlank(message = "O CPF não pode estar em branco.")
    @Size(min = 11, max = 11, message = "O CPF deve ter 11 caracteres.")
    @Pattern(regexp = "^\\d{11}$", message = "O CPF deve conter apenas dígitos.")
    String cpf;

    @NotBlank(message = "A profissão não pode estar em branco.")
    @Size(max = 50, message = "A profissão deve ter no máximo 50 caracteres.")
    String profissao;

    @NotBlank(message = "O estado civil não pode estar em branco.")
    @Size(max = 50, message = "O estado civil deve ter no máximo 50 caracteres.")
    @Pattern(regexp = "^(Solteiro|Casado|Divorciado|Viúvo|Separado|União Estável)$", message = "Estado civil inválido.")
    String estadoCivil;

    @NotNull(message = "O endereço não pode ser nulo.")
    @Valid
    EnderecoRequestDto enderecoRequestDto;

    @NotNull(message = "O contato não pode ser nulo.")
    @Valid
    ContatoRequestDto contatoRequestDto;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.cliente   |   CLASSE: ClienteResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java
package br.com.fiap.mottu.dto.cliente;

import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import lombok.Value;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.Set;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;

/**
 * DTO for {@link br.com.fiap.mottu.model.Cliente}
 */
@Value
public class ClienteResponseDto implements Serializable {
    Long idCliente;
    LocalDate dataCadastro;
    String sexo;
    String nome;
    String sobrenome;
    LocalDate dataNascimento;
    String cpf;
    String profissao;
    String estadoCivil;
    EnderecoResponseDto enderecoResponseDto;
    ContatoResponseDto contatoResponseDto;

    // Set<VeiculoResponseDto> veiculos; // Necessita de mapeamento customizado no ClienteMapper
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.contato
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\contato\ContatoRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.contato   |   CLASSE: ContatoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/mottu/dto/contato/ContatoRequestDto.java
package br.com.fiap.mottu.dto.contato;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;

@Value
public class ContatoRequestDto implements Serializable {
    /** ID para identificar um contato existente em operações de atualização */
    Long idContato;

    @NotBlank(message = "O email não pode estar em branco.")
    @Email(message = "Formato de email inválido.")
    String email;

    @Min(value = 0, message = "DDD inválido.")
    Integer ddd;

    @Min(value = 0, message = "DDI inválido.")
    Integer ddi;

    @Size(max = 20, message = "O telefone 1 deve ter no máximo 20 caracteres.")
    String telefone1;

    @Size(max = 20, message = "O telefone 2 deve ter no máximo 20 caracteres.")
    String telefone2;

    @Size(max = 20, message = "O telefone 3 deve ter no máximo 20 caracteres.")
    String telefone3;

    @NotBlank(message = "O celular não pode estar em branco.")
    @Size(max = 20, message = "O celular deve ter no máximo 20 caracteres.")
    String celular;

    @Size(max = 100, message = "Outras informações de contato devem ter no máximo 100 caracteres.")
    String outro;

    @Size(max = 200, message = "A observação deve ter no máximo 200 caracteres.")
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\contato\ContatoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.contato   |   CLASSE: ContatoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\contato\ContatoResponseDto.java
package br.com.fiap.mottu.dto.contato;

import lombok.Value;

import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Contato}
 */
@Value
public class ContatoResponseDto implements Serializable {
    Long idContato;
    String email;
    Integer ddd;
    Integer ddi;
    String telefone1;
    String telefone2;
    String telefone3;
    String celular;
    String outro;
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\contato\ContatoRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.contato   |   CLASSE: ContatoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/mottu/dto/contato/ContatoRequestDto.java
package br.com.fiap.mottu.dto.contato;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;

@Value
public class ContatoRequestDto implements Serializable {
    /** ID para identificar um contato existente em operações de atualização */
    Long idContato;

    @NotBlank(message = "O email não pode estar em branco.")
    @Email(message = "Formato de email inválido.")
    String email;

    @Min(value = 0, message = "DDD inválido.")
    Integer ddd;

    @Min(value = 0, message = "DDI inválido.")
    Integer ddi;

    @Size(max = 20, message = "O telefone 1 deve ter no máximo 20 caracteres.")
    String telefone1;

    @Size(max = 20, message = "O telefone 2 deve ter no máximo 20 caracteres.")
    String telefone2;

    @Size(max = 20, message = "O telefone 3 deve ter no máximo 20 caracteres.")
    String telefone3;

    @NotBlank(message = "O celular não pode estar em branco.")
    @Size(max = 20, message = "O celular deve ter no máximo 20 caracteres.")
    String celular;

    @Size(max = 100, message = "Outras informações de contato devem ter no máximo 100 caracteres.")
    String outro;

    @Size(max = 200, message = "A observação deve ter no máximo 200 caracteres.")
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\contato\ContatoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.contato   |   CLASSE: ContatoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\contato\ContatoResponseDto.java
package br.com.fiap.mottu.dto.contato;

import lombok.Value;

import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Contato}
 */
@Value
public class ContatoResponseDto implements Serializable {
    Long idContato;
    String email;
    Integer ddd;
    Integer ddi;
    String telefone1;
    String telefone2;
    String telefone3;
    String celular;
    String outro;
    String observacao;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.dashboard
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\dashboard\OcupacaoDiaDto.java   |   PACOTE: br.com.fiap.mottu.dto.dashboard   |   CLASSE: OcupacaoDiaDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// DTO
package br.com.fiap.mottu.dto.dashboard;
import java.time.LocalDate;
public record OcupacaoDiaDto(LocalDate dia, Long ocupados, Long livres) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\dashboard\ResumoOcupacaoDto.java   |   PACOTE: br.com.fiap.mottu.dto.dashboard   |   CLASSE: ResumoOcupacaoDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.dashboard;

public record ResumoOcupacaoDto(long totalBoxes, long ocupados, long livres) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\dashboard\OcupacaoDiaDto.java   |   PACOTE: br.com.fiap.mottu.dto.dashboard   |   CLASSE: OcupacaoDiaDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// DTO
package br.com.fiap.mottu.dto.dashboard;
import java.time.LocalDate;
public record OcupacaoDiaDto(LocalDate dia, Long ocupados, Long livres) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\dashboard\ResumoOcupacaoDto.java   |   PACOTE: br.com.fiap.mottu.dto.dashboard   |   CLASSE: ResumoOcupacaoDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.dashboard;

public record ResumoOcupacaoDto(long totalBoxes, long ocupados, long livres) {}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.endereco
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.endereco   |   CLASSE: EnderecoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java
package br.com.fiap.mottu.dto.endereco;

import lombok.Value;

import jakarta.validation.constraints.*;
import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Endereco}
 */
@Value
public class EnderecoRequestDto implements Serializable {
    // Apenas CEP, numero, complemento e observacao virão na requisição
    // Outros campos serão preenchidos pela ViaCEP
    @NotBlank(message = "O CEP não pode estar em branco.")
    @Size(min = 8, max = 9, message = "O CEP deve ter 8 ou 9 caracteres (formato 'XXXXXXXX' ou 'XXXXX-XXX').")
    @Pattern(regexp = "^\\d{8}$|^\\d{5}-\\d{3}$", message = "Formato de CEP inválido (esperado XXXXXXXX ou XXXXX-XXX).")
    String cep;

    @NotNull(message = "O número do endereço não pode ser nulo.")
    @Positive(message = "O número do endereço deve ser positivo.")
    @Max(value = 9999999, message = "O número do endereço deve ter no máximo 7 dígitos.")
    Integer numero;

    @Size(max = 60, message = "O complemento deve ter no máximo 60 caracteres.")
    String complemento;

    @Size(max = 200, message = "A observação deve ter no máximo 200 caracteres.")
    String observacao;

    // ID para identificar um endereço existente em operações de atualização
    Long idEndereco; // Adicionado para permitir a atualização de endereços existentes via ClienteRequestDto
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.endereco   |   CLASSE: EnderecoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java
package br.com.fiap.mottu.dto.endereco;

import lombok.Value;

import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Endereco}
 */
@Value
public class EnderecoResponseDto implements Serializable {
    Long idEndereco;
    String cep;
    Integer numero;
    String logradouro;
    String bairro;
    String cidade;
    String estado;
    String pais;
    String complemento;
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.endereco   |   CLASSE: EnderecoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java
package br.com.fiap.mottu.dto.endereco;

import lombok.Value;

import jakarta.validation.constraints.*;
import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Endereco}
 */
@Value
public class EnderecoRequestDto implements Serializable {
    // Apenas CEP, numero, complemento e observacao virão na requisição
    // Outros campos serão preenchidos pela ViaCEP
    @NotBlank(message = "O CEP não pode estar em branco.")
    @Size(min = 8, max = 9, message = "O CEP deve ter 8 ou 9 caracteres (formato 'XXXXXXXX' ou 'XXXXX-XXX').")
    @Pattern(regexp = "^\\d{8}$|^\\d{5}-\\d{3}$", message = "Formato de CEP inválido (esperado XXXXXXXX ou XXXXX-XXX).")
    String cep;

    @NotNull(message = "O número do endereço não pode ser nulo.")
    @Positive(message = "O número do endereço deve ser positivo.")
    @Max(value = 9999999, message = "O número do endereço deve ter no máximo 7 dígitos.")
    Integer numero;

    @Size(max = 60, message = "O complemento deve ter no máximo 60 caracteres.")
    String complemento;

    @Size(max = 200, message = "A observação deve ter no máximo 200 caracteres.")
    String observacao;

    // ID para identificar um endereço existente em operações de atualização
    Long idEndereco; // Adicionado para permitir a atualização de endereços existentes via ClienteRequestDto
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.endereco   |   CLASSE: EnderecoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java
package br.com.fiap.mottu.dto.endereco;

import lombok.Value;

import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Endereco}
 */
@Value
public class EnderecoResponseDto implements Serializable {
    Long idEndereco;
    String cep;
    Integer numero;
    String logradouro;
    String bairro;
    String cidade;
    String estado;
    String pais;
    String complemento;
    String observacao;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.estacionamento
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\estacionamento\PlacaRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.estacionamento   |   CLASSE: PlacaRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.estacionamento;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlacaRequestDto {

    @NotBlank(message = "A placa não pode estar em branco.")
    @Size(max = 10, message = "A placa deve ter no máximo 10 caracteres.")
    private String placa;

    public String getPlaca() {
        return placa;
    }

    public void setPlaca(String placa) {
        this.placa = placa;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\estacionamento\PlacaRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.estacionamento   |   CLASSE: PlacaRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.estacionamento;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class PlacaRequestDto {

    @NotBlank(message = "A placa não pode estar em branco.")
    @Size(max = 10, message = "A placa deve ter no máximo 10 caracteres.")
    private String placa;

    public String getPlaca() {
        return placa;
    }

    public void setPlaca(String placa) {
        this.placa = placa;
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.patio
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\patio\PatioRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.patio   |   CLASSE: PatioRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\patio\PatioRequestDto.java
package br.com.fiap.mottu.dto.patio;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Patio}
 */
@Value
public class PatioRequestDto implements Serializable {
    @NotBlank(message = "O nome do pátio não pode estar em branco.")
    @Size(max = 50, message = "O nome do pátio deve ter no máximo 50 caracteres.")
    String nomePatio;

    @NotNull(message = "A data de entrada não pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saída não pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observação deve ter no máximo 100 caracteres.")
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\patio\PatioResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.patio   |   CLASSE: PatioResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\patio\PatioResponseDto.java
package br.com.fiap.mottu.dto.patio;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Patio}
 */
@Value
public class PatioResponseDto implements Serializable {
    Long idPatio;
    String nomePatio;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\patio\PatioRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.patio   |   CLASSE: PatioRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\patio\PatioRequestDto.java
package br.com.fiap.mottu.dto.patio;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Patio}
 */
@Value
public class PatioRequestDto implements Serializable {
    @NotBlank(message = "O nome do pátio não pode estar em branco.")
    @Size(max = 50, message = "O nome do pátio deve ter no máximo 50 caracteres.")
    String nomePatio;

    @NotNull(message = "A data de entrada não pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saída não pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observação deve ter no máximo 100 caracteres.")
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\patio\PatioResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.patio   |   CLASSE: PatioResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\patio\PatioResponseDto.java
package br.com.fiap.mottu.dto.patio;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Patio}
 */
@Value
public class PatioResponseDto implements Serializable {
    Long idPatio;
    String nomePatio;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.rastreamento
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.rastreamento   |   CLASSE: RastreamentoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.rastreamento;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;
import java.math.BigDecimal; // Importe BigDecimal!

/**
 * DTO for {@link br.com.fiap.mottu.model.Rastreamento}
 */
@Value
public class RastreamentoRequestDto implements Serializable {

    @NotNull(message = "A coordenada IPS X não pode ser nula.")
    private BigDecimal ipsX;

    @NotNull(message = "A coordenada IPS Y não pode ser nula.")
    private BigDecimal ipsY;

    @NotNull(message = "A coordenada IPS Z não pode ser nula.")
    private BigDecimal ipsZ;

    @NotNull(message = "A Latitude GPRS não pode ser nula.")
    private BigDecimal gprsLatitude;

    @NotNull(message = "A Longitude GPRS não pode ser nula.")
    private BigDecimal gprsLongitude;

    @NotNull(message = "A Altitude GPRS não pode ser nula.")
    private BigDecimal gprsAltitude;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.rastreamento   |   CLASSE: RastreamentoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.rastreamento;

import lombok.Value; // Lombok: Para criar DTOs imutáveis e concisos
import java.io.Serializable; // Interface para marcar a classe como serializável
import java.math.BigDecimal; // Para representar números decimais com precisão
import java.time.LocalDateTime; // Para representar data e hora

/**
 * DTO for {@link br.com.fiap.mottu.model.Rastreamento}
 * Usado para transferir dados de Rastreamento da aplicação para o cliente (resposta).
 */
@Value // Lombok: Gera construtor com todos os campos, getters, equals, hashCode e toString.
public class RastreamentoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L; // Identificador para serialização

    Long idRastreamento; // ID do rastreamento

    // Coordenadas IPS (Indoor Positioning System)
    private BigDecimal ipsX;
    private BigDecimal ipsY;
    private BigDecimal ipsZ;

    // Coordenadas GPRS
    private BigDecimal gprsLatitude;
    private BigDecimal gprsLongitude;
    private BigDecimal gprsAltitude;

    LocalDateTime dataHoraRegistro; // NOVO CAMPO: Data e hora em que o rastreamento foi registrado
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.rastreamento   |   CLASSE: RastreamentoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.rastreamento;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;
import java.math.BigDecimal; // Importe BigDecimal!

/**
 * DTO for {@link br.com.fiap.mottu.model.Rastreamento}
 */
@Value
public class RastreamentoRequestDto implements Serializable {

    @NotNull(message = "A coordenada IPS X não pode ser nula.")
    private BigDecimal ipsX;

    @NotNull(message = "A coordenada IPS Y não pode ser nula.")
    private BigDecimal ipsY;

    @NotNull(message = "A coordenada IPS Z não pode ser nula.")
    private BigDecimal ipsZ;

    @NotNull(message = "A Latitude GPRS não pode ser nula.")
    private BigDecimal gprsLatitude;

    @NotNull(message = "A Longitude GPRS não pode ser nula.")
    private BigDecimal gprsLongitude;

    @NotNull(message = "A Altitude GPRS não pode ser nula.")
    private BigDecimal gprsAltitude;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.rastreamento   |   CLASSE: RastreamentoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.rastreamento;

import lombok.Value; // Lombok: Para criar DTOs imutáveis e concisos
import java.io.Serializable; // Interface para marcar a classe como serializável
import java.math.BigDecimal; // Para representar números decimais com precisão
import java.time.LocalDateTime; // Para representar data e hora

/**
 * DTO for {@link br.com.fiap.mottu.model.Rastreamento}
 * Usado para transferir dados de Rastreamento da aplicação para o cliente (resposta).
 */
@Value // Lombok: Gera construtor com todos os campos, getters, equals, hashCode e toString.
public class RastreamentoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L; // Identificador para serialização

    Long idRastreamento; // ID do rastreamento

    // Coordenadas IPS (Indoor Positioning System)
    private BigDecimal ipsX;
    private BigDecimal ipsY;
    private BigDecimal ipsZ;

    // Coordenadas GPRS
    private BigDecimal gprsLatitude;
    private BigDecimal gprsLongitude;
    private BigDecimal gprsAltitude;

    LocalDateTime dataHoraRegistro; // NOVO CAMPO: Data e hora em que o rastreamento foi registrado
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.veiculo
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\veiculo\VeiculoLocalizacaoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.veiculo   |   CLASSE: VeiculoLocalizacaoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.veiculo;

import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import lombok.Value;

import java.io.Serializable;
import java.time.LocalDateTime;

@Value
public class VeiculoLocalizacaoResponseDto implements Serializable {
    Long idVeiculo;
    String placa;
    String modelo;
    String fabricante;
    String status;
    String tagBleId;
    RastreamentoResponseDto ultimoRastreamento;
    PatioResponseDto patioAssociado;
    ZonaResponseDto zonaAssociada;
    BoxResponseDto boxAssociado;
    LocalDateTime dataConsulta;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\veiculo\VeiculoRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.veiculo   |   CLASSE: VeiculoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.veiculo;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;

@Value
public class VeiculoRequestDto implements Serializable {
    @NotBlank(message = "A placa não pode estar em branco.")
    @Size(max = 10, message = "A placa deve ter no máximo 10 caracteres.")
    String placa;

    @NotBlank(message = "O RENAVAM não pode estar em branco.")
    @Size(min = 11, max = 11, message = "O RENAVAM deve ter 11 caracteres.")
    @Pattern(regexp = "^\\d{11}$", message = "O RENAVAM deve conter apenas dígitos.")
    String renavam;

    @NotBlank(message = "O chassi não pode estar em branco.")
    @Size(min = 17, max = 17, message = "O chassi deve ter 17 caracteres.")
    String chassi;

    @NotBlank(message = "O fabricante não pode estar em branco.")
    @Size(max = 50, message = "O fabricante deve ter no máximo 50 caracteres.")
    String fabricante;

    @NotBlank(message = "O modelo não pode estar em branco.")
    @Size(max = 60, message = "O modelo deve ter no máximo 60 caracteres.")
    String modelo;

    @Size(max = 30, message = "O motor deve ter no máximo 30 caracteres.")
    String motor;

    @NotNull(message = "O ano não pode ser nulo.")
    @Min(value = 1900, message = "O ano deve ser a partir de 1900.")
    @Max(value = 2100, message = "O ano deve ser no máximo 2100.")
    Integer ano;

    @NotBlank(message = "O combustível não pode estar em branco.")
    @Size(max = 20, message = "O combustível deve ter no máximo 20 caracteres.")
    String combustivel;

    @Size(max = 50, message = "O ID da Tag BLE deve ter no máximo 50 caracteres.")
    String tagBleId;

    @Pattern(regexp = "^(OPERACIONAL|EM_MANUTENCAO|INATIVO)$", message = "Status inválido. Valores permitidos: OPERACIONAL, EM_MANUTENCAO, INATIVO.")
    String status;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\veiculo\VeiculoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.veiculo   |   CLASSE: VeiculoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.veiculo;

import lombok.Value;
import java.io.Serializable;

@Value
public class VeiculoResponseDto implements Serializable {
    Long idVeiculo;
    String placa;
    String renavam;
    String chassi;
    String fabricante;
    String modelo;
    String motor;
    Integer ano;
    String combustivel;
    String tagBleId;
    String status;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\veiculo\VeiculoLocalizacaoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.veiculo   |   CLASSE: VeiculoLocalizacaoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.veiculo;

import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import lombok.Value;

import java.io.Serializable;
import java.time.LocalDateTime;

@Value
public class VeiculoLocalizacaoResponseDto implements Serializable {
    Long idVeiculo;
    String placa;
    String modelo;
    String fabricante;
    String status;
    String tagBleId;
    RastreamentoResponseDto ultimoRastreamento;
    PatioResponseDto patioAssociado;
    ZonaResponseDto zonaAssociada;
    BoxResponseDto boxAssociado;
    LocalDateTime dataConsulta;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\veiculo\VeiculoRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.veiculo   |   CLASSE: VeiculoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.veiculo;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;

@Value
public class VeiculoRequestDto implements Serializable {
    @NotBlank(message = "A placa não pode estar em branco.")
    @Size(max = 10, message = "A placa deve ter no máximo 10 caracteres.")
    String placa;

    @NotBlank(message = "O RENAVAM não pode estar em branco.")
    @Size(min = 11, max = 11, message = "O RENAVAM deve ter 11 caracteres.")
    @Pattern(regexp = "^\\d{11}$", message = "O RENAVAM deve conter apenas dígitos.")
    String renavam;

    @NotBlank(message = "O chassi não pode estar em branco.")
    @Size(min = 17, max = 17, message = "O chassi deve ter 17 caracteres.")
    String chassi;

    @NotBlank(message = "O fabricante não pode estar em branco.")
    @Size(max = 50, message = "O fabricante deve ter no máximo 50 caracteres.")
    String fabricante;

    @NotBlank(message = "O modelo não pode estar em branco.")
    @Size(max = 60, message = "O modelo deve ter no máximo 60 caracteres.")
    String modelo;

    @Size(max = 30, message = "O motor deve ter no máximo 30 caracteres.")
    String motor;

    @NotNull(message = "O ano não pode ser nulo.")
    @Min(value = 1900, message = "O ano deve ser a partir de 1900.")
    @Max(value = 2100, message = "O ano deve ser no máximo 2100.")
    Integer ano;

    @NotBlank(message = "O combustível não pode estar em branco.")
    @Size(max = 20, message = "O combustível deve ter no máximo 20 caracteres.")
    String combustivel;

    @Size(max = 50, message = "O ID da Tag BLE deve ter no máximo 50 caracteres.")
    String tagBleId;

    @Pattern(regexp = "^(OPERACIONAL|EM_MANUTENCAO|INATIVO)$", message = "Status inválido. Valores permitidos: OPERACIONAL, EM_MANUTENCAO, INATIVO.")
    String status;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\veiculo\VeiculoResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.veiculo   |   CLASSE: VeiculoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.veiculo;

import lombok.Value;
import java.io.Serializable;

@Value
public class VeiculoResponseDto implements Serializable {
    Long idVeiculo;
    String placa;
    String renavam;
    String chassi;
    String fabricante;
    String modelo;
    String motor;
    Integer ano;
    String combustivel;
    String tagBleId;
    String status;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.dto.zona
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\zona\ZonaRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.zona   |   CLASSE: ZonaRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\zona\ZonaRequestDto.java
package br.com.fiap.mottu.dto.zona;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Zona}
 */
@Value
public class ZonaRequestDto implements Serializable {
    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(max = 50, message = "O nome deve ter no máximo 50 caracteres.")
    String nome;

    @NotNull(message = "A data de entrada não pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saída não pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observação deve ter no máximo 100 caracteres.")
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\dto\zona\ZonaResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.zona   |   CLASSE: ZonaResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\zona\ZonaResponseDto.java
package br.com.fiap.mottu.dto.zona;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Zona}
 */
@Value
public class ZonaResponseDto implements Serializable {
    Long idZona;
    String nome;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\zona\ZonaRequestDto.java   |   PACOTE: br.com.fiap.mottu.dto.zona   |   CLASSE: ZonaRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\zona\ZonaRequestDto.java
package br.com.fiap.mottu.dto.zona;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Zona}
 */
@Value
public class ZonaRequestDto implements Serializable {
    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(max = 50, message = "O nome deve ter no máximo 50 caracteres.")
    String nome;

    @NotNull(message = "A data de entrada não pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saída não pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observação deve ter no máximo 100 caracteres.")
    String observacao;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\dto\zona\ZonaResponseDto.java   |   PACOTE: br.com.fiap.mottu.dto.zona   |   CLASSE: ZonaResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\zona\ZonaResponseDto.java
package br.com.fiap.mottu.dto.zona;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Zona}
 */
@Value
public class ZonaResponseDto implements Serializable {
    Long idZona;
    String nome;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.exception
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\exception\DuplicatedResourceException.java   |   PACOTE: br.com.fiap.mottu.exception   |   CLASSE: DuplicatedResourceException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\DuplicatedResourceException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// Anotação para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.CONFLICT) // 409 Conflict
public class DuplicatedResourceException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public DuplicatedResourceException(String message) {
        super(message);
    }

    public DuplicatedResourceException(String resourceName, String identifierName, String identifierValue) {
        super(String.format("%s com %s '%s' já existe.", resourceName, identifierName, identifierValue));
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\exception\InvalidInputException.java   |   PACOTE: br.com.fiap.mottu.exception   |   CLASSE: InvalidInputException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\InvalidInputException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// Anotação para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.BAD_REQUEST) // 400 Bad Request
public class InvalidInputException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public InvalidInputException(String message) {
        super(message);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\exception\ResourceNotFoundException.java   |   PACOTE: br.com.fiap.mottu.exception   |   CLASSE: ResourceNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\ResourceNotFoundException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// Anotação para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String resourceName, Long id) {
        super(String.format("%s com ID %d não encontrado(a).", resourceName, id));
    }

    public ResourceNotFoundException(String resourceName, String identifierName, String identifierValue) {
        super(String.format("%s com %s '%s' não encontrado(a).", resourceName, identifierName, identifierValue));
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\exception\DuplicatedResourceException.java   |   PACOTE: br.com.fiap.mottu.exception   |   CLASSE: DuplicatedResourceException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\DuplicatedResourceException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// Anotação para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.CONFLICT) // 409 Conflict
public class DuplicatedResourceException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public DuplicatedResourceException(String message) {
        super(message);
    }

    public DuplicatedResourceException(String resourceName, String identifierName, String identifierValue) {
        super(String.format("%s com %s '%s' já existe.", resourceName, identifierName, identifierValue));
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\exception\InvalidInputException.java   |   PACOTE: br.com.fiap.mottu.exception   |   CLASSE: InvalidInputException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\InvalidInputException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// Anotação para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.BAD_REQUEST) // 400 Bad Request
public class InvalidInputException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public InvalidInputException(String message) {
        super(message);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\exception\ResourceNotFoundException.java   |   PACOTE: br.com.fiap.mottu.exception   |   CLASSE: ResourceNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\ResourceNotFoundException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// Anotação para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String resourceName, Long id) {
        super(String.format("%s com ID %d não encontrado(a).", resourceName, id));
    }

    public ResourceNotFoundException(String resourceName, String identifierName, String identifierValue) {
        super(String.format("%s com %s '%s' não encontrado(a).", resourceName, identifierName, identifierValue));
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.exception.handler
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java   |   PACOTE: br.com.fiap.mottu.exception.handler   |   CLASSE: GlobalExceptionHandler
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java
package br.com.fiap.mottu.exception.handler;

import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.InvalidInputException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "Não Encontrado");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(DuplicatedResourceException.class)
    public ResponseEntity<Object> handleDuplicatedResourceException(DuplicatedResourceException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.CONFLICT.value());
        body.put("error", "Conflito de Dados");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(InvalidInputException.class)
    public ResponseEntity<Object> handleInvalidInputException(InvalidInputException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Requisição Inválida");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    // Você pode adicionar mais handlers para outras exceções que possam surgir,
    // como DataIntegrityViolationException do JPA/Hibernate.
    // Exemplo:
    // @ExceptionHandler(DataIntegrityViolationException.class)
    // public ResponseEntity<Object> handleDataIntegrityViolationException(DataIntegrityViolationException ex, WebRequest request) {
    //    // ... lógica similar, retornando 409 Conflict ou 400 Bad Request dependendo do caso
    // }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java   |   PACOTE: br.com.fiap.mottu.exception.handler   |   CLASSE: GlobalExceptionHandler
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java
package br.com.fiap.mottu.exception.handler;

import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.InvalidInputException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "Não Encontrado");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(DuplicatedResourceException.class)
    public ResponseEntity<Object> handleDuplicatedResourceException(DuplicatedResourceException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.CONFLICT.value());
        body.put("error", "Conflito de Dados");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(InvalidInputException.class)
    public ResponseEntity<Object> handleInvalidInputException(InvalidInputException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Requisição Inválida");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    // Você pode adicionar mais handlers para outras exceções que possam surgir,
    // como DataIntegrityViolationException do JPA/Hibernate.
    // Exemplo:
    // @ExceptionHandler(DataIntegrityViolationException.class)
    // public ResponseEntity<Object> handleDataIntegrityViolationException(DataIntegrityViolationException ex, WebRequest request) {
    //    // ... lógica similar, retornando 409 Conflict ou 400 Bad Request dependendo do caso
    // }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.external.viacep
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\external\viacep\ViaCepResponse.java   |   PACOTE: br.com.fiap.mottu.external.viacep   |   CLASSE: ViaCepResponse
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\external\viacep\ViaCepResponse.java
package br.com.fiap.mottu.external.viacep; // Pacote atualizado

import com.fasterxml.jackson.annotation.JsonAlias;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ViaCepResponse {
    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade; // Corresponde à cidade
    private String uf;         // Corresponde ao estado
    private String ibge;
    private String gia;
    private String ddd;
    private String siafi;

    @JsonAlias("erro")
    private Boolean erro;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\external\viacep\ViaCepService.java   |   PACOTE: br.com.fiap.mottu.external.viacep   |   CLASSE: ViaCepService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\external\viacep\ViaCepService.java
package br.com.fiap.mottu.external.viacep; // Pacote atualizado

import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono; // Para trabalhar com WebClient (assíncrono)

@Service
public class ViaCepService {

    private final WebClient webClient;

    public ViaCepService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://viacep.com.br/ws/").build();
    }

    public Mono<ViaCepResponse> buscarEnderecoPorCep(String cep) {
        String cleanCep = cep.replaceAll("[^0-9]", "");

        if (cleanCep.length() != 8) {
            return Mono.error(new IllegalArgumentException("CEP inválido. Deve conter 8 dígitos."));
        }

        return webClient.get()
                .uri("/{cep}/json/", cleanCep)
                .retrieve()
                .bodyToMono(ViaCepResponse.class)
                .flatMap(response -> {
                    if (response.getErro() != null && response.getErro()) {
                        return Mono.empty();
                    }
                    return Mono.just(response);
                });
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\external\viacep\ViaCepResponse.java   |   PACOTE: br.com.fiap.mottu.external.viacep   |   CLASSE: ViaCepResponse
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\external\viacep\ViaCepResponse.java
package br.com.fiap.mottu.external.viacep; // Pacote atualizado

import com.fasterxml.jackson.annotation.JsonAlias;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ViaCepResponse {
    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade; // Corresponde à cidade
    private String uf;         // Corresponde ao estado
    private String ibge;
    private String gia;
    private String ddd;
    private String siafi;

    @JsonAlias("erro")
    private Boolean erro;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\external\viacep\ViaCepService.java   |   PACOTE: br.com.fiap.mottu.external.viacep   |   CLASSE: ViaCepService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\external\viacep\ViaCepService.java
package br.com.fiap.mottu.external.viacep; // Pacote atualizado

import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono; // Para trabalhar com WebClient (assíncrono)

@Service
public class ViaCepService {

    private final WebClient webClient;

    public ViaCepService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://viacep.com.br/ws/").build();
    }

    public Mono<ViaCepResponse> buscarEnderecoPorCep(String cep) {
        String cleanCep = cep.replaceAll("[^0-9]", "");

        if (cleanCep.length() != 8) {
            return Mono.error(new IllegalArgumentException("CEP inválido. Deve conter 8 dígitos."));
        }

        return webClient.get()
                .uri("/{cep}/json/", cleanCep)
                .retrieve()
                .bodyToMono(ViaCepResponse.class)
                .flatMap(response -> {
                    if (response.getErro() != null && response.getErro()) {
                        return Mono.empty();
                    }
                    return Mono.just(response);
                });
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.filter
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\filter\BoxFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: BoxFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\BoxFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record BoxFilter(
        String nome,
        String status,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\filter\ClienteFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: ClienteFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\ClienteFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record ClienteFilter(
        String nome,
        String sobrenome,
        String cpf,
        String sexo,
        String profissao,
        String estadoCivil,
        LocalDate dataCadastroInicio,
        LocalDate dataCadastroFim,
        LocalDate dataNascimentoInicio,
        LocalDate dataNascimentoFim,
        String enderecoCidade,
        String enderecoEstado,
        String contatoEmail,
        String contatoCelular,
        String veiculoPlaca,
        String veiculoModelo
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\filter\ContatoFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: ContatoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\ContatoFilter.java
package br.com.fiap.mottu.filter;

public record ContatoFilter(
        String email,
        Integer ddd,
        Integer ddi,
        String telefone1,
        String celular,
        String observacao,
        String clienteNome // Filtro por cliente associado
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\filter\EnderecoFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: EnderecoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\EnderecoFilter.java
package br.com.fiap.mottu.filter;

public record EnderecoFilter(
        String cep,
        Integer numero,
        String logradouro,
        String bairro,
        String cidade,
        String estado,
        String pais,
        String observacao,
        String clienteNome // Filtro por cliente associado
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\filter\PatioFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: PatioFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\PatioFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record PatioFilter(
        String nomePatio,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao,
        String veiculoPlaca, // Filtro por veículo associado (via junção)
        String enderecoCidade, // Filtro por endereço associado (via junção)
        String contatoEmail, // Filtro por contato associado (via junção)
        String zonaNome // Filtro por zona associada (via junção)
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\filter\RastreamentoFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: RastreamentoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.filter;

import java.math.BigDecimal; // Importe BigDecimal!

public record RastreamentoFilter(
        BigDecimal ipsX,
        BigDecimal ipsY,
        BigDecimal ipsZ,

        BigDecimal gprsLatitude,
        BigDecimal gprsLongitude,
        BigDecimal gprsAltitude,

        String veiculoPlaca // Filtro por veículo associado
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\filter\VeiculoFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: VeiculoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\VeiculoFilter.java
package br.com.fiap.mottu.filter;

public record VeiculoFilter(
        String placa,
        String renavam,
        String chassi,
        String fabricante,
        String modelo,
        String motor,
        Integer ano,
        String combustivel,
        String clienteCpf,
        String boxNome,
        String patioNome,
        String zonaNome,
        String tagBleId // NOVO CAMPO
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\filter\ZonaFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: ZonaFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\ZonaFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record ZonaFilter(
        String nome,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao,
        String boxNome, // Filtro por box associado (via junção)
        String veiculoPlaca, // Filtro por veículo associado (via junção)
        String patioNome // Filtro por patio associado (via junção)
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\filter\BoxFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: BoxFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\BoxFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record BoxFilter(
        String nome,
        String status,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\filter\ClienteFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: ClienteFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\ClienteFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record ClienteFilter(
        String nome,
        String sobrenome,
        String cpf,
        String sexo,
        String profissao,
        String estadoCivil,
        LocalDate dataCadastroInicio,
        LocalDate dataCadastroFim,
        LocalDate dataNascimentoInicio,
        LocalDate dataNascimentoFim,
        String enderecoCidade,
        String enderecoEstado,
        String contatoEmail,
        String contatoCelular,
        String veiculoPlaca,
        String veiculoModelo
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\filter\ContatoFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: ContatoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\ContatoFilter.java
package br.com.fiap.mottu.filter;

public record ContatoFilter(
        String email,
        Integer ddd,
        Integer ddi,
        String telefone1,
        String celular,
        String observacao,
        String clienteNome // Filtro por cliente associado
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\filter\EnderecoFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: EnderecoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\EnderecoFilter.java
package br.com.fiap.mottu.filter;

public record EnderecoFilter(
        String cep,
        Integer numero,
        String logradouro,
        String bairro,
        String cidade,
        String estado,
        String pais,
        String observacao,
        String clienteNome // Filtro por cliente associado
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\filter\PatioFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: PatioFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\PatioFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record PatioFilter(
        String nomePatio,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao,
        String veiculoPlaca, // Filtro por veículo associado (via junção)
        String enderecoCidade, // Filtro por endereço associado (via junção)
        String contatoEmail, // Filtro por contato associado (via junção)
        String zonaNome // Filtro por zona associada (via junção)
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\filter\RastreamentoFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: RastreamentoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.filter;

import java.math.BigDecimal; // Importe BigDecimal!

public record RastreamentoFilter(
        BigDecimal ipsX,
        BigDecimal ipsY,
        BigDecimal ipsZ,

        BigDecimal gprsLatitude,
        BigDecimal gprsLongitude,
        BigDecimal gprsAltitude,

        String veiculoPlaca // Filtro por veículo associado
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\filter\VeiculoFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: VeiculoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\VeiculoFilter.java
package br.com.fiap.mottu.filter;

public record VeiculoFilter(
        String placa,
        String renavam,
        String chassi,
        String fabricante,
        String modelo,
        String motor,
        Integer ano,
        String combustivel,
        String clienteCpf,
        String boxNome,
        String patioNome,
        String zonaNome,
        String tagBleId // NOVO CAMPO
) {}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\filter\ZonaFilter.java   |   PACOTE: br.com.fiap.mottu.filter   |   CLASSE: ZonaFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\ZonaFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record ZonaFilter(
        String nome,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao,
        String boxNome, // Filtro por box associado (via junção)
        String veiculoPlaca, // Filtro por veículo associado (via junção)
        String patioNome // Filtro por patio associado (via junção)
) {}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.mapper
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\BoxMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: BoxMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.model.Box;
import java.time.LocalDate;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-01T09:22:18-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class BoxMapperImpl implements BoxMapper {

    @Override
    public Box toEntity(BoxRequestDto boxRequestDto) {
        if ( boxRequestDto == null ) {
            return null;
        }

        Box.BoxBuilder box = Box.builder();

        box.nome( boxRequestDto.getNome() );
        box.status( boxRequestDto.getStatus() );
        box.dataEntrada( boxRequestDto.getDataEntrada() );
        box.dataSaida( boxRequestDto.getDataSaida() );
        box.observacao( boxRequestDto.getObservacao() );

        return box.build();
    }

    @Override
    public Box partialUpdate(BoxRequestDto boxRequestDto, Box box) {
        if ( boxRequestDto == null ) {
            return box;
        }

        if ( boxRequestDto.getNome() != null ) {
            box.setNome( boxRequestDto.getNome() );
        }
        if ( boxRequestDto.getStatus() != null ) {
            box.setStatus( boxRequestDto.getStatus() );
        }
        if ( boxRequestDto.getDataEntrada() != null ) {
            box.setDataEntrada( boxRequestDto.getDataEntrada() );
        }
        if ( boxRequestDto.getDataSaida() != null ) {
            box.setDataSaida( boxRequestDto.getDataSaida() );
        }
        if ( boxRequestDto.getObservacao() != null ) {
            box.setObservacao( boxRequestDto.getObservacao() );
        }

        return box;
    }

    @Override
    public BoxResponseDto toResponseDto(Box box) {
        if ( box == null ) {
            return null;
        }

        Long idBox = null;
        String nome = null;
        String status = null;
        LocalDate dataEntrada = null;
        LocalDate dataSaida = null;
        String observacao = null;

        idBox = box.getIdBox();
        nome = box.getNome();
        status = box.getStatus();
        dataEntrada = box.getDataEntrada();
        dataSaida = box.getDataSaida();
        observacao = box.getObservacao();

        BoxResponseDto boxResponseDto = new BoxResponseDto( idBox, nome, status, dataEntrada, dataSaida, observacao );

        return boxResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\ClienteMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ClienteMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Endereco;
import java.time.LocalDate;
import javax.annotation.processing.Generated;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-01T09:22:18-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class ClienteMapperImpl implements ClienteMapper {

    @Autowired
    private EnderecoMapper enderecoMapper;
    @Autowired
    private ContatoMapper contatoMapper;

    @Override
    public Cliente toEntity(ClienteRequestDto clienteRequestDto) {
        if ( clienteRequestDto == null ) {
            return null;
        }

        Cliente.ClienteBuilder cliente = Cliente.builder();

        cliente.endereco( enderecoMapper.toEntity( clienteRequestDto.getEnderecoRequestDto() ) );
        cliente.contato( contatoMapper.toEntity( clienteRequestDto.getContatoRequestDto() ) );
        cliente.sexo( clienteRequestDto.getSexo() );
        cliente.nome( clienteRequestDto.getNome() );
        cliente.sobrenome( clienteRequestDto.getSobrenome() );
        cliente.dataNascimento( clienteRequestDto.getDataNascimento() );
        cliente.cpf( clienteRequestDto.getCpf() );
        cliente.profissao( clienteRequestDto.getProfissao() );
        cliente.estadoCivil( clienteRequestDto.getEstadoCivil() );

        return cliente.build();
    }

    @Override
    public Cliente partialUpdate(ClienteRequestDto clienteRequestDto, Cliente cliente) {
        if ( clienteRequestDto == null ) {
            return cliente;
        }

        if ( clienteRequestDto.getEnderecoRequestDto() != null ) {
            if ( cliente.getEndereco() == null ) {
                cliente.setEndereco( Endereco.builder().build() );
            }
            enderecoMapper.partialUpdate( clienteRequestDto.getEnderecoRequestDto(), cliente.getEndereco() );
        }
        if ( clienteRequestDto.getContatoRequestDto() != null ) {
            if ( cliente.getContato() == null ) {
                cliente.setContato( Contato.builder().build() );
            }
            contatoMapper.partialUpdate( clienteRequestDto.getContatoRequestDto(), cliente.getContato() );
        }
        if ( clienteRequestDto.getSexo() != null ) {
            cliente.setSexo( clienteRequestDto.getSexo() );
        }
        if ( clienteRequestDto.getNome() != null ) {
            cliente.setNome( clienteRequestDto.getNome() );
        }
        if ( clienteRequestDto.getSobrenome() != null ) {
            cliente.setSobrenome( clienteRequestDto.getSobrenome() );
        }
        if ( clienteRequestDto.getDataNascimento() != null ) {
            cliente.setDataNascimento( clienteRequestDto.getDataNascimento() );
        }
        if ( clienteRequestDto.getCpf() != null ) {
            cliente.setCpf( clienteRequestDto.getCpf() );
        }
        if ( clienteRequestDto.getProfissao() != null ) {
            cliente.setProfissao( clienteRequestDto.getProfissao() );
        }
        if ( clienteRequestDto.getEstadoCivil() != null ) {
            cliente.setEstadoCivil( clienteRequestDto.getEstadoCivil() );
        }

        return cliente;
    }

    @Override
    public ClienteResponseDto toResponseDto(Cliente cliente) {
        if ( cliente == null ) {
            return null;
        }

        EnderecoResponseDto enderecoResponseDto = null;
        ContatoResponseDto contatoResponseDto = null;
        Long idCliente = null;
        LocalDate dataCadastro = null;
        String sexo = null;
        String nome = null;
        String sobrenome = null;
        LocalDate dataNascimento = null;
        String cpf = null;
        String profissao = null;
        String estadoCivil = null;

        enderecoResponseDto = enderecoMapper.toResponseDto( cliente.getEndereco() );
        contatoResponseDto = contatoMapper.toResponseDto( cliente.getContato() );
        idCliente = cliente.getIdCliente();
        dataCadastro = cliente.getDataCadastro();
        sexo = cliente.getSexo();
        nome = cliente.getNome();
        sobrenome = cliente.getSobrenome();
        dataNascimento = cliente.getDataNascimento();
        cpf = cliente.getCpf();
        profissao = cliente.getProfissao();
        estadoCivil = cliente.getEstadoCivil();

        ClienteResponseDto clienteResponseDto = new ClienteResponseDto( idCliente, dataCadastro, sexo, nome, sobrenome, dataNascimento, cpf, profissao, estadoCivil, enderecoResponseDto, contatoResponseDto );

        return clienteResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\ContatoMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ContatoMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.model.Contato;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-01T09:22:18-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class ContatoMapperImpl implements ContatoMapper {

    @Override
    public Contato toEntity(ContatoRequestDto contatoRequestDto) {
        if ( contatoRequestDto == null ) {
            return null;
        }

        Contato.ContatoBuilder contato = Contato.builder();

        contato.email( contatoRequestDto.getEmail() );
        contato.ddd( contatoRequestDto.getDdd() );
        contato.ddi( contatoRequestDto.getDdi() );
        contato.telefone1( contatoRequestDto.getTelefone1() );
        contato.telefone2( contatoRequestDto.getTelefone2() );
        contato.telefone3( contatoRequestDto.getTelefone3() );
        contato.celular( contatoRequestDto.getCelular() );
        contato.outro( contatoRequestDto.getOutro() );
        contato.observacao( contatoRequestDto.getObservacao() );

        return contato.build();
    }

    @Override
    public Contato partialUpdate(ContatoRequestDto contatoRequestDto, Contato contato) {
        if ( contatoRequestDto == null ) {
            return contato;
        }

        if ( contatoRequestDto.getEmail() != null ) {
            contato.setEmail( contatoRequestDto.getEmail() );
        }
        if ( contatoRequestDto.getDdd() != null ) {
            contato.setDdd( contatoRequestDto.getDdd() );
        }
        if ( contatoRequestDto.getDdi() != null ) {
            contato.setDdi( contatoRequestDto.getDdi() );
        }
        if ( contatoRequestDto.getTelefone1() != null ) {
            contato.setTelefone1( contatoRequestDto.getTelefone1() );
        }
        if ( contatoRequestDto.getTelefone2() != null ) {
            contato.setTelefone2( contatoRequestDto.getTelefone2() );
        }
        if ( contatoRequestDto.getTelefone3() != null ) {
            contato.setTelefone3( contatoRequestDto.getTelefone3() );
        }
        if ( contatoRequestDto.getCelular() != null ) {
            contato.setCelular( contatoRequestDto.getCelular() );
        }
        if ( contatoRequestDto.getOutro() != null ) {
            contato.setOutro( contatoRequestDto.getOutro() );
        }
        if ( contatoRequestDto.getObservacao() != null ) {
            contato.setObservacao( contatoRequestDto.getObservacao() );
        }

        return contato;
    }

    @Override
    public ContatoResponseDto toResponseDto(Contato contato) {
        if ( contato == null ) {
            return null;
        }

        Long idContato = null;
        String email = null;
        Integer ddd = null;
        Integer ddi = null;
        String telefone1 = null;
        String telefone2 = null;
        String telefone3 = null;
        String celular = null;
        String outro = null;
        String observacao = null;

        idContato = contato.getIdContato();
        email = contato.getEmail();
        ddd = contato.getDdd();
        ddi = contato.getDdi();
        telefone1 = contato.getTelefone1();
        telefone2 = contato.getTelefone2();
        telefone3 = contato.getTelefone3();
        celular = contato.getCelular();
        outro = contato.getOutro();
        observacao = contato.getObservacao();

        ContatoResponseDto contatoResponseDto = new ContatoResponseDto( idContato, email, ddd, ddi, telefone1, telefone2, telefone3, celular, outro, observacao );

        return contatoResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\EnderecoMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: EnderecoMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.model.Endereco;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-01T09:22:18-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class EnderecoMapperImpl implements EnderecoMapper {

    @Override
    public Endereco toEntity(EnderecoRequestDto enderecoRequestDto) {
        if ( enderecoRequestDto == null ) {
            return null;
        }

        Endereco.EnderecoBuilder endereco = Endereco.builder();

        endereco.cep( enderecoRequestDto.getCep() );
        endereco.numero( enderecoRequestDto.getNumero() );
        endereco.complemento( enderecoRequestDto.getComplemento() );
        endereco.observacao( enderecoRequestDto.getObservacao() );

        return endereco.build();
    }

    @Override
    public Endereco partialUpdate(EnderecoRequestDto enderecoRequestDto, Endereco endereco) {
        if ( enderecoRequestDto == null ) {
            return endereco;
        }

        if ( enderecoRequestDto.getCep() != null ) {
            endereco.setCep( enderecoRequestDto.getCep() );
        }
        if ( enderecoRequestDto.getNumero() != null ) {
            endereco.setNumero( enderecoRequestDto.getNumero() );
        }
        if ( enderecoRequestDto.getComplemento() != null ) {
            endereco.setComplemento( enderecoRequestDto.getComplemento() );
        }
        if ( enderecoRequestDto.getObservacao() != null ) {
            endereco.setObservacao( enderecoRequestDto.getObservacao() );
        }

        return endereco;
    }

    @Override
    public EnderecoResponseDto toResponseDto(Endereco endereco) {
        if ( endereco == null ) {
            return null;
        }

        Long idEndereco = null;
        String cep = null;
        Integer numero = null;
        String logradouro = null;
        String bairro = null;
        String cidade = null;
        String estado = null;
        String pais = null;
        String complemento = null;
        String observacao = null;

        idEndereco = endereco.getIdEndereco();
        cep = endereco.getCep();
        numero = endereco.getNumero();
        logradouro = endereco.getLogradouro();
        bairro = endereco.getBairro();
        cidade = endereco.getCidade();
        estado = endereco.getEstado();
        pais = endereco.getPais();
        complemento = endereco.getComplemento();
        observacao = endereco.getObservacao();

        EnderecoResponseDto enderecoResponseDto = new EnderecoResponseDto( idEndereco, cep, numero, logradouro, bairro, cidade, estado, pais, complemento, observacao );

        return enderecoResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\PatioMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: PatioMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.model.Patio;
import java.time.LocalDate;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-01T09:22:18-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class PatioMapperImpl implements PatioMapper {

    @Override
    public Patio toEntity(PatioRequestDto patioRequestDto) {
        if ( patioRequestDto == null ) {
            return null;
        }

        Patio.PatioBuilder patio = Patio.builder();

        patio.nomePatio( patioRequestDto.getNomePatio() );
        patio.dataEntrada( patioRequestDto.getDataEntrada() );
        patio.dataSaida( patioRequestDto.getDataSaida() );
        patio.observacao( patioRequestDto.getObservacao() );

        return patio.build();
    }

    @Override
    public Patio partialUpdate(PatioRequestDto patioRequestDto, Patio patio) {
        if ( patioRequestDto == null ) {
            return patio;
        }

        if ( patioRequestDto.getNomePatio() != null ) {
            patio.setNomePatio( patioRequestDto.getNomePatio() );
        }
        if ( patioRequestDto.getDataEntrada() != null ) {
            patio.setDataEntrada( patioRequestDto.getDataEntrada() );
        }
        if ( patioRequestDto.getDataSaida() != null ) {
            patio.setDataSaida( patioRequestDto.getDataSaida() );
        }
        if ( patioRequestDto.getObservacao() != null ) {
            patio.setObservacao( patioRequestDto.getObservacao() );
        }

        return patio;
    }

    @Override
    public PatioResponseDto toResponseDto(Patio patio) {
        if ( patio == null ) {
            return null;
        }

        Long idPatio = null;
        String nomePatio = null;
        LocalDate dataEntrada = null;
        LocalDate dataSaida = null;
        String observacao = null;

        idPatio = patio.getIdPatio();
        nomePatio = patio.getNomePatio();
        dataEntrada = patio.getDataEntrada();
        dataSaida = patio.getDataSaida();
        observacao = patio.getObservacao();

        PatioResponseDto patioResponseDto = new PatioResponseDto( idPatio, nomePatio, dataEntrada, dataSaida, observacao );

        return patioResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\RastreamentoMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: RastreamentoMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.model.Rastreamento;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-01T09:22:18-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class RastreamentoMapperImpl implements RastreamentoMapper {

    @Override
    public Rastreamento toEntity(RastreamentoRequestDto rastreamentoRequestDto) {
        if ( rastreamentoRequestDto == null ) {
            return null;
        }

        Rastreamento.RastreamentoBuilder rastreamento = Rastreamento.builder();

        rastreamento.ipsX( rastreamentoRequestDto.getIpsX() );
        rastreamento.ipsY( rastreamentoRequestDto.getIpsY() );
        rastreamento.ipsZ( rastreamentoRequestDto.getIpsZ() );
        rastreamento.gprsLatitude( rastreamentoRequestDto.getGprsLatitude() );
        rastreamento.gprsLongitude( rastreamentoRequestDto.getGprsLongitude() );
        rastreamento.gprsAltitude( rastreamentoRequestDto.getGprsAltitude() );

        return rastreamento.build();
    }

    @Override
    public Rastreamento partialUpdate(RastreamentoRequestDto dto, Rastreamento rastreamento) {
        if ( dto == null ) {
            return rastreamento;
        }

        if ( dto.getIpsX() != null ) {
            rastreamento.setIpsX( dto.getIpsX() );
        }
        if ( dto.getIpsY() != null ) {
            rastreamento.setIpsY( dto.getIpsY() );
        }
        if ( dto.getIpsZ() != null ) {
            rastreamento.setIpsZ( dto.getIpsZ() );
        }
        if ( dto.getGprsLatitude() != null ) {
            rastreamento.setGprsLatitude( dto.getGprsLatitude() );
        }
        if ( dto.getGprsLongitude() != null ) {
            rastreamento.setGprsLongitude( dto.getGprsLongitude() );
        }
        if ( dto.getGprsAltitude() != null ) {
            rastreamento.setGprsAltitude( dto.getGprsAltitude() );
        }

        return rastreamento;
    }

    @Override
    public RastreamentoResponseDto toResponseDto(Rastreamento rastreamento) {
        if ( rastreamento == null ) {
            return null;
        }

        Long idRastreamento = null;
        BigDecimal ipsX = null;
        BigDecimal ipsY = null;
        BigDecimal ipsZ = null;
        BigDecimal gprsLatitude = null;
        BigDecimal gprsLongitude = null;
        BigDecimal gprsAltitude = null;
        LocalDateTime dataHoraRegistro = null;

        idRastreamento = rastreamento.getIdRastreamento();
        ipsX = rastreamento.getIpsX();
        ipsY = rastreamento.getIpsY();
        ipsZ = rastreamento.getIpsZ();
        gprsLatitude = rastreamento.getGprsLatitude();
        gprsLongitude = rastreamento.getGprsLongitude();
        gprsAltitude = rastreamento.getGprsAltitude();
        dataHoraRegistro = rastreamento.getDataHoraRegistro();

        RastreamentoResponseDto rastreamentoResponseDto = new RastreamentoResponseDto( idRastreamento, ipsX, ipsY, ipsZ, gprsLatitude, gprsLongitude, gprsAltitude, dataHoraRegistro );

        return rastreamentoResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\VeiculoMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: VeiculoMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.model.Veiculo;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-01T09:22:18-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class VeiculoMapperImpl implements VeiculoMapper {

    @Override
    public Veiculo toEntity(VeiculoRequestDto veiculoRequestDto) {
        if ( veiculoRequestDto == null ) {
            return null;
        }

        Veiculo.VeiculoBuilder veiculo = Veiculo.builder();

        veiculo.tagBleId( veiculoRequestDto.getTagBleId() );
        veiculo.status( veiculoRequestDto.getStatus() );
        veiculo.placa( veiculoRequestDto.getPlaca() );
        veiculo.renavam( veiculoRequestDto.getRenavam() );
        veiculo.chassi( veiculoRequestDto.getChassi() );
        veiculo.fabricante( veiculoRequestDto.getFabricante() );
        veiculo.modelo( veiculoRequestDto.getModelo() );
        veiculo.motor( veiculoRequestDto.getMotor() );
        veiculo.ano( veiculoRequestDto.getAno() );
        veiculo.combustivel( veiculoRequestDto.getCombustivel() );

        return veiculo.build();
    }

    @Override
    public Veiculo partialUpdate(VeiculoRequestDto veiculoRequestDto, Veiculo veiculo) {
        if ( veiculoRequestDto == null ) {
            return veiculo;
        }

        if ( veiculoRequestDto.getTagBleId() != null ) {
            veiculo.setTagBleId( veiculoRequestDto.getTagBleId() );
        }
        if ( veiculoRequestDto.getStatus() != null ) {
            veiculo.setStatus( veiculoRequestDto.getStatus() );
        }
        if ( veiculoRequestDto.getPlaca() != null ) {
            veiculo.setPlaca( veiculoRequestDto.getPlaca() );
        }
        if ( veiculoRequestDto.getRenavam() != null ) {
            veiculo.setRenavam( veiculoRequestDto.getRenavam() );
        }
        if ( veiculoRequestDto.getChassi() != null ) {
            veiculo.setChassi( veiculoRequestDto.getChassi() );
        }
        if ( veiculoRequestDto.getFabricante() != null ) {
            veiculo.setFabricante( veiculoRequestDto.getFabricante() );
        }
        if ( veiculoRequestDto.getModelo() != null ) {
            veiculo.setModelo( veiculoRequestDto.getModelo() );
        }
        if ( veiculoRequestDto.getMotor() != null ) {
            veiculo.setMotor( veiculoRequestDto.getMotor() );
        }
        if ( veiculoRequestDto.getAno() != null ) {
            veiculo.setAno( veiculoRequestDto.getAno() );
        }
        if ( veiculoRequestDto.getCombustivel() != null ) {
            veiculo.setCombustivel( veiculoRequestDto.getCombustivel() );
        }

        return veiculo;
    }

    @Override
    public VeiculoResponseDto toResponseDto(Veiculo veiculo) {
        if ( veiculo == null ) {
            return null;
        }

        String tagBleId = null;
        String status = null;
        Long idVeiculo = null;
        String placa = null;
        String renavam = null;
        String chassi = null;
        String fabricante = null;
        String modelo = null;
        String motor = null;
        Integer ano = null;
        String combustivel = null;

        tagBleId = veiculo.getTagBleId();
        status = veiculo.getStatus();
        idVeiculo = veiculo.getIdVeiculo();
        placa = veiculo.getPlaca();
        renavam = veiculo.getRenavam();
        chassi = veiculo.getChassi();
        fabricante = veiculo.getFabricante();
        modelo = veiculo.getModelo();
        motor = veiculo.getMotor();
        ano = veiculo.getAno();
        combustivel = veiculo.getCombustivel();

        VeiculoResponseDto veiculoResponseDto = new VeiculoResponseDto( idVeiculo, placa, renavam, chassi, fabricante, modelo, motor, ano, combustivel, tagBleId, status );

        return veiculoResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\ZonaMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ZonaMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.model.Zona;
import java.time.LocalDate;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-01T09:22:18-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class ZonaMapperImpl implements ZonaMapper {

    @Override
    public Zona toEntity(ZonaRequestDto zonaRequestDto) {
        if ( zonaRequestDto == null ) {
            return null;
        }

        Zona.ZonaBuilder zona = Zona.builder();

        zona.nome( zonaRequestDto.getNome() );
        zona.dataEntrada( zonaRequestDto.getDataEntrada() );
        zona.dataSaida( zonaRequestDto.getDataSaida() );
        zona.observacao( zonaRequestDto.getObservacao() );

        return zona.build();
    }

    @Override
    public Zona partialUpdate(ZonaRequestDto zonaRequestDto, Zona zona) {
        if ( zonaRequestDto == null ) {
            return zona;
        }

        if ( zonaRequestDto.getNome() != null ) {
            zona.setNome( zonaRequestDto.getNome() );
        }
        if ( zonaRequestDto.getDataEntrada() != null ) {
            zona.setDataEntrada( zonaRequestDto.getDataEntrada() );
        }
        if ( zonaRequestDto.getDataSaida() != null ) {
            zona.setDataSaida( zonaRequestDto.getDataSaida() );
        }
        if ( zonaRequestDto.getObservacao() != null ) {
            zona.setObservacao( zonaRequestDto.getObservacao() );
        }

        return zona;
    }

    @Override
    public ZonaResponseDto toResponseDto(Zona zona) {
        if ( zona == null ) {
            return null;
        }

        Long idZona = null;
        String nome = null;
        LocalDate dataEntrada = null;
        LocalDate dataSaida = null;
        String observacao = null;

        idZona = zona.getIdZona();
        nome = zona.getNome();
        dataEntrada = zona.getDataEntrada();
        dataSaida = zona.getDataSaida();
        observacao = zona.getObservacao();

        ZonaResponseDto zonaResponseDto = new ZonaResponseDto( idZona, nome, dataEntrada, dataSaida, observacao );

        return zonaResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\BoxMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: BoxMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.model.Box;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        uses = {PatioMapper.class} // NOVO: Adicionar PatioMapper aqui, se necessário para o DTO (não estritamente necessário para esta feature, mas boa prática para o gráfico de dependências)
)
public interface BoxMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idBox", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Box toEntity(BoxRequestDto boxRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de um Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idBox", ignore = true) // ID não é atualizado
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Box partialUpdate(BoxRequestDto boxRequestDto, @MappingTarget Box box);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    BoxResponseDto toResponseDto(Box box);
    // --- Métodos para mapear coleções (opcional) ---
    // List<BoxResponseDto> toResponseDtoList(List<Box> boxes);
    // Set<BoxResponseDto> toResponseDtoSet(Set<Box> boxes);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\ClienteMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ClienteMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\ClienteMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto;
import br.com.fiap.mottu.model.Cliente;

// Importe os mappers para os DTOs aninhados
import br.com.fiap.mottu.mapper.EnderecoMapper;
import br.com.fiap.mottu.mapper.ContatoMapper;
// Importar mapper para VeiculoResponseDto se ClienteResponseDto for incluí-lo
// import br.com.fiap.mottu.mapper.relacionamento.ClienteVeiculoMapper;
// import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // Para mapear para VeiculoResponseDto

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

import java.util.Set; // Necessário para mapear coleções
import java.util.stream.Collectors; // Necessário para stream() e collect()

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        // Adiciona os mappers para os DTOs aninhados (Endereco e Contato)
        uses = { EnderecoMapper.class, ContatoMapper.class }
        // Se for mapear Set<ClienteVeiculo> para Set<VeiculoResponseDto>, precisará de um Mapper que faça isso.
        // Ex: uses = { EnderecoMapper.class, ContatoMapper.class, ClienteVeiculoMapper.class }
)
public interface ClienteMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    // Mapeia ClienteRequestDto -> Cliente
    @Mapping(target = "idCliente", ignore = true) // ID é gerado pelo BD, ignore ao mapear Request para Entidade
    // @Mapping(target = "dataCadastro", ignore = true) // dataCadastro é gerada pelo BD (DEFAULT SYSDATE), ignore ao mapear Request para Entidade
    @Mapping(target = "endereco", source = "enderecoRequestDto") // Mapeia o DTO de Endereco aninhado para a Entidade Endereco
    @Mapping(target = "contato", source = "contatoRequestDto") // Mapeia o DTO de Contato aninhado para a Entidade Contato
    @Mapping(target = "clienteVeiculos", ignore = true) // Relação Many-to-Many não é criada diretamente aqui
    Cliente toEntity(ClienteRequestDto clienteRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de um Request DTO
    // Mapeia ClienteRequestDto -> Cliente (existente)
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idCliente", ignore = true) // ID não é atualizado pelo DTO
    @Mapping(target = "dataCadastro", ignore = true) // Data de cadastro não é atualizada pelo DTO
    @Mapping(target = "endereco", source = "enderecoRequestDto") // Mapeia o DTO de Endereco aninhado para a Entidade Endereco existente no Cliente
    @Mapping(target = "contato", source = "contatoRequestDto") // Mapeia o DTO de Contato aninhado para a Entidade Contato existente no Cliente
    @Mapping(target = "clienteVeiculos", ignore = true) // Relação Many-to-Many não é atualizada diretamente aqui
    Cliente partialUpdate(ClienteRequestDto clienteRequestDto, @MappingTarget Cliente cliente);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    // Mapeia Cliente -> ClienteResponseDto
    @Mapping(target = "enderecoResponseDto", source = "endereco") // Mapeia a Entidade Endereco para o DTO de Endereco aninhado no Response
    @Mapping(target = "contatoResponseDto", source = "contato") // Mapeia a Entidade Contato para o DTO de Contato aninhado no Response
    // Se ClienteResponseDto tiver campos de coleções (ex: Set<VeiculoResponseDto> veiculos)
    // Você precisaria de um método @Named para fazer essa conversão se ClienteVeiculoMapper não for suficiente,
    // ou um método diretamente no mapper se a lógica for simples.
    // Exemplo: @Mapping(target = "veiculos", expression = "java(mapClienteVeiculosToVeiculoResponseDtos(cliente.getClienteVeiculos()))")
    ClienteResponseDto toResponseDto(Cliente cliente);

    // Exemplo de método para mapear Set<ClienteVeiculo> para Set<VeiculoResponseDto>
    // Este método pode ser um @Named ou um método privado na interface se for Java 8 default methods
    /*
    default Set<VeiculoResponseDto> mapClienteVeiculosToVeiculoResponseDtos(Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos) {
        if (clienteVeiculos == null) {
            return null;
        }
        // Assume que você tem um VeiculoMapper injetável para converter Veiculo para VeiculoResponseDto
        // Ou que o ClienteVeiculoMapper tem um método para mapear para VeiculoResponseDto
        return clienteVeiculos.stream()
                .map(ClienteVeiculo::getVeiculo) // Pega a entidade Veiculo da associação
                .map(veiculo -> SpringApplicationContext.getBean(VeiculoMapper.class).toResponseDto(veiculo)) // Necessita de um mecanismo para obter o bean do mapper
                .collect(Collectors.toSet());
    }
    */

    // --- Métodos para mapear coleções (opcional) ---
    // List<ClienteResponseDto> toResponseDtoList(List<Cliente> clientes);
    // Set<ClienteResponseDto> toResponseDtoSet(Set<Cliente> clientes);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\ContatoMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ContatoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\ContatoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.model.Contato;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se ContatoResponseDto tiver DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.ClienteMapper; // Exemplo se ContatoResponseDto incluir Cliente associado
// import br.com.fiap.mottu.mapper.relacionamento.ContatoPatioMapper; // Exemplo se ContatoResponseDto incluir Patio associado

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se ContatoResponseDto incluir DTOs aninhados ou coleções
        // uses = { ClienteMapper.class, ContatoPatioMapper.class }
)
public interface ContatoMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idContato", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "clienteContatos", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    Contato toEntity(ContatoRequestDto contatoRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idContato", ignore = true) // ID não é atualizado
    @Mapping(target = "clienteContatos", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é atualizado
    Contato partialUpdate(ContatoRequestDto contatoRequestDto, @MappingTarget Contato contato);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    ContatoResponseDto toResponseDto(Contato contato);

    // --- Métodos para mapear coleções (opcional) ---
    // List<ContatoResponseDto> toResponseDtoList(List<Contato> contatos);
    // Set<ContatoResponseDto> toResponseDtoSet(Set<Contato> contatos);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\EnderecoMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: EnderecoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\EnderecoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.model.Endereco;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se EnderecoResponseDto tiver DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.ClienteMapper; // Exemplo se EnderecoResponseDto incluir Cliente associado
// import br.com.fiap.mottu.mapper.relacionamento.EnderecoPatioMapper; // Exemplo se EnderecoResponseDto incluir Patio associado

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se EnderecoResponseDto incluir DTOs aninhados ou coleções
        // uses = { ClienteMapper.class, EnderecoPatioMapper.class }
)
public interface EnderecoMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idEndereco", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "clienteEnderecos", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    Endereco toEntity(EnderecoRequestDto enderecoRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idEndereco", ignore = true) // ID não é atualizado
    @Mapping(target = "clienteEnderecos", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é atualizado
    Endereco partialUpdate(EnderecoRequestDto enderecoRequestDto, @MappingTarget Endereco endereco);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    EnderecoResponseDto toResponseDto(Endereco endereco);

    // --- Métodos para mapear coleções (opcional) ---
    // List<EnderecoResponseDto> toResponseDtoList(List<Endereco> enderecos);
    // Set<EnderecoResponseDto> toResponseDtoSet(Set<Endereco> enderecos);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\PatioMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: PatioMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.model.Patio;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        uses = {BoxMapper.class} // NOVO: Adicionar BoxMapper aqui
)
public interface PatioMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idPatio", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Patio toEntity(PatioRequestDto patioRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idPatio", ignore = true) // ID não é atualizado
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Patio partialUpdate(PatioRequestDto patioRequestDto, @MappingTarget Patio patio);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    PatioResponseDto toResponseDto(Patio patio);
    // List<PatioResponseDto> toResponseDtoList(List<Patio> patios);
    // Set<PatioResponseDto> toResponseDtoSet(Set<Patio> patios);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\RastreamentoMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: RastreamentoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto; // DTO para requisições de criação/atualização
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto; // DTO para respostas
import br.com.fiap.mottu.model.Rastreamento; // Entidade Rastreamento
import org.mapstruct.*; // Importações do MapStruct para mapeamento de objetos
import org.mapstruct.ReportingPolicy; // Define como lidar com mapeamentos não mapeados
import org.mapstruct.MappingConstants; // Constantes do MapStruct

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE, // Ignora campos não mapeados no destino
        componentModel = MappingConstants.ComponentModel.SPRING // Integração com Spring (gera um bean)
)
public interface RastreamentoMapper {

    // Mapeia de RastreamentoRequestDto para a entidade Rastreamento
    @Mapping(target = "idRastreamento", ignore = true) // ID é gerado pelo banco, não vem no request
    @Mapping(target = "veiculoRastreamentos", ignore = true) // Relacionamentos são gerenciados separadamente
    @Mapping(target = "dataHoraRegistro", ignore = true) // Será gerado automaticamente na criação pela JPA/Hibernate
    Rastreamento toEntity(RastreamentoRequestDto rastreamentoRequestDto);

    // Atualiza uma entidade Rastreamento existente com dados de um RastreamentoRequestDto
    // Apenas campos não nulos no DTO serão usados para atualizar a entidade
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idRastreamento", ignore = true) // ID não deve ser atualizado
    @Mapping(target = "veiculoRastreamentos", ignore = true) // Relacionamentos não são atualizados por este DTO diretamente
    @Mapping(target = "dataHoraRegistro", ignore = true) // Data de registro não deve ser atualizada
    Rastreamento partialUpdate(RastreamentoRequestDto dto, @MappingTarget Rastreamento rastreamento);

    // Mapeia da entidade Rastreamento para RastreamentoResponseDto
    // O campo dataHoraRegistro será mapeado automaticamente pois os nomes coincidem
    RastreamentoResponseDto toResponseDto(Rastreamento rastreamento);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\VeiculoMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: VeiculoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.model.Veiculo;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
)
public interface VeiculoMapper {

    @Mapping(target = "idVeiculo", ignore = true)
    @Mapping(target = "clienteVeiculos", ignore = true)
    @Mapping(target = "veiculoBoxes", ignore = true)
    @Mapping(target = "veiculoPatios", ignore = true)
    @Mapping(target = "veiculoRastreamentos", ignore = true)
    @Mapping(target = "veiculoZonas", ignore = true)
    // Mapeia diretamente o campo tagBleId do DTO para a entidade
    @Mapping(source = "tagBleId", target = "tagBleId")
    @Mapping(source = "status", target = "status")
    Veiculo toEntity(VeiculoRequestDto veiculoRequestDto);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idVeiculo", ignore = true)
    @Mapping(target = "clienteVeiculos", ignore = true)
    @Mapping(target = "veiculoBoxes", ignore = true)
    @Mapping(target = "veiculoPatios", ignore = true)
    @Mapping(target = "veiculoRastreamentos", ignore = true)
    @Mapping(target = "veiculoZonas", ignore = true)
    // Mapeia diretamente o campo tagBleId do DTO para a entidade
    @Mapping(source = "tagBleId", target = "tagBleId")
    @Mapping(source = "status", target = "status")
    Veiculo partialUpdate(VeiculoRequestDto veiculoRequestDto, @MappingTarget Veiculo veiculo);

    // Mapeia diretamente o campo tagBleId da entidade para o DTO de resposta
    @Mapping(source = "tagBleId", target = "tagBleId")
    @Mapping(source = "status", target = "status")
    VeiculoResponseDto toResponseDto(Veiculo veiculo);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\ZonaMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ZonaMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\ZonaMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.model.Zona;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se ZonaRequestDto ou ZonaResponseDto tiverem DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoZonaMapper;
// import br.com.fiap.mottu.mapper.relacionamento.ZonaBoxMapper;
// import br.com.fiap.mottu.mapper.relacionamento.ZonaPatioMapper;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se ZonaRequestDto ou ZonaResponseDto incluirem DTOs aninhados ou coleções
        // uses = { VeiculoZonaMapper.class, ZonaBoxMapper.class, ZonaPatioMapper.class }
)
public interface ZonaMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idZona", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    Zona toEntity(ZonaRequestDto zonaRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idZona", ignore = true) // ID não é atualizado
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é atualizado
    Zona partialUpdate(ZonaRequestDto zonaRequestDto, @MappingTarget Zona zona);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    ZonaResponseDto toResponseDto(Zona zona);

    // --- Métodos para mapear coleções (opcional) ---
    // List<ZonaResponseDto> toResponseDtoList(List<Zona> zonas);
    // Set<ZonaResponseDto> toResponseDtoSet(Set<Zona> zonas);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\BoxMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: BoxMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.model.Box;
import java.time.LocalDate;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-10T13:45:33-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class BoxMapperImpl implements BoxMapper {

    @Override
    public Box toEntity(BoxRequestDto boxRequestDto) {
        if ( boxRequestDto == null ) {
            return null;
        }

        Box.BoxBuilder box = Box.builder();

        box.nome( boxRequestDto.getNome() );
        box.status( boxRequestDto.getStatus() );
        box.dataEntrada( boxRequestDto.getDataEntrada() );
        box.dataSaida( boxRequestDto.getDataSaida() );
        box.observacao( boxRequestDto.getObservacao() );

        return box.build();
    }

    @Override
    public Box partialUpdate(BoxRequestDto boxRequestDto, Box box) {
        if ( boxRequestDto == null ) {
            return box;
        }

        if ( boxRequestDto.getNome() != null ) {
            box.setNome( boxRequestDto.getNome() );
        }
        if ( boxRequestDto.getStatus() != null ) {
            box.setStatus( boxRequestDto.getStatus() );
        }
        if ( boxRequestDto.getDataEntrada() != null ) {
            box.setDataEntrada( boxRequestDto.getDataEntrada() );
        }
        if ( boxRequestDto.getDataSaida() != null ) {
            box.setDataSaida( boxRequestDto.getDataSaida() );
        }
        if ( boxRequestDto.getObservacao() != null ) {
            box.setObservacao( boxRequestDto.getObservacao() );
        }

        return box;
    }

    @Override
    public BoxResponseDto toResponseDto(Box box) {
        if ( box == null ) {
            return null;
        }

        Long idBox = null;
        String nome = null;
        String status = null;
        LocalDate dataEntrada = null;
        LocalDate dataSaida = null;
        String observacao = null;

        idBox = box.getIdBox();
        nome = box.getNome();
        status = box.getStatus();
        dataEntrada = box.getDataEntrada();
        dataSaida = box.getDataSaida();
        observacao = box.getObservacao();

        BoxResponseDto boxResponseDto = new BoxResponseDto( idBox, nome, status, dataEntrada, dataSaida, observacao );

        return boxResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\ClienteMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ClienteMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Endereco;
import java.time.LocalDate;
import javax.annotation.processing.Generated;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-10T13:45:32-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class ClienteMapperImpl implements ClienteMapper {

    @Autowired
    private EnderecoMapper enderecoMapper;
    @Autowired
    private ContatoMapper contatoMapper;

    @Override
    public Cliente toEntity(ClienteRequestDto clienteRequestDto) {
        if ( clienteRequestDto == null ) {
            return null;
        }

        Cliente.ClienteBuilder cliente = Cliente.builder();

        cliente.endereco( enderecoMapper.toEntity( clienteRequestDto.getEnderecoRequestDto() ) );
        cliente.contato( contatoMapper.toEntity( clienteRequestDto.getContatoRequestDto() ) );
        cliente.sexo( clienteRequestDto.getSexo() );
        cliente.nome( clienteRequestDto.getNome() );
        cliente.sobrenome( clienteRequestDto.getSobrenome() );
        cliente.dataNascimento( clienteRequestDto.getDataNascimento() );
        cliente.cpf( clienteRequestDto.getCpf() );
        cliente.profissao( clienteRequestDto.getProfissao() );
        cliente.estadoCivil( clienteRequestDto.getEstadoCivil() );

        return cliente.build();
    }

    @Override
    public Cliente partialUpdate(ClienteRequestDto clienteRequestDto, Cliente cliente) {
        if ( clienteRequestDto == null ) {
            return cliente;
        }

        if ( clienteRequestDto.getEnderecoRequestDto() != null ) {
            if ( cliente.getEndereco() == null ) {
                cliente.setEndereco( Endereco.builder().build() );
            }
            enderecoMapper.partialUpdate( clienteRequestDto.getEnderecoRequestDto(), cliente.getEndereco() );
        }
        if ( clienteRequestDto.getContatoRequestDto() != null ) {
            if ( cliente.getContato() == null ) {
                cliente.setContato( Contato.builder().build() );
            }
            contatoMapper.partialUpdate( clienteRequestDto.getContatoRequestDto(), cliente.getContato() );
        }
        if ( clienteRequestDto.getSexo() != null ) {
            cliente.setSexo( clienteRequestDto.getSexo() );
        }
        if ( clienteRequestDto.getNome() != null ) {
            cliente.setNome( clienteRequestDto.getNome() );
        }
        if ( clienteRequestDto.getSobrenome() != null ) {
            cliente.setSobrenome( clienteRequestDto.getSobrenome() );
        }
        if ( clienteRequestDto.getDataNascimento() != null ) {
            cliente.setDataNascimento( clienteRequestDto.getDataNascimento() );
        }
        if ( clienteRequestDto.getCpf() != null ) {
            cliente.setCpf( clienteRequestDto.getCpf() );
        }
        if ( clienteRequestDto.getProfissao() != null ) {
            cliente.setProfissao( clienteRequestDto.getProfissao() );
        }
        if ( clienteRequestDto.getEstadoCivil() != null ) {
            cliente.setEstadoCivil( clienteRequestDto.getEstadoCivil() );
        }

        return cliente;
    }

    @Override
    public ClienteResponseDto toResponseDto(Cliente cliente) {
        if ( cliente == null ) {
            return null;
        }

        EnderecoResponseDto enderecoResponseDto = null;
        ContatoResponseDto contatoResponseDto = null;
        Long idCliente = null;
        LocalDate dataCadastro = null;
        String sexo = null;
        String nome = null;
        String sobrenome = null;
        LocalDate dataNascimento = null;
        String cpf = null;
        String profissao = null;
        String estadoCivil = null;

        enderecoResponseDto = enderecoMapper.toResponseDto( cliente.getEndereco() );
        contatoResponseDto = contatoMapper.toResponseDto( cliente.getContato() );
        idCliente = cliente.getIdCliente();
        dataCadastro = cliente.getDataCadastro();
        sexo = cliente.getSexo();
        nome = cliente.getNome();
        sobrenome = cliente.getSobrenome();
        dataNascimento = cliente.getDataNascimento();
        cpf = cliente.getCpf();
        profissao = cliente.getProfissao();
        estadoCivil = cliente.getEstadoCivil();

        ClienteResponseDto clienteResponseDto = new ClienteResponseDto( idCliente, dataCadastro, sexo, nome, sobrenome, dataNascimento, cpf, profissao, estadoCivil, enderecoResponseDto, contatoResponseDto );

        return clienteResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\ContatoMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ContatoMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.model.Contato;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-10T13:45:33-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class ContatoMapperImpl implements ContatoMapper {

    @Override
    public Contato toEntity(ContatoRequestDto contatoRequestDto) {
        if ( contatoRequestDto == null ) {
            return null;
        }

        Contato.ContatoBuilder contato = Contato.builder();

        contato.email( contatoRequestDto.getEmail() );
        contato.ddd( contatoRequestDto.getDdd() );
        contato.ddi( contatoRequestDto.getDdi() );
        contato.telefone1( contatoRequestDto.getTelefone1() );
        contato.telefone2( contatoRequestDto.getTelefone2() );
        contato.telefone3( contatoRequestDto.getTelefone3() );
        contato.celular( contatoRequestDto.getCelular() );
        contato.outro( contatoRequestDto.getOutro() );
        contato.observacao( contatoRequestDto.getObservacao() );

        return contato.build();
    }

    @Override
    public Contato partialUpdate(ContatoRequestDto contatoRequestDto, Contato contato) {
        if ( contatoRequestDto == null ) {
            return contato;
        }

        if ( contatoRequestDto.getEmail() != null ) {
            contato.setEmail( contatoRequestDto.getEmail() );
        }
        if ( contatoRequestDto.getDdd() != null ) {
            contato.setDdd( contatoRequestDto.getDdd() );
        }
        if ( contatoRequestDto.getDdi() != null ) {
            contato.setDdi( contatoRequestDto.getDdi() );
        }
        if ( contatoRequestDto.getTelefone1() != null ) {
            contato.setTelefone1( contatoRequestDto.getTelefone1() );
        }
        if ( contatoRequestDto.getTelefone2() != null ) {
            contato.setTelefone2( contatoRequestDto.getTelefone2() );
        }
        if ( contatoRequestDto.getTelefone3() != null ) {
            contato.setTelefone3( contatoRequestDto.getTelefone3() );
        }
        if ( contatoRequestDto.getCelular() != null ) {
            contato.setCelular( contatoRequestDto.getCelular() );
        }
        if ( contatoRequestDto.getOutro() != null ) {
            contato.setOutro( contatoRequestDto.getOutro() );
        }
        if ( contatoRequestDto.getObservacao() != null ) {
            contato.setObservacao( contatoRequestDto.getObservacao() );
        }

        return contato;
    }

    @Override
    public ContatoResponseDto toResponseDto(Contato contato) {
        if ( contato == null ) {
            return null;
        }

        Long idContato = null;
        String email = null;
        Integer ddd = null;
        Integer ddi = null;
        String telefone1 = null;
        String telefone2 = null;
        String telefone3 = null;
        String celular = null;
        String outro = null;
        String observacao = null;

        idContato = contato.getIdContato();
        email = contato.getEmail();
        ddd = contato.getDdd();
        ddi = contato.getDdi();
        telefone1 = contato.getTelefone1();
        telefone2 = contato.getTelefone2();
        telefone3 = contato.getTelefone3();
        celular = contato.getCelular();
        outro = contato.getOutro();
        observacao = contato.getObservacao();

        ContatoResponseDto contatoResponseDto = new ContatoResponseDto( idContato, email, ddd, ddi, telefone1, telefone2, telefone3, celular, outro, observacao );

        return contatoResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\EnderecoMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: EnderecoMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.model.Endereco;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-10T13:45:33-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class EnderecoMapperImpl implements EnderecoMapper {

    @Override
    public Endereco toEntity(EnderecoRequestDto enderecoRequestDto) {
        if ( enderecoRequestDto == null ) {
            return null;
        }

        Endereco.EnderecoBuilder endereco = Endereco.builder();

        endereco.cep( enderecoRequestDto.getCep() );
        endereco.numero( enderecoRequestDto.getNumero() );
        endereco.complemento( enderecoRequestDto.getComplemento() );
        endereco.observacao( enderecoRequestDto.getObservacao() );

        return endereco.build();
    }

    @Override
    public Endereco partialUpdate(EnderecoRequestDto enderecoRequestDto, Endereco endereco) {
        if ( enderecoRequestDto == null ) {
            return endereco;
        }

        if ( enderecoRequestDto.getCep() != null ) {
            endereco.setCep( enderecoRequestDto.getCep() );
        }
        if ( enderecoRequestDto.getNumero() != null ) {
            endereco.setNumero( enderecoRequestDto.getNumero() );
        }
        if ( enderecoRequestDto.getComplemento() != null ) {
            endereco.setComplemento( enderecoRequestDto.getComplemento() );
        }
        if ( enderecoRequestDto.getObservacao() != null ) {
            endereco.setObservacao( enderecoRequestDto.getObservacao() );
        }

        return endereco;
    }

    @Override
    public EnderecoResponseDto toResponseDto(Endereco endereco) {
        if ( endereco == null ) {
            return null;
        }

        Long idEndereco = null;
        String cep = null;
        Integer numero = null;
        String logradouro = null;
        String bairro = null;
        String cidade = null;
        String estado = null;
        String pais = null;
        String complemento = null;
        String observacao = null;

        idEndereco = endereco.getIdEndereco();
        cep = endereco.getCep();
        numero = endereco.getNumero();
        logradouro = endereco.getLogradouro();
        bairro = endereco.getBairro();
        cidade = endereco.getCidade();
        estado = endereco.getEstado();
        pais = endereco.getPais();
        complemento = endereco.getComplemento();
        observacao = endereco.getObservacao();

        EnderecoResponseDto enderecoResponseDto = new EnderecoResponseDto( idEndereco, cep, numero, logradouro, bairro, cidade, estado, pais, complemento, observacao );

        return enderecoResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\PatioMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: PatioMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.model.Patio;
import java.time.LocalDate;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-10T13:45:33-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class PatioMapperImpl implements PatioMapper {

    @Override
    public Patio toEntity(PatioRequestDto patioRequestDto) {
        if ( patioRequestDto == null ) {
            return null;
        }

        Patio.PatioBuilder patio = Patio.builder();

        patio.nomePatio( patioRequestDto.getNomePatio() );
        patio.dataEntrada( patioRequestDto.getDataEntrada() );
        patio.dataSaida( patioRequestDto.getDataSaida() );
        patio.observacao( patioRequestDto.getObservacao() );

        return patio.build();
    }

    @Override
    public Patio partialUpdate(PatioRequestDto patioRequestDto, Patio patio) {
        if ( patioRequestDto == null ) {
            return patio;
        }

        if ( patioRequestDto.getNomePatio() != null ) {
            patio.setNomePatio( patioRequestDto.getNomePatio() );
        }
        if ( patioRequestDto.getDataEntrada() != null ) {
            patio.setDataEntrada( patioRequestDto.getDataEntrada() );
        }
        if ( patioRequestDto.getDataSaida() != null ) {
            patio.setDataSaida( patioRequestDto.getDataSaida() );
        }
        if ( patioRequestDto.getObservacao() != null ) {
            patio.setObservacao( patioRequestDto.getObservacao() );
        }

        return patio;
    }

    @Override
    public PatioResponseDto toResponseDto(Patio patio) {
        if ( patio == null ) {
            return null;
        }

        Long idPatio = null;
        String nomePatio = null;
        LocalDate dataEntrada = null;
        LocalDate dataSaida = null;
        String observacao = null;

        idPatio = patio.getIdPatio();
        nomePatio = patio.getNomePatio();
        dataEntrada = patio.getDataEntrada();
        dataSaida = patio.getDataSaida();
        observacao = patio.getObservacao();

        PatioResponseDto patioResponseDto = new PatioResponseDto( idPatio, nomePatio, dataEntrada, dataSaida, observacao );

        return patioResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\RastreamentoMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: RastreamentoMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.model.Rastreamento;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-10T13:45:33-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class RastreamentoMapperImpl implements RastreamentoMapper {

    @Override
    public Rastreamento toEntity(RastreamentoRequestDto rastreamentoRequestDto) {
        if ( rastreamentoRequestDto == null ) {
            return null;
        }

        Rastreamento.RastreamentoBuilder rastreamento = Rastreamento.builder();

        rastreamento.ipsX( rastreamentoRequestDto.getIpsX() );
        rastreamento.ipsY( rastreamentoRequestDto.getIpsY() );
        rastreamento.ipsZ( rastreamentoRequestDto.getIpsZ() );
        rastreamento.gprsLatitude( rastreamentoRequestDto.getGprsLatitude() );
        rastreamento.gprsLongitude( rastreamentoRequestDto.getGprsLongitude() );
        rastreamento.gprsAltitude( rastreamentoRequestDto.getGprsAltitude() );

        return rastreamento.build();
    }

    @Override
    public Rastreamento partialUpdate(RastreamentoRequestDto dto, Rastreamento rastreamento) {
        if ( dto == null ) {
            return rastreamento;
        }

        if ( dto.getIpsX() != null ) {
            rastreamento.setIpsX( dto.getIpsX() );
        }
        if ( dto.getIpsY() != null ) {
            rastreamento.setIpsY( dto.getIpsY() );
        }
        if ( dto.getIpsZ() != null ) {
            rastreamento.setIpsZ( dto.getIpsZ() );
        }
        if ( dto.getGprsLatitude() != null ) {
            rastreamento.setGprsLatitude( dto.getGprsLatitude() );
        }
        if ( dto.getGprsLongitude() != null ) {
            rastreamento.setGprsLongitude( dto.getGprsLongitude() );
        }
        if ( dto.getGprsAltitude() != null ) {
            rastreamento.setGprsAltitude( dto.getGprsAltitude() );
        }

        return rastreamento;
    }

    @Override
    public RastreamentoResponseDto toResponseDto(Rastreamento rastreamento) {
        if ( rastreamento == null ) {
            return null;
        }

        Long idRastreamento = null;
        BigDecimal ipsX = null;
        BigDecimal ipsY = null;
        BigDecimal ipsZ = null;
        BigDecimal gprsLatitude = null;
        BigDecimal gprsLongitude = null;
        BigDecimal gprsAltitude = null;
        LocalDateTime dataHoraRegistro = null;

        idRastreamento = rastreamento.getIdRastreamento();
        ipsX = rastreamento.getIpsX();
        ipsY = rastreamento.getIpsY();
        ipsZ = rastreamento.getIpsZ();
        gprsLatitude = rastreamento.getGprsLatitude();
        gprsLongitude = rastreamento.getGprsLongitude();
        gprsAltitude = rastreamento.getGprsAltitude();
        dataHoraRegistro = rastreamento.getDataHoraRegistro();

        RastreamentoResponseDto rastreamentoResponseDto = new RastreamentoResponseDto( idRastreamento, ipsX, ipsY, ipsZ, gprsLatitude, gprsLongitude, gprsAltitude, dataHoraRegistro );

        return rastreamentoResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\VeiculoMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: VeiculoMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.model.Veiculo;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-10T13:45:33-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class VeiculoMapperImpl implements VeiculoMapper {

    @Override
    public Veiculo toEntity(VeiculoRequestDto veiculoRequestDto) {
        if ( veiculoRequestDto == null ) {
            return null;
        }

        Veiculo.VeiculoBuilder veiculo = Veiculo.builder();

        veiculo.tagBleId( veiculoRequestDto.getTagBleId() );
        veiculo.status( veiculoRequestDto.getStatus() );
        veiculo.placa( veiculoRequestDto.getPlaca() );
        veiculo.renavam( veiculoRequestDto.getRenavam() );
        veiculo.chassi( veiculoRequestDto.getChassi() );
        veiculo.fabricante( veiculoRequestDto.getFabricante() );
        veiculo.modelo( veiculoRequestDto.getModelo() );
        veiculo.motor( veiculoRequestDto.getMotor() );
        veiculo.ano( veiculoRequestDto.getAno() );
        veiculo.combustivel( veiculoRequestDto.getCombustivel() );

        return veiculo.build();
    }

    @Override
    public Veiculo partialUpdate(VeiculoRequestDto veiculoRequestDto, Veiculo veiculo) {
        if ( veiculoRequestDto == null ) {
            return veiculo;
        }

        if ( veiculoRequestDto.getTagBleId() != null ) {
            veiculo.setTagBleId( veiculoRequestDto.getTagBleId() );
        }
        if ( veiculoRequestDto.getStatus() != null ) {
            veiculo.setStatus( veiculoRequestDto.getStatus() );
        }
        if ( veiculoRequestDto.getPlaca() != null ) {
            veiculo.setPlaca( veiculoRequestDto.getPlaca() );
        }
        if ( veiculoRequestDto.getRenavam() != null ) {
            veiculo.setRenavam( veiculoRequestDto.getRenavam() );
        }
        if ( veiculoRequestDto.getChassi() != null ) {
            veiculo.setChassi( veiculoRequestDto.getChassi() );
        }
        if ( veiculoRequestDto.getFabricante() != null ) {
            veiculo.setFabricante( veiculoRequestDto.getFabricante() );
        }
        if ( veiculoRequestDto.getModelo() != null ) {
            veiculo.setModelo( veiculoRequestDto.getModelo() );
        }
        if ( veiculoRequestDto.getMotor() != null ) {
            veiculo.setMotor( veiculoRequestDto.getMotor() );
        }
        if ( veiculoRequestDto.getAno() != null ) {
            veiculo.setAno( veiculoRequestDto.getAno() );
        }
        if ( veiculoRequestDto.getCombustivel() != null ) {
            veiculo.setCombustivel( veiculoRequestDto.getCombustivel() );
        }

        return veiculo;
    }

    @Override
    public VeiculoResponseDto toResponseDto(Veiculo veiculo) {
        if ( veiculo == null ) {
            return null;
        }

        String tagBleId = null;
        String status = null;
        Long idVeiculo = null;
        String placa = null;
        String renavam = null;
        String chassi = null;
        String fabricante = null;
        String modelo = null;
        String motor = null;
        Integer ano = null;
        String combustivel = null;

        tagBleId = veiculo.getTagBleId();
        status = veiculo.getStatus();
        idVeiculo = veiculo.getIdVeiculo();
        placa = veiculo.getPlaca();
        renavam = veiculo.getRenavam();
        chassi = veiculo.getChassi();
        fabricante = veiculo.getFabricante();
        modelo = veiculo.getModelo();
        motor = veiculo.getMotor();
        ano = veiculo.getAno();
        combustivel = veiculo.getCombustivel();

        VeiculoResponseDto veiculoResponseDto = new VeiculoResponseDto( idVeiculo, placa, renavam, chassi, fabricante, modelo, motor, ano, combustivel, tagBleId, status );

        return veiculoResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\build\generated\sources\annotationProcessor\java\main\br\com\fiap\mottu\mapper\ZonaMapperImpl.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ZonaMapperImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.model.Zona;
import java.time.LocalDate;
import javax.annotation.processing.Generated;
import org.springframework.stereotype.Component;

@Generated(
    value = "org.mapstruct.ap.MappingProcessor",
    date = "2025-09-10T13:45:33-0300",
    comments = "version: 1.5.5.Final, compiler: IncrementalProcessingEnvironment from gradle-language-java-8.14.3.jar, environment: Java 21.0.1 (Oracle Corporation)"
)
@Component
public class ZonaMapperImpl implements ZonaMapper {

    @Override
    public Zona toEntity(ZonaRequestDto zonaRequestDto) {
        if ( zonaRequestDto == null ) {
            return null;
        }

        Zona.ZonaBuilder zona = Zona.builder();

        zona.nome( zonaRequestDto.getNome() );
        zona.dataEntrada( zonaRequestDto.getDataEntrada() );
        zona.dataSaida( zonaRequestDto.getDataSaida() );
        zona.observacao( zonaRequestDto.getObservacao() );

        return zona.build();
    }

    @Override
    public Zona partialUpdate(ZonaRequestDto zonaRequestDto, Zona zona) {
        if ( zonaRequestDto == null ) {
            return zona;
        }

        if ( zonaRequestDto.getNome() != null ) {
            zona.setNome( zonaRequestDto.getNome() );
        }
        if ( zonaRequestDto.getDataEntrada() != null ) {
            zona.setDataEntrada( zonaRequestDto.getDataEntrada() );
        }
        if ( zonaRequestDto.getDataSaida() != null ) {
            zona.setDataSaida( zonaRequestDto.getDataSaida() );
        }
        if ( zonaRequestDto.getObservacao() != null ) {
            zona.setObservacao( zonaRequestDto.getObservacao() );
        }

        return zona;
    }

    @Override
    public ZonaResponseDto toResponseDto(Zona zona) {
        if ( zona == null ) {
            return null;
        }

        Long idZona = null;
        String nome = null;
        LocalDate dataEntrada = null;
        LocalDate dataSaida = null;
        String observacao = null;

        idZona = zona.getIdZona();
        nome = zona.getNome();
        dataEntrada = zona.getDataEntrada();
        dataSaida = zona.getDataSaida();
        observacao = zona.getObservacao();

        ZonaResponseDto zonaResponseDto = new ZonaResponseDto( idZona, nome, dataEntrada, dataSaida, observacao );

        return zonaResponseDto;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\BoxMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: BoxMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.model.Box;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        uses = {PatioMapper.class} // NOVO: Adicionar PatioMapper aqui, se necessário para o DTO (não estritamente necessário para esta feature, mas boa prática para o gráfico de dependências)
)
public interface BoxMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idBox", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Box toEntity(BoxRequestDto boxRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de um Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idBox", ignore = true) // ID não é atualizado
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Box partialUpdate(BoxRequestDto boxRequestDto, @MappingTarget Box box);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    BoxResponseDto toResponseDto(Box box);
    // --- Métodos para mapear coleções (opcional) ---
    // List<BoxResponseDto> toResponseDtoList(List<Box> boxes);
    // Set<BoxResponseDto> toResponseDtoSet(Set<Box> boxes);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\ClienteMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ClienteMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\ClienteMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto;
import br.com.fiap.mottu.model.Cliente;

// Importe os mappers para os DTOs aninhados
import br.com.fiap.mottu.mapper.EnderecoMapper;
import br.com.fiap.mottu.mapper.ContatoMapper;
// Importar mapper para VeiculoResponseDto se ClienteResponseDto for incluí-lo
// import br.com.fiap.mottu.mapper.relacionamento.ClienteVeiculoMapper;
// import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // Para mapear para VeiculoResponseDto

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

import java.util.Set; // Necessário para mapear coleções
import java.util.stream.Collectors; // Necessário para stream() e collect()

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        // Adiciona os mappers para os DTOs aninhados (Endereco e Contato)
        uses = { EnderecoMapper.class, ContatoMapper.class }
        // Se for mapear Set<ClienteVeiculo> para Set<VeiculoResponseDto>, precisará de um Mapper que faça isso.
        // Ex: uses = { EnderecoMapper.class, ContatoMapper.class, ClienteVeiculoMapper.class }
)
public interface ClienteMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    // Mapeia ClienteRequestDto -> Cliente
    @Mapping(target = "idCliente", ignore = true) // ID é gerado pelo BD, ignore ao mapear Request para Entidade
    // @Mapping(target = "dataCadastro", ignore = true) // dataCadastro é gerada pelo BD (DEFAULT SYSDATE), ignore ao mapear Request para Entidade
    @Mapping(target = "endereco", source = "enderecoRequestDto") // Mapeia o DTO de Endereco aninhado para a Entidade Endereco
    @Mapping(target = "contato", source = "contatoRequestDto") // Mapeia o DTO de Contato aninhado para a Entidade Contato
    @Mapping(target = "clienteVeiculos", ignore = true) // Relação Many-to-Many não é criada diretamente aqui
    Cliente toEntity(ClienteRequestDto clienteRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de um Request DTO
    // Mapeia ClienteRequestDto -> Cliente (existente)
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idCliente", ignore = true) // ID não é atualizado pelo DTO
    @Mapping(target = "dataCadastro", ignore = true) // Data de cadastro não é atualizada pelo DTO
    @Mapping(target = "endereco", source = "enderecoRequestDto") // Mapeia o DTO de Endereco aninhado para a Entidade Endereco existente no Cliente
    @Mapping(target = "contato", source = "contatoRequestDto") // Mapeia o DTO de Contato aninhado para a Entidade Contato existente no Cliente
    @Mapping(target = "clienteVeiculos", ignore = true) // Relação Many-to-Many não é atualizada diretamente aqui
    Cliente partialUpdate(ClienteRequestDto clienteRequestDto, @MappingTarget Cliente cliente);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    // Mapeia Cliente -> ClienteResponseDto
    @Mapping(target = "enderecoResponseDto", source = "endereco") // Mapeia a Entidade Endereco para o DTO de Endereco aninhado no Response
    @Mapping(target = "contatoResponseDto", source = "contato") // Mapeia a Entidade Contato para o DTO de Contato aninhado no Response
    // Se ClienteResponseDto tiver campos de coleções (ex: Set<VeiculoResponseDto> veiculos)
    // Você precisaria de um método @Named para fazer essa conversão se ClienteVeiculoMapper não for suficiente,
    // ou um método diretamente no mapper se a lógica for simples.
    // Exemplo: @Mapping(target = "veiculos", expression = "java(mapClienteVeiculosToVeiculoResponseDtos(cliente.getClienteVeiculos()))")
    ClienteResponseDto toResponseDto(Cliente cliente);

    // Exemplo de método para mapear Set<ClienteVeiculo> para Set<VeiculoResponseDto>
    // Este método pode ser um @Named ou um método privado na interface se for Java 8 default methods
    /*
    default Set<VeiculoResponseDto> mapClienteVeiculosToVeiculoResponseDtos(Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos) {
        if (clienteVeiculos == null) {
            return null;
        }
        // Assume que você tem um VeiculoMapper injetável para converter Veiculo para VeiculoResponseDto
        // Ou que o ClienteVeiculoMapper tem um método para mapear para VeiculoResponseDto
        return clienteVeiculos.stream()
                .map(ClienteVeiculo::getVeiculo) // Pega a entidade Veiculo da associação
                .map(veiculo -> SpringApplicationContext.getBean(VeiculoMapper.class).toResponseDto(veiculo)) // Necessita de um mecanismo para obter o bean do mapper
                .collect(Collectors.toSet());
    }
    */

    // --- Métodos para mapear coleções (opcional) ---
    // List<ClienteResponseDto> toResponseDtoList(List<Cliente> clientes);
    // Set<ClienteResponseDto> toResponseDtoSet(Set<Cliente> clientes);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\ContatoMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ContatoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\ContatoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.model.Contato;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se ContatoResponseDto tiver DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.ClienteMapper; // Exemplo se ContatoResponseDto incluir Cliente associado
// import br.com.fiap.mottu.mapper.relacionamento.ContatoPatioMapper; // Exemplo se ContatoResponseDto incluir Patio associado

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se ContatoResponseDto incluir DTOs aninhados ou coleções
        // uses = { ClienteMapper.class, ContatoPatioMapper.class }
)
public interface ContatoMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idContato", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "clienteContatos", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    Contato toEntity(ContatoRequestDto contatoRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idContato", ignore = true) // ID não é atualizado
    @Mapping(target = "clienteContatos", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é atualizado
    Contato partialUpdate(ContatoRequestDto contatoRequestDto, @MappingTarget Contato contato);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    ContatoResponseDto toResponseDto(Contato contato);

    // --- Métodos para mapear coleções (opcional) ---
    // List<ContatoResponseDto> toResponseDtoList(List<Contato> contatos);
    // Set<ContatoResponseDto> toResponseDtoSet(Set<Contato> contatos);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\EnderecoMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: EnderecoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\EnderecoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.model.Endereco;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se EnderecoResponseDto tiver DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.ClienteMapper; // Exemplo se EnderecoResponseDto incluir Cliente associado
// import br.com.fiap.mottu.mapper.relacionamento.EnderecoPatioMapper; // Exemplo se EnderecoResponseDto incluir Patio associado

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se EnderecoResponseDto incluir DTOs aninhados ou coleções
        // uses = { ClienteMapper.class, EnderecoPatioMapper.class }
)
public interface EnderecoMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idEndereco", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "clienteEnderecos", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    Endereco toEntity(EnderecoRequestDto enderecoRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idEndereco", ignore = true) // ID não é atualizado
    @Mapping(target = "clienteEnderecos", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é atualizado
    Endereco partialUpdate(EnderecoRequestDto enderecoRequestDto, @MappingTarget Endereco endereco);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    EnderecoResponseDto toResponseDto(Endereco endereco);

    // --- Métodos para mapear coleções (opcional) ---
    // List<EnderecoResponseDto> toResponseDtoList(List<Endereco> enderecos);
    // Set<EnderecoResponseDto> toResponseDtoSet(Set<Endereco> enderecos);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\PatioMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: PatioMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.model.Patio;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        uses = {BoxMapper.class} // NOVO: Adicionar BoxMapper aqui
)
public interface PatioMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idPatio", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Patio toEntity(PatioRequestDto patioRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idPatio", ignore = true) // ID não é atualizado
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Patio partialUpdate(PatioRequestDto patioRequestDto, @MappingTarget Patio patio);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    PatioResponseDto toResponseDto(Patio patio);
    // List<PatioResponseDto> toResponseDtoList(List<Patio> patios);
    // Set<PatioResponseDto> toResponseDtoSet(Set<Patio> patios);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\RastreamentoMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: RastreamentoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto; // DTO para requisições de criação/atualização
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto; // DTO para respostas
import br.com.fiap.mottu.model.Rastreamento; // Entidade Rastreamento
import org.mapstruct.*; // Importações do MapStruct para mapeamento de objetos
import org.mapstruct.ReportingPolicy; // Define como lidar com mapeamentos não mapeados
import org.mapstruct.MappingConstants; // Constantes do MapStruct

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE, // Ignora campos não mapeados no destino
        componentModel = MappingConstants.ComponentModel.SPRING // Integração com Spring (gera um bean)
)
public interface RastreamentoMapper {

    // Mapeia de RastreamentoRequestDto para a entidade Rastreamento
    @Mapping(target = "idRastreamento", ignore = true) // ID é gerado pelo banco, não vem no request
    @Mapping(target = "veiculoRastreamentos", ignore = true) // Relacionamentos são gerenciados separadamente
    @Mapping(target = "dataHoraRegistro", ignore = true) // Será gerado automaticamente na criação pela JPA/Hibernate
    Rastreamento toEntity(RastreamentoRequestDto rastreamentoRequestDto);

    // Atualiza uma entidade Rastreamento existente com dados de um RastreamentoRequestDto
    // Apenas campos não nulos no DTO serão usados para atualizar a entidade
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idRastreamento", ignore = true) // ID não deve ser atualizado
    @Mapping(target = "veiculoRastreamentos", ignore = true) // Relacionamentos não são atualizados por este DTO diretamente
    @Mapping(target = "dataHoraRegistro", ignore = true) // Data de registro não deve ser atualizada
    Rastreamento partialUpdate(RastreamentoRequestDto dto, @MappingTarget Rastreamento rastreamento);

    // Mapeia da entidade Rastreamento para RastreamentoResponseDto
    // O campo dataHoraRegistro será mapeado automaticamente pois os nomes coincidem
    RastreamentoResponseDto toResponseDto(Rastreamento rastreamento);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\VeiculoMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: VeiculoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.model.Veiculo;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
)
public interface VeiculoMapper {

    @Mapping(target = "idVeiculo", ignore = true)
    @Mapping(target = "clienteVeiculos", ignore = true)
    @Mapping(target = "veiculoBoxes", ignore = true)
    @Mapping(target = "veiculoPatios", ignore = true)
    @Mapping(target = "veiculoRastreamentos", ignore = true)
    @Mapping(target = "veiculoZonas", ignore = true)
    // Mapeia diretamente o campo tagBleId do DTO para a entidade
    @Mapping(source = "tagBleId", target = "tagBleId")
    @Mapping(source = "status", target = "status")
    Veiculo toEntity(VeiculoRequestDto veiculoRequestDto);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idVeiculo", ignore = true)
    @Mapping(target = "clienteVeiculos", ignore = true)
    @Mapping(target = "veiculoBoxes", ignore = true)
    @Mapping(target = "veiculoPatios", ignore = true)
    @Mapping(target = "veiculoRastreamentos", ignore = true)
    @Mapping(target = "veiculoZonas", ignore = true)
    // Mapeia diretamente o campo tagBleId do DTO para a entidade
    @Mapping(source = "tagBleId", target = "tagBleId")
    @Mapping(source = "status", target = "status")
    Veiculo partialUpdate(VeiculoRequestDto veiculoRequestDto, @MappingTarget Veiculo veiculo);

    // Mapeia diretamente o campo tagBleId da entidade para o DTO de resposta
    @Mapping(source = "tagBleId", target = "tagBleId")
    @Mapping(source = "status", target = "status")
    VeiculoResponseDto toResponseDto(Veiculo veiculo);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\mapper\ZonaMapper.java   |   PACOTE: br.com.fiap.mottu.mapper   |   CLASSE: ZonaMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\ZonaMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.model.Zona;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se ZonaRequestDto ou ZonaResponseDto tiverem DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoZonaMapper;
// import br.com.fiap.mottu.mapper.relacionamento.ZonaBoxMapper;
// import br.com.fiap.mottu.mapper.relacionamento.ZonaPatioMapper;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se ZonaRequestDto ou ZonaResponseDto incluirem DTOs aninhados ou coleções
        // uses = { VeiculoZonaMapper.class, ZonaBoxMapper.class, ZonaPatioMapper.class }
)
public interface ZonaMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idZona", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    Zona toEntity(ZonaRequestDto zonaRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idZona", ignore = true) // ID não é atualizado
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é atualizado
    Zona partialUpdate(ZonaRequestDto zonaRequestDto, @MappingTarget Zona zona);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    ZonaResponseDto toResponseDto(Zona zona);

    // --- Métodos para mapear coleções (opcional) ---
    // List<ZonaResponseDto> toResponseDtoList(List<Zona> zonas);
    // Set<ZonaResponseDto> toResponseDtoSet(Set<Zona> zonas);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.model
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\Box.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Box
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_BOX")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido 'exclude = {...}'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Box {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_BOX")
    @EqualsAndHashCode.Include
    private Long idBox;

    @Column(name = "NOME", nullable = false, length = 50)
    private String nome;

    @Column(name = "STATUS", nullable = false, length = 1)
    private String status;

    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;

    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;

    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    // Relacionamentos inversos para tabelas de junção
    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoBox> veiculoBoxes = new HashSet<>();

    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaBox> zonaBoxes = new HashSet<>();

    // Relacionamento inverso para PatioBox
    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.PatioBox> patioBoxes = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\Cliente.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Cliente
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Cliente.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

import org.springframework.data.annotation.CreatedDate; // <-- IMPORTAR AQUI
import org.springframework.data.jpa.domain.support.AuditingEntityListener; // <-- IMPORTAR AQUI

@Entity
@Table(name = "TB_CLIENTE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@EntityListeners(AuditingEntityListener.class) // <-- ADICIONAR AQUI!
public class Cliente {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_CLIENTE")
    @EqualsAndHashCode.Include
    private Long idCliente;

    @CreatedDate // <-- ADICIONAR AQUI!
    @Column(name = "DATA_CADASTRO", nullable = false, updatable = false)
    private LocalDate dataCadastro;

    @Column(name = "SEXO", nullable = false, length = 2)
    private String sexo;
    @Column(name = "NOME", nullable = false, length = 100)
    private String nome;
    @Column(name = "SOBRENOME", nullable = false, length = 100)
    private String sobrenome;
    @Column(name = "DATA_NASCIMENTO", nullable = false)
    private LocalDate dataNascimento;
    @Column(name = "CPF", nullable = false, unique = true, length = 11)
    private String cpf;
    @Column(name = "PROFISSAO", nullable = false, length = 50)
    private String profissao;
    @Column(name = "ESTADO_CIVIL", nullable = false, length = 50)
    private String estadoCivil;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TB_ENDERECO_ID_ENDERECO", nullable = false)
    @ToString.Exclude
    private Endereco endereco;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TB_CONTATO_ID_CONTATO", nullable = false)
    @ToString.Exclude
    private Contato contato;

    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\Contato.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Contato
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Contato.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "TB_CONTATO")
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Contato {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_CONTATO")
    @EqualsAndHashCode.Include
    private Long idContato;
    @Column(name = "EMAIL", nullable = false, length = 100)
    private String email;
    @Column(name = "DDD", nullable = false, precision = 4, scale = 0)
    private Integer ddd;
    @Column(name = "DDI", nullable = false, precision = 4, scale = 0)
    private Integer ddi;
    @Column(name = "TELEFONE1", nullable = false, length = 20)
    private String telefone1;
    @Column(name = "TELEFONE2", length = 20)
    private String telefone2;
    @Column(name = "TELEFONE3", length = 20)
    private String telefone3;
    @Column(name = "CELULAR", nullable = false, length = 20)
    private String celular;
    @Column(name = "OUTRO", length = 100)
    private String outro;
    @Column(name = "OBSERVACAO", length = 200)
    private String observacao;

    @OneToMany(mappedBy = "contato", cascade = CascadeType.ALL)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<Cliente> clienteContatos = new HashSet<>();
    @OneToMany(mappedBy = "contato", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ContatoPatio> contatoPatios = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\Endereco.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Endereco
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Endereco.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "TB_ENDERECO")
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Endereco {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_ENDERECO")
    @EqualsAndHashCode.Include
    private Long idEndereco;
    @Column(name = "CEP", nullable = false, length = 9) // Linha a ser restaurada para este estado
    private String cep;
    @Column(name = "NUMERO", nullable = false, precision = 7, scale = 0)
    private Integer numero;
    @Column(name = "LOGRADOURO", nullable = false, length = 50)
    private String logradouro;
    @Column(name = "BAIRRO", nullable = false, length = 50)
    private String bairro;
    @Column(name = "CIDADE", nullable = false, length = 50)
    private String cidade;
    @Column(name = "ESTADO", nullable = false, length = 2) // Linha a ser restaurada para este estado
    private String estado;
    @Column(name = "PAIS", nullable = false, length = 50)
    private String pais;
    @Column(name = "COMPLEMENTO", length = 60)
    private String complemento;
    @Column(name = "OBSERVACAO", length = 200)
    private String observacao;
    // Relacionamentos inversos
    @OneToMany(mappedBy = "endereco", cascade = CascadeType.ALL)
    @ToString.Exclude
    @Builder.Default
    private Set<Cliente> clienteEnderecos = new HashSet<>();
    @OneToMany(mappedBy = "endereco", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.EnderecoPatio> enderecoPatios = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\Patio.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Patio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_PATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido 'exclude = {...}'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Patio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_PATIO")
    @EqualsAndHashCode.Include
    private Long idPatio;

    @Column(name = "NOME_PATIO", nullable = false, length = 50)
    private String nomePatio;

    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;

    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;

    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ContatoPatio> contatoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.EnderecoPatio> enderecoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoPatio> veiculoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaPatio> zonaPatios = new HashSet<>();

    // Relacionamento inverso para PatioBox
    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.PatioBox> patioBoxes = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\Rastreamento.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Rastreamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_RASTREAMENTO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"veiculoRastreamentos"})
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Rastreamento {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_RASTREAMENTO")
    @EqualsAndHashCode.Include
    private Long idRastreamento;

    @Column(name = "IPS_X", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsX;

    @Column(name = "IPS_Y", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsY;

    @Column(name = "IPS_Z", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsZ;

    @Column(name = "GPRS_LATITUDE", nullable = false, precision = 11, scale = 6)
    private BigDecimal gprsLatitude;

    @Column(name = "GPRS_LONGITUDE", nullable = false, precision = 11, scale = 6)
    private BigDecimal gprsLongitude;

    @Column(name = "GPRS_ALTITUDE", nullable = false, precision = 7, scale = 2)
    private BigDecimal gprsAltitude;

    @CreationTimestamp
    @Column(name = "DATA_HORA_REGISTRO", nullable = false, updatable = false)
    private LocalDateTime dataHoraRegistro;

    @OneToMany(mappedBy = "rastreamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento> veiculoRastreamentos = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\Veiculo.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Veiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_VEICULO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Veiculo {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_VEICULO")
    @EqualsAndHashCode.Include
    private Long idVeiculo;

    @Column(name = "PLACA", nullable = false, unique = true, length = 10)
    private String placa;

    @Column(name = "RENAVAM", nullable = false, unique = true, length = 11)
    private String renavam;

    @Column(name = "CHASSI", nullable = false, unique = true, length = 17)
    private String chassi;

    @Column(name = "FABRICANTE", nullable = false, length = 50)
    private String fabricante;

    @Column(name = "MODELO", nullable = false, length = 60)
    private String modelo;

    @Column(name = "MOTOR", length = 30)
    private String motor;

    @Column(name = "ANO", nullable = false)
    private Integer ano;

    @Column(name = "COMBUSTIVEL", nullable = false, length = 20)
    private String combustivel;

    // --- CORREÇÃO APLICADA AQUI ---
    // Campo de texto simples para corresponder ao seu DDL.
    @Column(name = "TAG_BLE_ID", unique = true, length = 50)
    private String tagBleId;

    // --- CORREÇÃO APLICADA AQUI ---
    // Adicionado mapeamento para a coluna STATUS_OPERACIONAL que faltava
    @Column(name = "STATUS_OPERACIONAL", length = 20)
    private String status;

    // Relacionamentos inversos
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos = new HashSet<>();

    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoBox> veiculoBoxes = new HashSet<>();

    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoPatio> veiculoPatios = new HashSet<>();

    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento> veiculoRastreamentos = new HashSet<>();

    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoZona> veiculoZonas = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\Zona.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Zona
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Zona.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_ZONA")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Zona {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_ZONA")
    @EqualsAndHashCode.Include
    private Long idZona;
    @Column(name = "NOME", nullable = false, length = 50)
    private String nome;
    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;
    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;
    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoZona> veiculoZonas = new HashSet<>();
    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaBox> zonaBoxes = new HashSet<>();
    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaPatio> zonaPatios = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\Box.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Box
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_BOX")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido 'exclude = {...}'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Box {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_BOX")
    @EqualsAndHashCode.Include
    private Long idBox;

    @Column(name = "NOME", nullable = false, length = 50)
    private String nome;

    @Column(name = "STATUS", nullable = false, length = 1)
    private String status;

    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;

    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;

    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    // Relacionamentos inversos para tabelas de junção
    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoBox> veiculoBoxes = new HashSet<>();

    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaBox> zonaBoxes = new HashSet<>();

    // Relacionamento inverso para PatioBox
    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.PatioBox> patioBoxes = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\Cliente.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Cliente
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Cliente.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

import org.springframework.data.annotation.CreatedDate; // <-- IMPORTAR AQUI
import org.springframework.data.jpa.domain.support.AuditingEntityListener; // <-- IMPORTAR AQUI

@Entity
@Table(name = "TB_CLIENTE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@EntityListeners(AuditingEntityListener.class) // <-- ADICIONAR AQUI!
public class Cliente {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_CLIENTE")
    @EqualsAndHashCode.Include
    private Long idCliente;

    @CreatedDate // <-- ADICIONAR AQUI!
    @Column(name = "DATA_CADASTRO", nullable = false, updatable = false)
    private LocalDate dataCadastro;

    @Column(name = "SEXO", nullable = false, length = 2)
    private String sexo;
    @Column(name = "NOME", nullable = false, length = 100)
    private String nome;
    @Column(name = "SOBRENOME", nullable = false, length = 100)
    private String sobrenome;
    @Column(name = "DATA_NASCIMENTO", nullable = false)
    private LocalDate dataNascimento;
    @Column(name = "CPF", nullable = false, unique = true, length = 11)
    private String cpf;
    @Column(name = "PROFISSAO", nullable = false, length = 50)
    private String profissao;
    @Column(name = "ESTADO_CIVIL", nullable = false, length = 50)
    private String estadoCivil;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TB_ENDERECO_ID_ENDERECO", nullable = false)
    @ToString.Exclude
    private Endereco endereco;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TB_CONTATO_ID_CONTATO", nullable = false)
    @ToString.Exclude
    private Contato contato;

    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\Contato.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Contato
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Contato.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "TB_CONTATO")
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Contato {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_CONTATO")
    @EqualsAndHashCode.Include
    private Long idContato;
    @Column(name = "EMAIL", nullable = false, length = 100)
    private String email;
    @Column(name = "DDD", nullable = false, precision = 4, scale = 0)
    private Integer ddd;
    @Column(name = "DDI", nullable = false, precision = 4, scale = 0)
    private Integer ddi;
    @Column(name = "TELEFONE1", nullable = false, length = 20)
    private String telefone1;
    @Column(name = "TELEFONE2", length = 20)
    private String telefone2;
    @Column(name = "TELEFONE3", length = 20)
    private String telefone3;
    @Column(name = "CELULAR", nullable = false, length = 20)
    private String celular;
    @Column(name = "OUTRO", length = 100)
    private String outro;
    @Column(name = "OBSERVACAO", length = 200)
    private String observacao;

    @OneToMany(mappedBy = "contato", cascade = CascadeType.ALL)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<Cliente> clienteContatos = new HashSet<>();
    @OneToMany(mappedBy = "contato", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ContatoPatio> contatoPatios = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\Endereco.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Endereco
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Endereco.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "TB_ENDERECO")
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Endereco {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_ENDERECO")
    @EqualsAndHashCode.Include
    private Long idEndereco;
    @Column(name = "CEP", nullable = false, length = 9) // Linha a ser restaurada para este estado
    private String cep;
    @Column(name = "NUMERO", nullable = false, precision = 7, scale = 0)
    private Integer numero;
    @Column(name = "LOGRADOURO", nullable = false, length = 50)
    private String logradouro;
    @Column(name = "BAIRRO", nullable = false, length = 50)
    private String bairro;
    @Column(name = "CIDADE", nullable = false, length = 50)
    private String cidade;
    @Column(name = "ESTADO", nullable = false, length = 2) // Linha a ser restaurada para este estado
    private String estado;
    @Column(name = "PAIS", nullable = false, length = 50)
    private String pais;
    @Column(name = "COMPLEMENTO", length = 60)
    private String complemento;
    @Column(name = "OBSERVACAO", length = 200)
    private String observacao;
    // Relacionamentos inversos
    @OneToMany(mappedBy = "endereco", cascade = CascadeType.ALL)
    @ToString.Exclude
    @Builder.Default
    private Set<Cliente> clienteEnderecos = new HashSet<>();
    @OneToMany(mappedBy = "endereco", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.EnderecoPatio> enderecoPatios = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\Patio.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Patio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_PATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido 'exclude = {...}'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Patio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_PATIO")
    @EqualsAndHashCode.Include
    private Long idPatio;

    @Column(name = "NOME_PATIO", nullable = false, length = 50)
    private String nomePatio;

    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;

    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;

    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ContatoPatio> contatoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.EnderecoPatio> enderecoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoPatio> veiculoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaPatio> zonaPatios = new HashSet<>();

    // Relacionamento inverso para PatioBox
    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.PatioBox> patioBoxes = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\Rastreamento.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Rastreamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_RASTREAMENTO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"veiculoRastreamentos"})
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Rastreamento {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_RASTREAMENTO")
    @EqualsAndHashCode.Include
    private Long idRastreamento;

    @Column(name = "IPS_X", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsX;

    @Column(name = "IPS_Y", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsY;

    @Column(name = "IPS_Z", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsZ;

    @Column(name = "GPRS_LATITUDE", nullable = false, precision = 11, scale = 6)
    private BigDecimal gprsLatitude;

    @Column(name = "GPRS_LONGITUDE", nullable = false, precision = 11, scale = 6)
    private BigDecimal gprsLongitude;

    @Column(name = "GPRS_ALTITUDE", nullable = false, precision = 7, scale = 2)
    private BigDecimal gprsAltitude;

    @CreationTimestamp
    @Column(name = "DATA_HORA_REGISTRO", nullable = false, updatable = false)
    private LocalDateTime dataHoraRegistro;

    @OneToMany(mappedBy = "rastreamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento> veiculoRastreamentos = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\Veiculo.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Veiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_VEICULO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Veiculo {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_VEICULO")
    @EqualsAndHashCode.Include
    private Long idVeiculo;

    @Column(name = "PLACA", nullable = false, unique = true, length = 10)
    private String placa;

    @Column(name = "RENAVAM", nullable = false, unique = true, length = 11)
    private String renavam;

    @Column(name = "CHASSI", nullable = false, unique = true, length = 17)
    private String chassi;

    @Column(name = "FABRICANTE", nullable = false, length = 50)
    private String fabricante;

    @Column(name = "MODELO", nullable = false, length = 60)
    private String modelo;

    @Column(name = "MOTOR", length = 30)
    private String motor;

    @Column(name = "ANO", nullable = false)
    private Integer ano;

    @Column(name = "COMBUSTIVEL", nullable = false, length = 20)
    private String combustivel;

    // --- CORREÇÃO APLICADA AQUI ---
    // Campo de texto simples para corresponder ao seu DDL.
    @Column(name = "TAG_BLE_ID", unique = true, length = 50)
    private String tagBleId;

    // --- CORREÇÃO APLICADA AQUI ---
    // Adicionado mapeamento para a coluna STATUS_OPERACIONAL que faltava
    @Column(name = "STATUS_OPERACIONAL", length = 20)
    private String status;

    // Relacionamentos inversos
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos = new HashSet<>();

    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoBox> veiculoBoxes = new HashSet<>();

    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoPatio> veiculoPatios = new HashSet<>();

    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento> veiculoRastreamentos = new HashSet<>();

    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoZona> veiculoZonas = new HashSet<>();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\Zona.java   |   PACOTE: br.com.fiap.mottu.model   |   CLASSE: Zona
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Zona.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_ZONA")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Zona {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_ZONA")
    @EqualsAndHashCode.Include
    private Long idZona;
    @Column(name = "NOME", nullable = false, length = 50)
    private String nome;
    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;
    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;
    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoZona> veiculoZonas = new HashSet<>();
    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaBox> zonaBoxes = new HashSet<>();
    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaPatio> zonaPatios = new HashSet<>();
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.model.relacionamento
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ClienteVeiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_CLIENTEVEICULO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ClienteVeiculo {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ClienteVeiculoId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("clienteId")
    @JoinColumn(name = "TB_CLIENTE_ID_CLIENTE", referencedColumnName = "ID_CLIENTE", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Cliente cliente;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", referencedColumnName = "ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;

    public ClienteVeiculo(Cliente cliente, Veiculo veiculo) {
        this.cliente = cliente;
        this.veiculo = veiculo;
        this.id = new ClienteVeiculoId(
                cliente.getIdCliente(),
                cliente.getEndereco() != null ? cliente.getEndereco().getIdEndereco() : null,
                cliente.getContato() != null ? cliente.getContato().getIdContato() : null,
                veiculo.getIdVeiculo()
        );
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ClienteVeiculoId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para PKs compostas
public class ClienteVeiculoId implements Serializable {

    @Column(name = "TB_CLIENTE_ID_CLIENTE", nullable = false)
    private Long clienteId;

    @Column(name = "TB_CLIENTE_TB_ENDERECO_ID_ENDERECO", nullable = false)
    private Long clienteEnderecoId;

    @Column(name = "TB_CLIENTE_TB_CONTATO_ID_CONTATO", nullable = false)
    private Long clienteContatoId;

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ContatoPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Patio;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_CONTATOPATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ContatoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ContatoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("contatoId")
    @JoinColumn(name = "TB_CONTATO_ID_CONTATO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Contato contato;

    public ContatoPatio(Patio patio, Contato contato) {
        this.patio = patio;
        this.contato = contato;
        this.id = new ContatoPatioId(patio.getIdPatio(), contato.getIdContato());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ContatoPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ContatoPatioId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_CONTATO_ID_CONTATO", nullable = false)
    private Long contatoId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: EnderecoPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Endereco;
import br.com.fiap.mottu.model.Patio;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ENDERECIOPATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class EnderecoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private EnderecoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("enderecoId")
    @JoinColumn(name = "TB_ENDERECO_ID_ENDERECO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Endereco endereco;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;

    public EnderecoPatio(Endereco endereco, Patio patio) {
        this.endereco = endereco;
        this.patio = patio;
        this.id = new EnderecoPatioId(endereco.getIdEndereco(), patio.getIdPatio());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: EnderecoPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class EnderecoPatioId implements Serializable {

    @Column(name = "TB_ENDERECO_ID_ENDERECO", nullable = false)
    private Long enderecoId;

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\PatioBox.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: PatioBox
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Box;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_PATIOBOX")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // NOVO: Adicione esta anotação para que Lombok gere um construtor com todos os campos.
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class PatioBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private PatioBoxId id;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId") // Mapeia o campo 'patioId' da chave composta
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Patio patio;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId") // Mapeia o campo 'boxId' da chave composta
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Box box;

    // Construtor para facilitar a criação da associação (este construtor é mantido, Lombok gerará o @AllArgsConstructor também)
    public PatioBox(Patio patio, Box box) {
        this.patio = patio;
        this.box = box;
        // Garanta que getIdBox() existe na sua classe Box ou use o nome correto do getter do ID do Box
        this.id = new PatioBoxId(patio.getIdPatio(), box.getIdBox());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\PatioBoxId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: PatioBoxId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para PKs compostas
public class PatioBoxId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoBox
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOBOX")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoBoxId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId")
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Box box;

    public VeiculoBox(Veiculo veiculo, Box box) {
        this.veiculo = veiculo;
        this.box = box;
        this.id = new VeiculoBoxId(veiculo.getIdVeiculo(), box.getIdBox());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoBoxId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoBoxId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOPATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;

    public VeiculoPatio(Veiculo veiculo, Patio patio) {
        this.veiculo = veiculo;
        this.patio = patio;
        this.id = new VeiculoPatioId(veiculo.getIdVeiculo(), patio.getIdPatio());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoPatioId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamento.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoRastreamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULORASTREAMENTO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoRastreamento {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoRastreamentoId id;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Veiculo veiculo;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("rastreamentoId")
    @JoinColumn(name = "TB_RASTREAMENTO_ID_RASTREAMENTO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Rastreamento rastreamento;

    public VeiculoRastreamento(Veiculo veiculo, Rastreamento rastreamento) {
        this.veiculo = veiculo;
        this.rastreamento = rastreamento;
        this.id = new VeiculoRastreamentoId(veiculo.getIdVeiculo(), rastreamento.getIdRastreamento());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoRastreamentoId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoRastreamentoId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_RASTREAMENTO_ID_RASTREAMENTO", nullable = false)
    private Long rastreamentoId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoZona
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOZONA")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoZona {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoZonaId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Zona zona;

    public VeiculoZona(Veiculo veiculo, Zona zona) {
        this.veiculo = veiculo;
        this.zona = zona;
        this.id = new VeiculoZonaId(veiculo.getIdVeiculo(), zona.getIdZona());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoZonaId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoZonaId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ZonaBox
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ZONABOX")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ZonaBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ZonaBoxId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Zona zona;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId")
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Box box;

    public ZonaBox(Zona zona, Box box) {
        this.zona = zona;
        this.box = box;
        this.id = new ZonaBoxId(zona.getIdZona(), box.getIdBox());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ZonaBoxId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ZonaBoxId implements Serializable {

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ZonaPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ZONAPATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ZonaPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ZonaPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Zona zona;

    public ZonaPatio(Patio patio, Zona zona) {
        this.patio = patio;
        this.zona = zona;
        this.id = new ZonaPatioId(patio.getIdPatio(), zona.getIdZona());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ZonaPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ZonaPatioId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ClienteVeiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_CLIENTEVEICULO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ClienteVeiculo {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ClienteVeiculoId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("clienteId")
    @JoinColumn(name = "TB_CLIENTE_ID_CLIENTE", referencedColumnName = "ID_CLIENTE", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Cliente cliente;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", referencedColumnName = "ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;

    public ClienteVeiculo(Cliente cliente, Veiculo veiculo) {
        this.cliente = cliente;
        this.veiculo = veiculo;
        this.id = new ClienteVeiculoId(
                cliente.getIdCliente(),
                cliente.getEndereco() != null ? cliente.getEndereco().getIdEndereco() : null,
                cliente.getContato() != null ? cliente.getContato().getIdContato() : null,
                veiculo.getIdVeiculo()
        );
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ClienteVeiculoId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para PKs compostas
public class ClienteVeiculoId implements Serializable {

    @Column(name = "TB_CLIENTE_ID_CLIENTE", nullable = false)
    private Long clienteId;

    @Column(name = "TB_CLIENTE_TB_ENDERECO_ID_ENDERECO", nullable = false)
    private Long clienteEnderecoId;

    @Column(name = "TB_CLIENTE_TB_CONTATO_ID_CONTATO", nullable = false)
    private Long clienteContatoId;

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ContatoPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Patio;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_CONTATOPATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ContatoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ContatoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("contatoId")
    @JoinColumn(name = "TB_CONTATO_ID_CONTATO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Contato contato;

    public ContatoPatio(Patio patio, Contato contato) {
        this.patio = patio;
        this.contato = contato;
        this.id = new ContatoPatioId(patio.getIdPatio(), contato.getIdContato());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ContatoPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ContatoPatioId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_CONTATO_ID_CONTATO", nullable = false)
    private Long contatoId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: EnderecoPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Endereco;
import br.com.fiap.mottu.model.Patio;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ENDERECIOPATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class EnderecoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private EnderecoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("enderecoId")
    @JoinColumn(name = "TB_ENDERECO_ID_ENDERECO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Endereco endereco;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;

    public EnderecoPatio(Endereco endereco, Patio patio) {
        this.endereco = endereco;
        this.patio = patio;
        this.id = new EnderecoPatioId(endereco.getIdEndereco(), patio.getIdPatio());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: EnderecoPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class EnderecoPatioId implements Serializable {

    @Column(name = "TB_ENDERECO_ID_ENDERECO", nullable = false)
    private Long enderecoId;

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\PatioBox.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: PatioBox
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Box;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_PATIOBOX")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // NOVO: Adicione esta anotação para que Lombok gere um construtor com todos os campos.
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class PatioBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private PatioBoxId id;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId") // Mapeia o campo 'patioId' da chave composta
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Patio patio;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId") // Mapeia o campo 'boxId' da chave composta
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Box box;

    // Construtor para facilitar a criação da associação (este construtor é mantido, Lombok gerará o @AllArgsConstructor também)
    public PatioBox(Patio patio, Box box) {
        this.patio = patio;
        this.box = box;
        // Garanta que getIdBox() existe na sua classe Box ou use o nome correto do getter do ID do Box
        this.id = new PatioBoxId(patio.getIdPatio(), box.getIdBox());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\PatioBoxId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: PatioBoxId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para PKs compostas
public class PatioBoxId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoBox
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOBOX")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoBoxId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId")
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Box box;

    public VeiculoBox(Veiculo veiculo, Box box) {
        this.veiculo = veiculo;
        this.box = box;
        this.id = new VeiculoBoxId(veiculo.getIdVeiculo(), box.getIdBox());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoBoxId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoBoxId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOPATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;

    public VeiculoPatio(Veiculo veiculo, Patio patio) {
        this.veiculo = veiculo;
        this.patio = patio;
        this.id = new VeiculoPatioId(veiculo.getIdVeiculo(), patio.getIdPatio());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoPatioId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamento.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoRastreamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULORASTREAMENTO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoRastreamento {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoRastreamentoId id;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Veiculo veiculo;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("rastreamentoId")
    @JoinColumn(name = "TB_RASTREAMENTO_ID_RASTREAMENTO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Rastreamento rastreamento;

    public VeiculoRastreamento(Veiculo veiculo, Rastreamento rastreamento) {
        this.veiculo = veiculo;
        this.rastreamento = rastreamento;
        this.id = new VeiculoRastreamentoId(veiculo.getIdVeiculo(), rastreamento.getIdRastreamento());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoRastreamentoId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoRastreamentoId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_RASTREAMENTO_ID_RASTREAMENTO", nullable = false)
    private Long rastreamentoId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoZona
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOZONA")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoZona {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoZonaId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Zona zona;

    public VeiculoZona(Veiculo veiculo, Zona zona) {
        this.veiculo = veiculo;
        this.zona = zona;
        this.id = new VeiculoZonaId(veiculo.getIdVeiculo(), zona.getIdZona());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: VeiculoZonaId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoZonaId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ZonaBox
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ZONABOX")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ZonaBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ZonaBoxId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Zona zona;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId")
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Box box;

    public ZonaBox(Zona zona, Box box) {
        this.zona = zona;
        this.box = box;
        this.id = new ZonaBoxId(zona.getIdZona(), box.getIdBox());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ZonaBoxId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ZonaBoxId implements Serializable {

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ZonaPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ZONAPATIO")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ZonaPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ZonaPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Zona zona;

    public ZonaPatio(Patio patio, Zona zona) {
        this.patio = patio;
        this.zona = zona;
        this.id = new ZonaPatioId(patio.getIdPatio(), zona.getIdZona());
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java   |   PACOTE: br.com.fiap.mottu.model.relacionamento   |   CLASSE: ZonaPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ZonaPatioId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.repository
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\BoxRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: BoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\BoxRepository.java
package br.com.fiap.mottu.repository;


import br.com.fiap.mottu.model.Box;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface BoxRepository extends JpaRepository<Box, Long>, JpaSpecificationExecutor<Box> {
    Optional<Box> findById(Long idBox); // Já disponível, mas explicitando
    List<Box> findByNomeContainingIgnoreCase(String nome); // Mantido para buscas parciais se necessário
    Optional<Box> findByNomeIgnoreCase(String nome); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomeIgnoreCase(String nome); // ADICIONADO como alternativa para checagem de duplicidade
    List<Box> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Box> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);


}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\ClienteRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: ClienteRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\ClienteRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Cliente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;


import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long>, JpaSpecificationExecutor<Cliente> {
    // Métodos de pesquisa avançada (derivados):
    // Cliente: cpf, id, nome, data de cadastro
    Optional<Cliente> findByCpf(String cpf);
    Optional<Cliente> findById(Long idCliente); // Já disponível, mas explicitando
    List<Cliente> findByNomeContainingIgnoreCase(String nome);
    List<Cliente> findByDataCadastroBetween(LocalDate startDate, LocalDate endDate);

}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\ContatoRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: ContatoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\ContatoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Contato;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface ContatoRepository extends JpaRepository<Contato, Long>, JpaSpecificationExecutor<Contato> {
    // Você pode adicionar métodos de busca por email, telefone, etc.
    Optional<Contato> findByEmail(String email);
    List<Contato> findByCelularContaining(String celular); // Exemplo de busca parcial por celular
    List<Contato> findByDddAndTelefone1(Integer ddd, String telefone1); // Exemplo de combinação
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\DashboardStatsRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: DashboardStatsRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Repository
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.dto.dashboard.OcupacaoDiaDto;
import br.com.fiap.mottu.model.Box;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDate;
import java.util.List;

@org.springframework.stereotype.Repository
public interface DashboardStatsRepository extends org.springframework.data.repository.Repository<Box, Long> {

    @Query("select count(b) from Box b")
    long countBoxes();

    @Query("select count(b) from Box b where b.status = 'O'")
    long countBoxesOcupados();

    @Query("select count(b) from Box b where b.status = 'L'")
    long countBoxesLivres();

    @Query("""
        select new br.com.fiap.mottu.dto.dashboard.OcupacaoDiaDto(
            b.dataEntrada,
            sum(case when b.status = 'O' then 1 else 0 end),
            sum(case when b.status = 'L' then 1 else 0 end)
        )
        from Box b
        where b.dataEntrada between :ini and :fim
        group by b.dataEntrada
        order by b.dataEntrada
    """)
    List<OcupacaoDiaDto> ocupacaoPorDia(@Param("ini") LocalDate ini,
                                        @Param("fim") LocalDate fim);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\EnderecoRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: EnderecoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\EnderecoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Endereco;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface EnderecoRepository extends JpaRepository<Endereco, Long>, JpaSpecificationExecutor<Endereco> {
    // Métodos de pesquisa avançada (derivados):
    Optional<Endereco> findByCep(String cep);
    List<Endereco> findByCidadeContainingIgnoreCase(String cidade);
    List<Endereco> findByEstado(String estado);
    List<Endereco> findByLogradouroContainingIgnoreCase(String logradouro);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\PatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: PatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\PatioRepository.java
package br.com.fiap.mottu.repository;


import br.com.fiap.mottu.model.Patio;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PatioRepository extends JpaRepository<Patio, Long>, JpaSpecificationExecutor<Patio> {
    Optional<Patio> findById(Long idPatio); // Já disponível, mas explicitando
    List<Patio> findByNomePatioContainingIgnoreCase(String nomePatio); // Mantido para buscas parciais
    Optional<Patio> findByNomePatioIgnoreCase(String nomePatio); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomePatioIgnoreCase(String nomePatio); // ADICIONADO como alternativa
    List<Patio> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Patio> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);


}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\RastreamentoRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: RastreamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Rastreamento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface RastreamentoRepository extends JpaRepository<Rastreamento, Long>, JpaSpecificationExecutor<Rastreamento> {
    // Métodos de busca customizados podem ser adicionados aqui se necessário. Por exemplo:
    List<Rastreamento> findByDataHoraRegistroBetween(LocalDateTime start, LocalDateTime end);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\VeiculoRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: VeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Veiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface VeiculoRepository extends JpaRepository<Veiculo, Long>, JpaSpecificationExecutor<Veiculo> {

    // ====== SEUS MÉTODOS ORIGINAIS (mantidos) ======
    Optional<Veiculo> findByPlaca(String placa);
    Optional<Veiculo> findByRenavam(String renavam);
    Optional<Veiculo> findByChassi(String chassi);
    Optional<Veiculo> findByTagBleId(String tagBleId); // NOVO MÉTODO

    List<Veiculo> findByModeloContainingIgnoreCase(String modelo);
    List<Veiculo> findByFabricanteContainingIgnoreCase(String fabricante);
    List<Veiculo> findByAno(Integer ano); // <-- corrigido: removido o 'A' que quebrava a compilação
    List<Veiculo> findByAnoBetween(Integer startAno, Integer endAno);
    List<Veiculo> findByCombustivelContainingIgnoreCase(String combustivel);

    // ====== ADIÇÕES MÍNIMAS (para o fluxo de OCR/estacionamento) ======
    /**
     * Match exato ignorando caixa. Evita depender do formato de caixa que o OCR/normalização devolver.
     */
    Optional<Veiculo> findByPlacaIgnoreCase(String placa);

    /**
     * Útil para validações rápidas de existência (opcional).
     */
    boolean existsByPlacaIgnoreCase(String placa);

    /**
     * Lista todas as placas em UPPERCASE — usada pelo fuzzy match após normalização Mercosul.
     */
    @Query("select upper(v.placa) from Veiculo v")
    List<String> listarPlacas();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\ZonaRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: ZonaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\ZonaRepository.java
package br.com.fiap.mottu.repository;


import br.com.fiap.mottu.model.Zona;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ZonaRepository extends JpaRepository<Zona, Long>, JpaSpecificationExecutor<Zona> {
    Optional<Zona> findById(Long idZona); // Já disponível, mas explicitando
    List<Zona> findByNomeContainingIgnoreCase(String nome); // Mantido para buscas parciais
    Optional<Zona> findByNomeIgnoreCase(String nome); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomeIgnoreCase(String nome); // ADICIONADO como alternativa
    List<Zona> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Zona> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);

}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\BoxRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: BoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\BoxRepository.java
package br.com.fiap.mottu.repository;


import br.com.fiap.mottu.model.Box;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface BoxRepository extends JpaRepository<Box, Long>, JpaSpecificationExecutor<Box> {
    Optional<Box> findById(Long idBox); // Já disponível, mas explicitando
    List<Box> findByNomeContainingIgnoreCase(String nome); // Mantido para buscas parciais se necessário
    Optional<Box> findByNomeIgnoreCase(String nome); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomeIgnoreCase(String nome); // ADICIONADO como alternativa para checagem de duplicidade
    List<Box> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Box> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);


}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\ClienteRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: ClienteRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\ClienteRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Cliente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;


import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long>, JpaSpecificationExecutor<Cliente> {
    // Métodos de pesquisa avançada (derivados):
    // Cliente: cpf, id, nome, data de cadastro
    Optional<Cliente> findByCpf(String cpf);
    Optional<Cliente> findById(Long idCliente); // Já disponível, mas explicitando
    List<Cliente> findByNomeContainingIgnoreCase(String nome);
    List<Cliente> findByDataCadastroBetween(LocalDate startDate, LocalDate endDate);

}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\ContatoRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: ContatoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\ContatoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Contato;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface ContatoRepository extends JpaRepository<Contato, Long>, JpaSpecificationExecutor<Contato> {
    // Você pode adicionar métodos de busca por email, telefone, etc.
    Optional<Contato> findByEmail(String email);
    List<Contato> findByCelularContaining(String celular); // Exemplo de busca parcial por celular
    List<Contato> findByDddAndTelefone1(Integer ddd, String telefone1); // Exemplo de combinação
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\DashboardStatsRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: DashboardStatsRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Repository
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.dto.dashboard.OcupacaoDiaDto;
import br.com.fiap.mottu.model.Box;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDate;
import java.util.List;

@org.springframework.stereotype.Repository
public interface DashboardStatsRepository extends org.springframework.data.repository.Repository<Box, Long> {

    @Query("select count(b) from Box b")
    long countBoxes();

    @Query("select count(b) from Box b where b.status = 'O'")
    long countBoxesOcupados();

    @Query("select count(b) from Box b where b.status = 'L'")
    long countBoxesLivres();

    @Query("""
        select new br.com.fiap.mottu.dto.dashboard.OcupacaoDiaDto(
            b.dataEntrada,
            sum(case when b.status = 'O' then 1 else 0 end),
            sum(case when b.status = 'L' then 1 else 0 end)
        )
        from Box b
        where b.dataEntrada between :ini and :fim
        group by b.dataEntrada
        order by b.dataEntrada
    """)
    List<OcupacaoDiaDto> ocupacaoPorDia(@Param("ini") LocalDate ini,
                                        @Param("fim") LocalDate fim);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\EnderecoRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: EnderecoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\EnderecoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Endereco;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface EnderecoRepository extends JpaRepository<Endereco, Long>, JpaSpecificationExecutor<Endereco> {
    // Métodos de pesquisa avançada (derivados):
    Optional<Endereco> findByCep(String cep);
    List<Endereco> findByCidadeContainingIgnoreCase(String cidade);
    List<Endereco> findByEstado(String estado);
    List<Endereco> findByLogradouroContainingIgnoreCase(String logradouro);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\PatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: PatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\PatioRepository.java
package br.com.fiap.mottu.repository;


import br.com.fiap.mottu.model.Patio;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PatioRepository extends JpaRepository<Patio, Long>, JpaSpecificationExecutor<Patio> {
    Optional<Patio> findById(Long idPatio); // Já disponível, mas explicitando
    List<Patio> findByNomePatioContainingIgnoreCase(String nomePatio); // Mantido para buscas parciais
    Optional<Patio> findByNomePatioIgnoreCase(String nomePatio); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomePatioIgnoreCase(String nomePatio); // ADICIONADO como alternativa
    List<Patio> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Patio> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);


}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\RastreamentoRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: RastreamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Rastreamento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface RastreamentoRepository extends JpaRepository<Rastreamento, Long>, JpaSpecificationExecutor<Rastreamento> {
    // Métodos de busca customizados podem ser adicionados aqui se necessário. Por exemplo:
    List<Rastreamento> findByDataHoraRegistroBetween(LocalDateTime start, LocalDateTime end);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\VeiculoRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: VeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Veiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface VeiculoRepository extends JpaRepository<Veiculo, Long>, JpaSpecificationExecutor<Veiculo> {

    // ====== SEUS MÉTODOS ORIGINAIS (mantidos) ======
    Optional<Veiculo> findByPlaca(String placa);
    Optional<Veiculo> findByRenavam(String renavam);
    Optional<Veiculo> findByChassi(String chassi);
    Optional<Veiculo> findByTagBleId(String tagBleId); // NOVO MÉTODO

    List<Veiculo> findByModeloContainingIgnoreCase(String modelo);
    List<Veiculo> findByFabricanteContainingIgnoreCase(String fabricante);
    List<Veiculo> findByAno(Integer ano); // <-- corrigido: removido o 'A' que quebrava a compilação
    List<Veiculo> findByAnoBetween(Integer startAno, Integer endAno);
    List<Veiculo> findByCombustivelContainingIgnoreCase(String combustivel);

    // ====== ADIÇÕES MÍNIMAS (para o fluxo de OCR/estacionamento) ======
    /**
     * Match exato ignorando caixa. Evita depender do formato de caixa que o OCR/normalização devolver.
     */
    Optional<Veiculo> findByPlacaIgnoreCase(String placa);

    /**
     * Útil para validações rápidas de existência (opcional).
     */
    boolean existsByPlacaIgnoreCase(String placa);

    /**
     * Lista todas as placas em UPPERCASE — usada pelo fuzzy match após normalização Mercosul.
     */
    @Query("select upper(v.placa) from Veiculo v")
    List<String> listarPlacas();
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\ZonaRepository.java   |   PACOTE: br.com.fiap.mottu.repository   |   CLASSE: ZonaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\ZonaRepository.java
package br.com.fiap.mottu.repository;


import br.com.fiap.mottu.model.Zona;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ZonaRepository extends JpaRepository<Zona, Long>, JpaSpecificationExecutor<Zona> {
    Optional<Zona> findById(Long idZona); // Já disponível, mas explicitando
    List<Zona> findByNomeContainingIgnoreCase(String nome); // Mantido para buscas parciais
    Optional<Zona> findByNomeIgnoreCase(String nome); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomeIgnoreCase(String nome); // ADICIONADO como alternativa
    List<Zona> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Zona> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.repository.relacionamento
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: ClienteVeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ClienteVeiculoRepository extends JpaRepository<ClienteVeiculo, ClienteVeiculoId>, JpaSpecificationExecutor<ClienteVeiculo> {
    // Métodos customizados podem ser úteis aqui
    List<ClienteVeiculo> findById_ClienteId(Long clienteId);
    List<ClienteVeiculo> findById_VeiculoId(Long veiculoId);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: ContatoPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ContatoPatio;
import br.com.fiap.mottu.model.relacionamento.ContatoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ContatoPatioRepository extends JpaRepository<ContatoPatio, ContatoPatioId>, JpaSpecificationExecutor<ContatoPatio> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: EnderecoPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.EnderecoPatio;
import br.com.fiap.mottu.model.relacionamento.EnderecoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface EnderecoPatioRepository extends JpaRepository<EnderecoPatio, EnderecoPatioId>, JpaSpecificationExecutor<EnderecoPatio> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\PatioBoxRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: PatioBoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.PatioBox;
import br.com.fiap.mottu.model.relacionamento.PatioBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface PatioBoxRepository extends JpaRepository<PatioBox, PatioBoxId>, JpaSpecificationExecutor<PatioBox> {
    // Métodos customizados podem ser adicionados aqui se necessário
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: VeiculoBoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoBoxRepository extends JpaRepository<VeiculoBox, VeiculoBoxId>, JpaSpecificationExecutor<VeiculoBox> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: VeiculoPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoPatioRepository extends JpaRepository<VeiculoPatio, VeiculoPatioId>, JpaSpecificationExecutor<VeiculoPatio> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: VeiculoRastreamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamentoId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoRastreamentoRepository extends JpaRepository<VeiculoRastreamento, VeiculoRastreamentoId>, JpaSpecificationExecutor<VeiculoRastreamento> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: VeiculoZonaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import br.com.fiap.mottu.model.relacionamento.VeiculoZonaId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoZonaRepository extends JpaRepository<VeiculoZona, VeiculoZonaId>, JpaSpecificationExecutor<VeiculoZona> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: ZonaBoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ZonaBox;
import br.com.fiap.mottu.model.relacionamento.ZonaBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ZonaBoxRepository extends JpaRepository<ZonaBox, ZonaBoxId>, JpaSpecificationExecutor<ZonaBox> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: ZonaPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.ZonaPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ZonaPatioRepository extends JpaRepository<ZonaPatio, ZonaPatioId>, JpaSpecificationExecutor<ZonaPatio> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: ClienteVeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ClienteVeiculoRepository extends JpaRepository<ClienteVeiculo, ClienteVeiculoId>, JpaSpecificationExecutor<ClienteVeiculo> {
    // Métodos customizados podem ser úteis aqui
    List<ClienteVeiculo> findById_ClienteId(Long clienteId);
    List<ClienteVeiculo> findById_VeiculoId(Long veiculoId);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: ContatoPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ContatoPatio;
import br.com.fiap.mottu.model.relacionamento.ContatoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ContatoPatioRepository extends JpaRepository<ContatoPatio, ContatoPatioId>, JpaSpecificationExecutor<ContatoPatio> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: EnderecoPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.EnderecoPatio;
import br.com.fiap.mottu.model.relacionamento.EnderecoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface EnderecoPatioRepository extends JpaRepository<EnderecoPatio, EnderecoPatioId>, JpaSpecificationExecutor<EnderecoPatio> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\PatioBoxRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: PatioBoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.PatioBox;
import br.com.fiap.mottu.model.relacionamento.PatioBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface PatioBoxRepository extends JpaRepository<PatioBox, PatioBoxId>, JpaSpecificationExecutor<PatioBox> {
    // Métodos customizados podem ser adicionados aqui se necessário
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: VeiculoBoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoBoxRepository extends JpaRepository<VeiculoBox, VeiculoBoxId>, JpaSpecificationExecutor<VeiculoBox> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: VeiculoPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoPatioRepository extends JpaRepository<VeiculoPatio, VeiculoPatioId>, JpaSpecificationExecutor<VeiculoPatio> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: VeiculoRastreamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamentoId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoRastreamentoRepository extends JpaRepository<VeiculoRastreamento, VeiculoRastreamentoId>, JpaSpecificationExecutor<VeiculoRastreamento> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: VeiculoZonaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import br.com.fiap.mottu.model.relacionamento.VeiculoZonaId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoZonaRepository extends JpaRepository<VeiculoZona, VeiculoZonaId>, JpaSpecificationExecutor<VeiculoZona> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: ZonaBoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ZonaBox;
import br.com.fiap.mottu.model.relacionamento.ZonaBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ZonaBoxRepository extends JpaRepository<ZonaBox, ZonaBoxId>, JpaSpecificationExecutor<ZonaBox> {
    // Adicione métodos de busca específicos se precisar
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java   |   PACOTE: br.com.fiap.mottu.repository.relacionamento   |   CLASSE: ZonaPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.ZonaPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ZonaPatioRepository extends JpaRepository<ZonaPatio, ZonaPatioId>, JpaSpecificationExecutor<ZonaPatio> {
    // Adicione métodos de busca específicos se precisar
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.service
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\BoxService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: BoxService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.box.BoxRequestDto; // DTO para entrada de dados de Box
import br.com.fiap.mottu.filter.BoxFilter; // Filtros para busca de Boxes
import br.com.fiap.mottu.mapper.BoxMapper; // Mapper para converter entre Entidade e DTOs de Box
import br.com.fiap.mottu.model.Box; // Entidade Box
import br.com.fiap.mottu.repository.BoxRepository; // Repositório para Box
import br.com.fiap.mottu.exception.DuplicatedResourceException; // Exceção para recursos duplicados
import br.com.fiap.mottu.exception.ResourceNotFoundException; // Exceção para recursos não encontrados
import br.com.fiap.mottu.specification.BoxSpecification; // Especificações para busca filtrada de Box
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict; // Para remover entradas do cache
import org.springframework.cache.annotation.CachePut; // Para atualizar entradas no cache
import org.springframework.cache.annotation.Cacheable; // Para armazenar resultados de métodos em cache
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para informações de paginação e ordenação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
import java.util.List; // Usado internamente, mas os métodos públicos retornarão Page

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class BoxService {

    private final BoxRepository boxRepository; // Repositório para operações de Box no banco
    private final BoxMapper boxMapper; // Mapper para converter entre DTOs e Entidade Box 

    @Autowired // Injeta as dependências automaticamente pelo Spring
    public BoxService(BoxRepository boxRepository, BoxMapper boxMapper) {
        this.boxRepository = boxRepository; // 
        this.boxMapper = boxMapper; // 
    }

    // Método para listar todos os boxes de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("boxesList") // Armazena em cache o resultado desta listagem paginada
    public Page<Box> listarTodosBoxes(Pageable pageable) {
        return boxRepository.findAll(pageable); // Busca todos os boxes usando paginação
    }

    // Método para buscar um box por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "boxPorId", key = "#id") // Armazena em cache o box buscado pelo ID
    public Box buscarBoxPorId(Long id) {
        return boxRepository.findById(id) // Busca o box pelo ID 
                .orElseThrow(() -> new ResourceNotFoundException("Box", id)); // Lança exceção se não encontrado 
    }

    // Método para buscar boxes por filtro e com paginação
    @Transactional(readOnly = true)
    public Page<Box> buscarBoxesPorFiltro(BoxFilter filter, Pageable pageable) {
        return boxRepository.findAll(BoxSpecification.withFilters(filter), pageable); // Busca boxes com filtros e paginação 
    }

    // Método para criar um novo box
    @Transactional // Transação de escrita
    @CacheEvict(value = {"boxesList", "boxPorId"}, allEntries = true) // Remove todas as entradas dos caches 'boxesList' e 'boxPorId' após criar um novo box
    public Box criarBox(BoxRequestDto boxRequestDto) {
        String nome = boxRequestDto.getNome(); // 
        // Verifica se já existe um box com o mesmo nome (ignorando maiúsculas/minúsculas)
        if (boxRepository.findByNomeIgnoreCase(nome).isPresent()) { // 
            throw new DuplicatedResourceException("Box", "nome", nome); // Lança exceção se nome duplicado 
        }
        Box box = boxMapper.toEntity(boxRequestDto); // Mapeia DTO para entidade 
        return boxRepository.save(box); // Salva o novo box 
    }

    // Método para atualizar um box existente
    @Transactional
    @CachePut(value = "boxPorId", key = "#id") // Atualiza o cache 'boxPorId' com o box modificado
    @CacheEvict(value = "boxesList", allEntries = true) // Invalida o cache de listagem
    public Box atualizarBox(Long id, BoxRequestDto boxRequestDto) {
        return boxRepository.findById(id) // Busca o box existente 
                .map(boxExistente -> { // Se encontrado, atualiza
                    String novoNome = boxRequestDto.getNome(); // 
                    // Verifica se o novo nome (se fornecido e diferente do atual) já existe em outro box
                    if (novoNome != null && !novoNome.isBlank() && !novoNome.equalsIgnoreCase(boxExistente.getNome())) {
                        if (boxRepository.findByNomeIgnoreCase(novoNome) // 
                                .filter(b -> !b.getIdBox().equals(id)) // Exclui o próprio box da checagem
                                .isPresent()) {
                            throw new DuplicatedResourceException("Box", "nome", novoNome); // Lança exceção se duplicado 
                        }
                    }
                    boxMapper.partialUpdate(boxRequestDto, boxExistente); // Atualiza a entidade com dados do DTO 
                    return boxRepository.save(boxExistente); // Salva as alterações
                })
                .orElseThrow(() -> new ResourceNotFoundException("Box", id)); // Lança exceção se não encontrado para atualização 
    }

    // Método para deletar um box
    @Transactional
    @CacheEvict(value = {"boxPorId", "boxesList"}, allEntries = true, key = "#id") // Remove o box dos caches relevantes
    public void deletarBox(Long id) {
        if (!boxRepository.existsById(id)) { // Verifica se o box existe 
            throw new ResourceNotFoundException("Box", id); // Lança exceção se não encontrado 
        }
        boxRepository.deleteById(id); // Deleta o box 
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\ClienteService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// java\br\com\fiap\mottu\service\ClienteService.java   |   package br.com.fiap.mottu.service   |   class ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto; // DTO para entrada de dados de Cliente
// import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto; // Não usado diretamente aqui, mas sim dentro do ClienteRequestDto
// import br.com.fiap.mottu.dto.contato.ContatoRequestDto; // Não usado diretamente aqui, mas sim dentro do ClienteRequestDto
import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.filter.ClienteFilter; // Filtros para busca de Clientes
import br.com.fiap.mottu.model.Cliente; // Entidade Cliente
import br.com.fiap.mottu.model.Contato; // Entidade Contato
import br.com.fiap.mottu.model.Endereco; // Entidade Endereco
import br.com.fiap.mottu.model.Veiculo; // Entidade Veiculo
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo; // Entidade de junção Cliente-Veiculo
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId; // ID composto para ClienteVeiculo
import br.com.fiap.mottu.repository.ClienteRepository; // Repositório para Cliente
import br.com.fiap.mottu.repository.relacionamento.ClienteVeiculoRepository; // Repositório para ClienteVeiculo
import br.com.fiap.mottu.repository.ContatoRepository; // Repositório para Contato
import br.com.fiap.mottu.repository.EnderecoRepository; // Repositório para Endereco
import br.com.fiap.mottu.repository.VeiculoRepository; // Repositório para Veiculo
import br.com.fiap.mottu.specification.ClienteSpecification; // Especificações para busca filtrada de Cliente
import br.com.fiap.mottu.exception.ResourceNotFoundException; // Exceção para recursos não encontrados
import br.com.fiap.mottu.exception.DuplicatedResourceException; // Exceção para recursos duplicados
import br.com.fiap.mottu.exception.InvalidInputException; // Exceção para entrada inválida
import br.com.fiap.mottu.mapper.ClienteMapper; // Mapper para Cliente
import br.com.fiap.mottu.mapper.ContatoMapper; // Mapper para Contato
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict; // Para invalidar cache
import org.springframework.cache.annotation.CachePut;   // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;  // Para habilitar cache em métodos
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
import reactor.core.publisher.Mono; // Para programação reativa (usado em criar/atualizar devido ao ViaCEP)

import java.util.Set; // Para coleções como Set de Veículos
import java.util.stream.Collectors; // Para operações com streams

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class ClienteService {

    private final ClienteRepository clienteRepository; // Repositório para Cliente
    private final EnderecoRepository enderecoRepository; // Repositório para Endereco
    private final ContatoRepository contatoRepository; // Repositório para Contato
    private final VeiculoRepository veiculoRepository; // Repositório para Veiculo
    private final ClienteVeiculoRepository clienteVeiculoRepository; // Repositório para a relação Cliente-Veiculo
    private final EnderecoService enderecoService; // Serviço de Endereco (para criar/atualizar endereço com ViaCEP)
    private final ClienteMapper clienteMapper; // Mapper para Cliente
    private final ContatoMapper contatoMapper; // Mapper para Contato

    @Autowired // Construtor para injeção de dependências
    public ClienteService(
            ClienteRepository clienteRepository,
            EnderecoRepository enderecoRepository,
            ContatoRepository contatoRepository,
            VeiculoRepository veiculoRepository,
            ClienteVeiculoRepository clienteVeiculoRepository,
            EnderecoService enderecoService, //
            ClienteMapper clienteMapper,
            ContatoMapper contatoMapper //
    ) {
        this.clienteRepository = clienteRepository;
        this.enderecoRepository = enderecoRepository; //
        this.contatoRepository = contatoRepository; //
        this.veiculoRepository = veiculoRepository; //
        this.clienteVeiculoRepository = clienteVeiculoRepository; //
        this.enderecoService = enderecoService; //
        this.clienteMapper = clienteMapper; //
        this.contatoMapper = contatoMapper; //
    }

    // Método para listar todos os clientes de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("clientesList") // Armazena em cache o resultado desta listagem paginada
    public Page<Cliente> listarTodosClientes(Pageable pageable) {
        return clienteRepository.findAll(pageable); // Busca todos os clientes usando paginação
    }

    // Método para buscar um cliente por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "clientePorId", key = "#id") // Armazena em cache o cliente buscado pelo ID
    public Cliente buscarClientePorId(Long id) {
        return clienteRepository.findById(id) // Busca o cliente pelo ID
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", id)); // Lança exceção se não encontrado
    }

    // Método para buscar clientes por filtro e com paginação
    @Transactional(readOnly = true)
    // Considerar adicionar caching aqui também se os filtros forem usados frequentemente com os mesmos parâmetros
    // Ex: @Cacheable(value = "clientesFiltrados", key = "{#filter, #pageable}")
    public Page<Cliente> buscarClientesPorFiltro(ClienteFilter filter, Pageable pageable) {
        return clienteRepository.findAll(ClienteSpecification.withFilters(filter), pageable); // Busca clientes com filtros e paginação
    }

    // Método para criar um novo cliente (reativo devido à chamada ao ViaCEP)
    @Transactional
    @CacheEvict(value = {"clientesList", "clientePorId", "veiculosDoCliente"}, allEntries = true) // Invalida caches relevantes
    public Mono<Cliente> criarCliente(ClienteRequestDto dto) { //
        // Verifica se já existe um cliente com o mesmo CPF
        if (clienteRepository.findByCpf(dto.getCpf()).isPresent()) { //
            return Mono.error(new DuplicatedResourceException("Cliente", "CPF", dto.getCpf())); //
        }

        // Lógica para obter ou criar Endereço (reativa)
        Mono<Endereco> enderecoMono = (dto.getEnderecoRequestDto().getIdEndereco() != null) //
                ? Mono.justOrEmpty(enderecoRepository.findById(dto.getEnderecoRequestDto().getIdEndereco())) //
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Endereço", dto.getEnderecoRequestDto().getIdEndereco()))) //
                : enderecoService.criarEndereco(dto.getEnderecoRequestDto()); // Chama o serviço de endereço (reativo)

        // Lógica para obter ou criar Contato (síncrona, mas envolvida no fluxo reativo)
        Mono<Contato> contatoMono = Mono.defer(() -> { // Envolve a lógica síncrona em Mono.defer para integrá-la corretamente ao fluxo reativo
            ContatoRequestDto contatoDto = dto.getContatoRequestDto(); //
            if (contatoDto.getIdContato() != null) { //
                return Mono.justOrEmpty(contatoRepository.findById(contatoDto.getIdContato())) //
                        .switchIfEmpty(Mono.error(new ResourceNotFoundException("Contato", contatoDto.getIdContato()))); //
            } else {
                // Checagem de duplicação de e-mail para novos contatos
                if (contatoDto.getEmail() != null && contatoRepository.findByEmail(contatoDto.getEmail()).isPresent()) { //
                    return Mono.error(new DuplicatedResourceException("Contato", "email", contatoDto.getEmail()));
                }
                return Mono.just(contatoRepository.save(contatoMapper.toEntity(contatoDto))); //
            }
        });

        // Combina os resultados reativos de endereço e contato para criar o cliente
        return Mono.zip(enderecoMono, contatoMono) //
                .flatMap(tuple -> {
                    Cliente cliente = clienteMapper.toEntity(dto); // Mapeia DTO para entidade
                    cliente.setEndereco(tuple.getT1()); // Associa o endereço
                    cliente.setContato(tuple.getT2()); // Associa o contato
                    return Mono.just(clienteRepository.save(cliente)); // Salva o cliente
                })
                .onErrorResume(e -> { // Tratamento de erro para o fluxo reativo
                    if (e instanceof ResourceNotFoundException || e instanceof DuplicatedResourceException || e instanceof InvalidInputException) { //
                        return Mono.error(e); // Repassa exceções conhecidas
                    }
                    // Para outras exceções, encapsula em InvalidInputException
                    return Mono.error(new InvalidInputException("Erro inesperado ao criar cliente: " + e.getMessage())); //
                });
    }

    // Método para atualizar um cliente existente (reativo)
    @Transactional
    @CacheEvict(value = {"clientesList", "veiculosDoCliente"}, allEntries = true) // Invalida caches de listagem
    @CachePut(value = "clientePorId", key = "#id") // Atualiza o cache específico do cliente
    public Mono<Cliente> atualizarCliente(Long id, ClienteRequestDto dto) { //
        return Mono.justOrEmpty(clienteRepository.findById(id)) // Busca o cliente existente
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Cliente", id))) // Se não encontrar, lança erro
                .flatMap(clienteExistente -> {
                    // Verifica duplicação de CPF se estiver sendo alterado
                    if (dto.getCpf() != null && !dto.getCpf().equals(clienteExistente.getCpf()) && clienteRepository.findByCpf(dto.getCpf()).isPresent()) { //
                        return Mono.error(new DuplicatedResourceException("Cliente", "CPF", dto.getCpf())); //
                    }

                    clienteMapper.partialUpdate(dto, clienteExistente); // Atualiza campos básicos do cliente

                    // Lógica para atualizar ou criar Endereço (reativa)
                    Mono<Endereco> enderecoMono;
                    if (dto.getEnderecoRequestDto() != null) { //
                        if (dto.getEnderecoRequestDto().getIdEndereco() != null) { //
                            // Atualiza endereço existente
                            enderecoMono = enderecoService.atualizarEndereco(dto.getEnderecoRequestDto().getIdEndereco(), dto.getEnderecoRequestDto()); //
                        } else {
                            // Cria novo endereço
                            enderecoMono = enderecoService.criarEndereco(dto.getEnderecoRequestDto()); //
                        }
                        enderecoMono = enderecoMono.doOnNext(clienteExistente::setEndereco); // Associa o endereço atualizado/criado ao cliente
                    } else {
                        enderecoMono = Mono.just(clienteExistente.getEndereco()); // Mantém o endereço existente se não houver DTO de endereço
                    }

                    // Lógica para atualizar ou criar Contato (reativa)
                    Mono<Contato> contatoMono;
                    if (dto.getContatoRequestDto() != null) { //
                        ContatoRequestDto contatoDto = dto.getContatoRequestDto();
                        if (contatoDto.getIdContato() != null) { //
                            // Atualiza contato existente
                            contatoMono = Mono.justOrEmpty(contatoRepository.findById(contatoDto.getIdContato())) //
                                    .switchIfEmpty(Mono.error(new ResourceNotFoundException("Contato", contatoDto.getIdContato()))) //
                                    .flatMap(contatoExistente -> {
                                        // Checagem de duplicação de e-mail se estiver sendo alterado para um e-mail que já existe em outro contato
                                        if (contatoDto.getEmail() != null && !contatoDto.getEmail().equals(contatoExistente.getEmail()) &&
                                                contatoRepository.findByEmail(contatoDto.getEmail()).filter(c -> !c.getIdContato().equals(contatoExistente.getIdContato())).isPresent()) { //
                                            return Mono.error(new DuplicatedResourceException("Contato", "email", contatoDto.getEmail()));
                                        }
                                        contatoMapper.partialUpdate(contatoDto, contatoExistente); //
                                        return Mono.just(contatoRepository.save(contatoExistente)); //
                                    });
                        } else {
                            // Cria novo contato
                            // Checagem de duplicação de e-mail para novos contatos
                            if (contatoDto.getEmail() != null && contatoRepository.findByEmail(contatoDto.getEmail()).isPresent()) { //
                                return Mono.error(new DuplicatedResourceException("Contato", "email", contatoDto.getEmail()));
                            }
                            contatoMono = Mono.just(contatoRepository.save(contatoMapper.toEntity(contatoDto))); //
                        }
                        contatoMono = contatoMono.doOnNext(clienteExistente::setContato); // Associa o contato atualizado/criado ao cliente
                    } else {
                        contatoMono = Mono.just(clienteExistente.getContato()); // Mantém o contato existente
                    }

                    // Espera a conclusão das operações de endereço e contato, depois salva o cliente
                    return Mono.when(enderecoMono, contatoMono).then(Mono.fromCallable(() -> clienteRepository.save(clienteExistente)));
                })
                .onErrorResume(e -> { // Tratamento de erro para o fluxo reativo
                    if (e instanceof ResourceNotFoundException || e instanceof DuplicatedResourceException || e instanceof InvalidInputException) { //
                        return Mono.error(e);
                    }
                    return Mono.error(new InvalidInputException("Erro inesperado ao atualizar cliente: " + e.getMessage())); //
                });
    }

    // Método para deletar um cliente
    @Transactional
    @CacheEvict(value = {"clientesList", "clientePorId", "veiculosDoCliente"}, allEntries = true, key = "#id") // Remove o cliente de todos os caches relevantes
    public void deletarCliente(Long id) {
        if (!clienteRepository.existsById(id)) { // Verifica se o cliente existe
            throw new ResourceNotFoundException("Cliente", id); // Lança exceção se não encontrado
        }
        // Considerar a lógica de desassociação ou o que acontece com Endereco e Contato se forem exclusivos deste cliente
        // Atualmente, Endereco e Contato não são excluídos automaticamente aqui, apenas o Cliente e suas associações diretas (ClienteVeiculo).
        clienteRepository.deleteById(id); // Deleta o cliente
    }

    // Método para associar um veículo a um cliente
    @Transactional
    @CacheEvict(value = {"clientePorId", "veiculosDoCliente"}, key = "#clienteId", allEntries = true) // Invalida caches do cliente específico
    public ClienteVeiculo associarClienteVeiculo(Long clienteId, Long enderecoId, Long contatoId, Long veiculoId) {
        // Busca o cliente ou lança exceção
        Cliente cliente = clienteRepository.findById(clienteId) //
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", clienteId)); //
        // Busca o veículo ou lança exceção
        Veiculo veiculo = veiculoRepository.findById(veiculoId) //
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", veiculoId)); //

        // Valida se os IDs de endereço e contato no ClienteVeiculoId correspondem aos do Cliente buscado
        if (!cliente.getEndereco().getIdEndereco().equals(enderecoId)) {
            throw new InvalidInputException("ID do endereço fornecido (" + enderecoId + ") não corresponde ao endereço associado ao cliente (" + cliente.getEndereco().getIdEndereco() + ").");
        }
        if (!cliente.getContato().getIdContato().equals(contatoId)) {
            throw new InvalidInputException("ID do contato fornecido (" + contatoId + ") não corresponde ao contato associado ao cliente (" + cliente.getContato().getIdContato() + ").");
        }

        ClienteVeiculoId id = new ClienteVeiculoId(clienteId, enderecoId, contatoId, veiculoId); // Cria o ID composto
        if (clienteVeiculoRepository.existsById(id)) { // Verifica se a associação já existe
            throw new DuplicatedResourceException("Associação Cliente-Veículo", "IDs", id.toString()); //
        }
        ClienteVeiculo associacao = new ClienteVeiculo(cliente, veiculo); // Cria a entidade de relacionamento
        return clienteVeiculoRepository.save(associacao); // Salva a associação
    }

    // Método para desassociar um veículo de um cliente
    @Transactional
    @CacheEvict(value = {"clientePorId", "veiculosDoCliente"}, key = "#clienteId", allEntries = true) // Invalida caches do cliente
    public void desassociarClienteVeiculo(Long clienteId, Long enderecoId, Long contatoId, Long veiculoId) { //
        ClienteVeiculoId id = new ClienteVeiculoId(clienteId, enderecoId, contatoId, veiculoId); // Cria o ID composto
        if (!clienteVeiculoRepository.existsById(id)) { // Verifica se a associação existe para ser removida
            throw new ResourceNotFoundException("Associação Cliente-Veículo", "IDs", id.toString()); //
        }
        clienteVeiculoRepository.deleteById(id); // Remove a associação
    }

    // Método para listar os veículos de um cliente
    @Transactional(readOnly = true)
    @Cacheable(value = "veiculosDoCliente", key = "#clienteId") // Armazena em cache a lista de veículos do cliente
    public Set<Veiculo> getVeiculosByClienteId(Long clienteId) {
        Cliente cliente = clienteRepository.findById(clienteId) // Busca o cliente
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", clienteId)); // Lança exceção se não encontrado
        // Mapeia as associações ClienteVeiculo para obter apenas as entidades Veiculo
        return cliente.getClienteVeiculos().stream() //
                .map(ClienteVeiculo::getVeiculo) //
                .collect(Collectors.toSet()); //
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\ContatoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: ContatoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto; // DTO para entrada de dados de Contato
import br.com.fiap.mottu.filter.ContatoFilter; // Filtros para busca de Contatos
import br.com.fiap.mottu.mapper.ContatoMapper; // Mapper para converter entre Entidade e DTOs de Contato 
import br.com.fiap.mottu.model.Contato; // Entidade Contato 
import br.com.fiap.mottu.repository.ContatoRepository; // Repositório para Contato 
import br.com.fiap.mottu.exception.*; // Importa todas as exceções customizadas (DuplicatedResourceException, ResourceNotFoundException, etc.)
import br.com.fiap.mottu.specification.ContatoSpecification; // Especificações para busca filtrada de Contato 
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict; // Para invalidar cache
import org.springframework.cache.annotation.CachePut;   // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;  // Para habilitar cache em métodos
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
// import java.util.List; // Não será mais o tipo de retorno público principal para listagens

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class ContatoService {

    private final ContatoRepository contatoRepository; // Repositório para operações de Contato no banco
    private final ContatoMapper contatoMapper; // Mapper para Contato 

    @Autowired // Injeta as dependências automaticamente pelo Spring
    public ContatoService(ContatoRepository contatoRepository, ContatoMapper contatoMapper) {
        this.contatoRepository = contatoRepository; // 
        this.contatoMapper = contatoMapper; // 
    }

    // Método para listar todos os contatos de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("contatosList") // Armazena em cache o resultado desta listagem paginada
    public Page<Contato> listarTodosContatos(Pageable pageable) {
        return contatoRepository.findAll(pageable); // Busca todos os contatos usando paginação
    }

    // Método para buscar um contato por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "contatoPorId", key = "#id") // Armazena em cache o contato buscado pelo ID
    public Contato buscarContatoPorId(Long id) {
        return contatoRepository.findById(id) // Busca o contato pelo ID 
                .orElseThrow(() -> new ResourceNotFoundException("Contato", id)); // Lança exceção se não encontrado 
    }

    // Método para buscar contatos por filtro e com paginação
    @Transactional(readOnly = true)
    // @Cacheable(value = "contatosFiltrados", key = "{#filter, #pageable}") // Considere adicionar se aplicável
    public Page<Contato> buscarContatosPorFiltro(ContatoFilter filter, Pageable pageable) {
        return contatoRepository.findAll(ContatoSpecification.withFilters(filter), pageable); // Busca contatos com filtros e paginação 
    }

    // Método para criar um novo contato
    @Transactional // Transação de escrita
    @CacheEvict(value = {"contatosList", "contatoPorId"}, allEntries = true) // Invalida caches relevantes
    public Contato criarContato(ContatoRequestDto dto) { // 
        String email = dto.getEmail(); // 
        // Verifica se já existe um contato com o mesmo e-mail
        if (contatoRepository.findByEmail(email).isPresent()) { // 
            throw new DuplicatedResourceException("Contato", "email", email); // Lança exceção se e-mail duplicado 
        }
        Contato contato = contatoMapper.toEntity(dto); // Mapeia DTO para entidade 
        return contatoRepository.save(contato); // Salva o novo contato 
    }

    // Método para atualizar um contato existente
    @Transactional
    @CachePut(value = "contatoPorId", key = "#id") // Atualiza o cache 'contatoPorId' com o contato modificado
    @CacheEvict(value = "contatosList", allEntries = true) // Invalida o cache de listagem
    public Contato atualizarContato(Long id, ContatoRequestDto dto) { // 
        return contatoRepository.findById(id) // Busca o contato existente 
                .map(existente -> { // Se encontrado, atualiza
                    String novoEmail = dto.getEmail(); // 
                    // Verifica se o novo e-mail (se fornecido e diferente do atual) já existe em outro contato
                    if (novoEmail != null && !novoEmail.isBlank() && !novoEmail.equalsIgnoreCase(existente.getEmail())) {
                        if (contatoRepository.findByEmail(novoEmail) // 
                                .filter(c -> !c.getIdContato().equals(id)) // Exclui o próprio contato da checagem
                                .isPresent()) {
                            throw new DuplicatedResourceException("Contato", "email", novoEmail); // Lança exceção se duplicado 
                        }
                    }
                    contatoMapper.partialUpdate(dto, existente); // Atualiza a entidade com dados do DTO 
                    return contatoRepository.save(existente); // Salva as alterações
                })
                .orElseThrow(() -> new ResourceNotFoundException("Contato", id)); // Lança exceção se não encontrado para atualização 
    }

    // Método para deletar um contato
    @Transactional
    @CacheEvict(value = {"contatoPorId", "contatosList"}, allEntries = true, key = "#id") // Remove o contato dos caches relevantes
    public void deletarContato(Long id) {
        if (!contatoRepository.existsById(id)) { // Verifica se o contato existe 
            throw new ResourceNotFoundException("Contato", id); // Lança exceção se não encontrado 
        }
        contatoRepository.deleteById(id); // Deleta o contato 
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\DashboardService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: DashboardService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.dashboard.OcupacaoDiaDto;
import br.com.fiap.mottu.dto.dashboard.ResumoOcupacaoDto;
import br.com.fiap.mottu.repository.DashboardStatsRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;

@Service
@Transactional(readOnly = true)
public class DashboardService {

    private final DashboardStatsRepository repo;

    public DashboardService(DashboardStatsRepository repo) {
        this.repo = repo;
    }

    public ResumoOcupacaoDto getResumoAtual() {
        long total  = repo.countBoxes();
        long ocup   = repo.countBoxesOcupados();
        long livres = repo.countBoxesLivres(); // ou total - ocup
        return new ResumoOcupacaoDto(total, ocup, livres);
    }

    public List<OcupacaoDiaDto> getOcupacaoPorDia(LocalDate ini, LocalDate fim) {
        return repo.ocupacaoPorDia(ini, fim);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\EnderecoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: EnderecoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto; // DTO para entrada de dados de Endereço
import br.com.fiap.mottu.external.viacep.ViaCepService; // Serviço para consulta ao ViaCEP
import br.com.fiap.mottu.model.Endereco; // Entidade Endereço
import br.com.fiap.mottu.mapper.EnderecoMapper; // Mapper para Endereço
import br.com.fiap.mottu.repository.EnderecoRepository; // Repositório para Endereço
import br.com.fiap.mottu.exception.ResourceNotFoundException; // Exceção para recursos não encontrados
import br.com.fiap.mottu.exception.InvalidInputException; // Exceção para entrada inválida
import br.com.fiap.mottu.filter.EnderecoFilter; // Filtros para busca de Endereços
import br.com.fiap.mottu.specification.EnderecoSpecification; // Especificações para busca filtrada de Endereços
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict;    // Para invalidar cache
import org.springframework.cache.annotation.CachePut;      // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;     // Para habilitar cache em métodos
import org.springframework.data.domain.Page;          // Para resultados paginados
import org.springframework.data.domain.Pageable;        // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
import reactor.core.publisher.Mono; // Para programação reativa (ViaCEP)
// import java.util.List; // Não é mais o tipo de retorno público principal para listagens

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class EnderecoService {

    private final EnderecoRepository enderecoRepository; // Repositório para Endereço
    private final EnderecoMapper enderecoMapper; // Mapper para Endereço
    private final ViaCepService viaCepService; // Serviço para consulta ao ViaCEP

    @Autowired // Construtor para injeção de dependências
    public EnderecoService(EnderecoRepository enderecoRepository,
                           EnderecoMapper enderecoMapper,
                           ViaCepService viaCepService) { //
        this.enderecoRepository = enderecoRepository;
        this.enderecoMapper = enderecoMapper; //
        this.viaCepService = viaCepService; //
    }

    // Método para listar todos os endereços de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("enderecosList") // Armazena em cache o resultado desta listagem paginada
    public Page<Endereco> listarTodosEnderecos(Pageable pageable) {
        return enderecoRepository.findAll(pageable); // Busca todos os endereços usando paginação
    }

    // Método para buscar um endereço por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "enderecoPorId", key = "#id") // Armazena em cache o endereço buscado pelo ID
    public Endereco buscarEnderecoPorId(Long id) {
        return enderecoRepository.findById(id) // Busca o endereço pelo ID
                .orElseThrow(() -> new ResourceNotFoundException("Endereço", id)); // Lança exceção se não encontrado
    }

    // NOVO: Método para buscar endereços por filtro e com paginação
    @Transactional(readOnly = true)
    // @Cacheable(value = "enderecosFiltrados", key = "{#filter, #pageable}") // Considere adicionar se aplicável
    public Page<Endereco> buscarEnderecosPorFiltro(EnderecoFilter filter, Pageable pageable) {
        return enderecoRepository.findAll(EnderecoSpecification.withFilters(filter), pageable); // Busca endereços com filtros e paginação
    }

    // Método para criar um novo endereço (reativo devido à chamada ao ViaCEP)
    @Transactional
    // Invalidar caches de listagem ao criar um novo endereço. O cache individual não faz sentido para criar.
    @CacheEvict(value = {"enderecosList", "enderecoPorId", "enderecosFiltrados"}, allEntries = true)
    public Mono<Endereco> criarEndereco(EnderecoRequestDto dto) { //
        // Validação básica do CEP
        if (dto.getCep() == null || dto.getCep().isBlank()) { //
            return Mono.error(new InvalidInputException("CEP não pode ser nulo ou vazio.")); //
        }

        // Consulta o ViaCEP de forma reativa
        return viaCepService.buscarEnderecoPorCep(dto.getCep()) //
                .flatMap(viaCepResponse -> { // Se o CEP for encontrado no ViaCEP
                    Endereco endereco = enderecoMapper.toEntity(dto); // Mapeia o DTO para a entidade Endereco
                    // Preenche os campos do endereço com os dados retornados pelo ViaCEP
                    endereco.setLogradouro(viaCepResponse.getLogradouro()); //
                    endereco.setBairro(viaCepResponse.getBairro()); //
                    endereco.setCidade(viaCepResponse.getLocalidade()); //
                    endereco.setEstado(viaCepResponse.getUf()); //
                    endereco.setPais("Brasil"); // Define o país como Brasil (ViaCEP é nacional)
                    // Salva o endereço preenchido no banco de dados
                    return Mono.just(enderecoRepository.save(endereco)); //
                })
                // Se o CEP não for encontrado no ViaCEP (switchIfEmpty é acionado se o Mono anterior estiver vazio)
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Dados de CEP", "cep", dto.getCep()))) //
                .onErrorResume(e -> { // Trata erros que podem ocorrer durante o processo
                    // Se for uma exceção já conhecida (ResourceNotFoundException ou InvalidInputException), repassa
                    if (e instanceof ResourceNotFoundException || e instanceof InvalidInputException) { //
                        return Mono.error(e);
                    }
                    // Para outras exceções, encapsula em InvalidInputException
                    return Mono.error(new InvalidInputException("Erro ao consultar ViaCEP ou salvar endereço: " + e.getMessage())); //
                });
    }


    // Método para atualizar um endereço existente (reativo)
    @Transactional
    @CacheEvict(value = {"enderecosList", "enderecosFiltrados"}, allEntries = true) // Invalida caches de listagem
    @CachePut(value = "enderecoPorId", key = "#id") // Atualiza o cache específico do endereço
    public Mono<Endereco> atualizarEndereco(Long id, EnderecoRequestDto dto) { //
        return Mono.justOrEmpty(enderecoRepository.findById(id)) // Busca o endereço existente
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Endereço", id))) // Se não encontrar, lança erro
                .flatMap(enderecoExistente -> {
                    // Se um novo CEP foi fornecido no DTO, consulta o ViaCEP para atualizar os dados
                    if (dto.getCep() != null && !dto.getCep().isBlank() && !dto.getCep().equals(enderecoExistente.getCep())) { //
                        return viaCepService.buscarEnderecoPorCep(dto.getCep()) //
                                .flatMap(viaCepResponse -> {
                                    enderecoMapper.partialUpdate(dto, enderecoExistente); // Atualiza campos básicos do DTO
                                    // Preenche com os novos dados do ViaCEP
                                    enderecoExistente.setLogradouro(viaCepResponse.getLogradouro()); //
                                    enderecoExistente.setBairro(viaCepResponse.getBairro()); //
                                    enderecoExistente.setCidade(viaCepResponse.getLocalidade()); //
                                    enderecoExistente.setEstado(viaCepResponse.getUf()); //
                                    enderecoExistente.setPais("Brasil"); //
                                    return Mono.just(enderecoRepository.save(enderecoExistente)); // Salva o endereço atualizado
                                })
                                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Dados de CEP para atualização", "CEP", dto.getCep()))); //
                    } else {
                        // Se o CEP não mudou ou não foi fornecido, apenas atualiza os outros campos do DTO
                        enderecoMapper.partialUpdate(dto, enderecoExistente); //
                        return Mono.just(enderecoRepository.save(enderecoExistente)); // Salva o endereço atualizado
                    }
                })
                .onErrorResume(e -> { // Tratamento de erro
                    if (e instanceof ResourceNotFoundException || e instanceof InvalidInputException) { //
                        return Mono.error(e);
                    }
                    return Mono.error(new InvalidInputException("Erro inesperado ao atualizar endereço: " + e.getMessage())); //
                });
    }

    // Método para deletar um endereço
    @Transactional
    @CacheEvict(value = {"enderecoPorId", "enderecosList", "enderecosFiltrados"}, allEntries = true, key = "#id") // Remove o endereço dos caches relevantes
    public void deletarEndereco(Long id) {
        if (!enderecoRepository.existsById(id)) { // Verifica se o endereço existe
            throw new ResourceNotFoundException("Endereço", id); // Lança exceção se não encontrado
        }
        enderecoRepository.deleteById(id); // Deleta o endereço
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\EstacionamentoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: EstacionamentoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.exception.InvalidInputException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.repository.BoxRepository;
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.repository.relacionamento.VeiculoBoxRepository;
import br.com.fiap.mottu.service.ocr.PlateUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class EstacionamentoService {

    private final VeiculoRepository veiculoRepository;
    private final BoxRepository boxRepository;
    private final VeiculoBoxRepository veiculoBoxRepository;

    @Autowired
    public EstacionamentoService(VeiculoRepository veiculoRepository,
                                 BoxRepository boxRepository,
                                 VeiculoBoxRepository veiculoBoxRepository) {
        this.veiculoRepository = veiculoRepository;
        this.boxRepository = boxRepository;
        this.veiculoBoxRepository = veiculoBoxRepository;
    }

    @Transactional
    public Box parkMoto(String placa) {
        // 1) normaliza a placa recebida (corrige O↔0, I↔1, etc.) e usa UPPERCASE
        String normalized = PlateUtils.normalizeMercosul(placa);
        if (normalized.isEmpty()) {
            throw new InvalidInputException("Placa inválida.");
        }

        // 2) tenta match exato primeiro
        Optional<Veiculo> opt = veiculoRepository.findByPlaca(normalized);

        // 3) se não achou, faz fuzzy contra todas as placas cadastradas (normalizadas)
        Veiculo veiculo = opt.orElseGet(() -> {
            List<Veiculo> all = veiculoRepository.findAll();
            if (all.isEmpty()) throw new ResourceNotFoundException("Nenhum veículo cadastrado.");
            // Lista normalizada
            List<VeiculoNormalized> norm = all.stream()
                    .map(v -> new VeiculoNormalized(v, PlateUtils.normalizeMercosul(v.getPlaca())))
                    .collect(Collectors.toList());
            String bestPlate = PlateUtils.bestCandidate(
                    norm.stream().map(VeiculoNormalized::normalized).collect(Collectors.toList()),
                    normalized,
                    1 // tolera 1 erro; ajuste p/ 2 se necessário
            );
            if (bestPlate == null) {
                throw new ResourceNotFoundException("Veículo com placa " + placa + " não cadastrado.");
            }
            return norm.stream()
                    .min(Comparator.comparingInt(vn -> PlateUtils.levenshtein(vn.normalized(), normalized)))
                    .filter(vn -> PlateUtils.levenshtein(vn.normalized(), normalized) <= 1)
                    .map(VeiculoNormalized::entity)
                    .orElseThrow(() -> new ResourceNotFoundException("Veículo com placa " + placa + " não cadastrado."));
        });

        // 4) já estacionado?
        if (veiculo.getVeiculoBoxes() != null && !veiculo.getVeiculoBoxes().isEmpty()) {
            throw new InvalidInputException("Veículo de placa " + veiculo.getPlaca() + " já está estacionado.");
        }

        // 5) encontra primeira vaga livre
        Box vagaLivre = boxRepository.findAll().stream()
                .filter(box -> "L".equals(box.getStatus()))
                .findFirst()
                .orElseThrow(() -> new ResourceNotFoundException("Nenhuma vaga livre encontrada."));

        vagaLivre.setStatus("O");
        boxRepository.save(vagaLivre);

        VeiculoBox associacao = new VeiculoBox(veiculo, vagaLivre);
        veiculoBoxRepository.save(associacao);

        return vagaLivre;
    }

    @Transactional
    public void releaseSpot(String placa) {
        String normalized = PlateUtils.normalizeMercosul(placa);
        if (normalized.isEmpty()) {
            throw new InvalidInputException("Placa inválida.");
        }

        Veiculo veiculo = veiculoRepository.findByPlaca(normalized)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo com placa " + placa + " não encontrado."));

        VeiculoBox associacao = veiculo.getVeiculoBoxes().stream()
                .findFirst()
                .orElseThrow(() -> new ResourceNotFoundException("Veículo com placa " + placa + " não está estacionado em nenhum box."));

        Box boxOcupado = associacao.getBox();
        boxOcupado.setStatus("L");
        boxRepository.save(boxOcupado);

        veiculoBoxRepository.deleteById(associacao.getId());
    }

    /** Par auxiliar para manter a entidade + sua placa normalizada. */
    private record VeiculoNormalized(Veiculo entity, String normalized) {}
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\PatioService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: PatioService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.patio.PatioRequestDto; // DTO para entrada de dados de Pátio
import br.com.fiap.mottu.filter.PatioFilter; // Filtros para busca de Pátios
import br.com.fiap.mottu.mapper.PatioMapper; // Mapper para Pátio
import br.com.fiap.mottu.model.Patio; // Entidade Pátio
import br.com.fiap.mottu.model.Veiculo; // Entidade Veículo
import br.com.fiap.mottu.model.Zona; // Entidade Zona
import br.com.fiap.mottu.model.Box; // Entidade Box
import br.com.fiap.mottu.model.Contato; // Entidade Contato
import br.com.fiap.mottu.model.Endereco; // Entidade Endereço
// Entidades de Relacionamento e IDs
import br.com.fiap.mottu.model.relacionamento.*; // Importa todas as entidades de relacionamento
import br.com.fiap.mottu.repository.PatioRepository; // Repositório para Pátio
import br.com.fiap.mottu.repository.VeiculoRepository; // Repositório para Veículo
import br.com.fiap.mottu.repository.ZonaRepository; // Repositório para Zona
import br.com.fiap.mottu.repository.BoxRepository;          // Repositório para Box
import br.com.fiap.mottu.repository.ContatoRepository; // Repositório para Contato
import br.com.fiap.mottu.repository.EnderecoRepository; // Repositório para Endereço
// Repositórios de Relacionamento
import br.com.fiap.mottu.repository.relacionamento.*; // Importa todos os repositórios de relacionamento
import br.com.fiap.mottu.exception.DuplicatedResourceException; // Exceção para recursos duplicados
import br.com.fiap.mottu.exception.ResourceNotFoundException; // Exceção para recursos não encontrados
import br.com.fiap.mottu.specification.PatioSpecification; // Especificações para busca filtrada de Pátios
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict;    // Para invalidar cache
import org.springframework.cache.annotation.CachePut;      // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;     // Para habilitar cache em métodos
import org.springframework.data.domain.Page;          // Para resultados paginados
import org.springframework.data.domain.Pageable;        // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
import java.util.Set; // Para coleções
import java.util.stream.Collectors; // Para operações com streams

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class PatioService {

    private final PatioRepository patioRepository; // Repositório para Pátio
    private final PatioMapper patioMapper; // Mapper para Pátio
    private final VeiculoRepository veiculoRepository; // Repositório para Veículo
    private final ZonaRepository zonaRepository; // Repositório para Zona
    private final BoxRepository boxRepository; // Repositório para Box
    private final ContatoRepository contatoRepository; // Repositório para Contato
    private final EnderecoRepository enderecoRepository; // Repositório para Endereço
    // Repositórios das tabelas de junção
    private final VeiculoPatioRepository veiculoPatioRepository; //
    private final ZonaPatioRepository zonaPatioRepository; //
    private final ContatoPatioRepository contatoPatioRepository; //
    private final EnderecoPatioRepository enderecoPatioRepository; //
    private final PatioBoxRepository patioBoxRepository; //


    @Autowired // Construtor para injeção de dependências
    public PatioService(PatioRepository patioRepository, PatioMapper patioMapper,
                        VeiculoRepository veiculoRepository, ZonaRepository zonaRepository,
                        ContatoRepository contatoRepository, EnderecoRepository enderecoRepository,
                        VeiculoPatioRepository veiculoPatioRepository, ZonaPatioRepository zonaPatioRepository,
                        ContatoPatioRepository contatoPatioRepository, EnderecoPatioRepository enderecoPatioRepository,
                        BoxRepository boxRepository, PatioBoxRepository patioBoxRepository) { //
        this.patioRepository = patioRepository;
        this.patioMapper = patioMapper; //
        this.veiculoRepository = veiculoRepository;
        this.zonaRepository = zonaRepository;
        this.boxRepository = boxRepository; //
        this.contatoRepository = contatoRepository;
        this.enderecoRepository = enderecoRepository;
        this.veiculoPatioRepository = veiculoPatioRepository;
        this.zonaPatioRepository = zonaPatioRepository; //
        this.contatoPatioRepository = contatoPatioRepository;
        this.enderecoPatioRepository = enderecoPatioRepository;
        this.patioBoxRepository = patioBoxRepository; //
    }

    // Método para listar todos os pátios de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("patiosList") // Armazena em cache o resultado desta listagem paginada
    public Page<Patio> listarTodosPatios(Pageable pageable) {
        return patioRepository.findAll(pageable); // Busca todos os pátios usando paginação
    }

    // Método para buscar um pátio por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "patioPorId", key = "#id") // Armazena em cache o pátio buscado pelo ID
    public Patio buscarPatioPorId(Long id) {
        return patioRepository.findById(id) // Busca o pátio pelo ID
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", id)); // Lança exceção se não encontrado
    }

    // Método para buscar pátios por filtro e com paginação
    @Transactional(readOnly = true)
    // @Cacheable(value = "patiosFiltrados", key = "{#filter, #pageable}") // Considere adicionar se aplicável
    public Page<Patio> buscarPatiosPorFiltro(PatioFilter filter, Pageable pageable) {
        return patioRepository.findAll(PatioSpecification.withFilters(filter), pageable); // Busca pátios com filtros e paginação
    }

    // Método para criar um novo pátio
    @Transactional // Transação de escrita
    @CacheEvict(value = {"patiosList", "patioPorId"}, allEntries = true) // Invalida caches relevantes
    public Patio criarPatio(PatioRequestDto dto) { //
        String nome = dto.getNomePatio(); //
        // Verifica se já existe um pátio com o mesmo nome (ignorando maiúsculas/minúsculas)
        if (patioRepository.findByNomePatioIgnoreCase(nome).isPresent()) { //
            throw new DuplicatedResourceException("Pátio", "nomePátio", nome); // Lança exceção se nome duplicado
        }
        Patio patio = patioMapper.toEntity(dto); // Mapeia DTO para entidade
        return patioRepository.save(patio); // Salva o novo pátio
    }

    // Método para atualizar um pátio existente
    @Transactional
    @CachePut(value = "patioPorId", key = "#id") // Atualiza o cache 'patioPorId' com o pátio modificado
    @CacheEvict(value = "patiosList", allEntries = true) // Invalida o cache de listagem
    public Patio atualizarPatio(Long id, PatioRequestDto dto) { //
        return patioRepository.findById(id) // Busca o pátio existente
                .map(existente -> { // Se encontrado, atualiza
                    String novoNome = dto.getNomePatio(); //
                    // Verifica se o novo nome (se fornecido e diferente do atual) já existe em outro pátio
                    if (novoNome != null && !novoNome.isBlank() && !novoNome.equalsIgnoreCase(existente.getNomePatio())) { //
                        if (patioRepository.findByNomePatioIgnoreCase(novoNome) //
                                .filter(p -> !p.getIdPatio().equals(id)) // Exclui o próprio pátio da checagem
                                .isPresent()) {
                            throw new DuplicatedResourceException("Pátio", "nomePátio", novoNome); // Lança exceção se duplicado
                        }
                    }
                    patioMapper.partialUpdate(dto, existente); // Atualiza a entidade com dados do DTO
                    return patioRepository.save(existente); // Salva as alterações
                })
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", id)); // Lança exceção se não encontrado para atualização
    }

    // Método para deletar um pátio
    @Transactional
    @CacheEvict(value = {"patioPorId", "patiosList", "veiculosDoPatio", "zonasDoPatio", "contatosDoPatio", "enderecosDoPatio", "boxesDoPatio"}, allEntries = true, key = "#id")
    public void deletarPatio(Long id) {
        if (!patioRepository.existsById(id)) { // Verifica se o pátio existe
            throw new ResourceNotFoundException("Pátio", id); // Lança exceção se não encontrado
        }
        // A exclusão em cascata das associações (VeiculoPatio, ZonaPatio, etc.) é geralmente tratada pelo JPA
        // se 'orphanRemoval = true' e 'cascade = CascadeType.ALL' estiverem nas coleções da entidade Patio.
        patioRepository.deleteById(id); // Deleta o pátio
    }

    // --- Métodos de Associação ---
    // A invalidação de cache aqui é importante para dados derivados, como listas de veículos/zonas/etc. por pátio.

    // --- VeiculoPatio ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "veiculosDoPatio"}, key = "#patioId", allEntries = true) // Invalida cache do pátio e da lista de veículos dele
    public VeiculoPatio associarPatioVeiculo(Long patioId, Long veiculoId) {
        Patio patio = buscarPatioPorId(patioId); // Reutiliza o método que já lança exceção e usa cache
        Veiculo veiculo = veiculoRepository.findById(veiculoId) //
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", veiculoId)); //
        VeiculoPatioId idAssociacao = new VeiculoPatioId(veiculoId, patioId); //
        if (veiculoPatioRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Veículo", "IDs", idAssociacao.toString()); //
        }
        VeiculoPatio associacao = new VeiculoPatio(veiculo, patio); //
        return veiculoPatioRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "veiculosDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioVeiculo(Long patioId, Long veiculoId) {
        VeiculoPatioId idAssociacao = new VeiculoPatioId(veiculoId, patioId); //
        if (!veiculoPatioRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Veículo", "IDs", idAssociacao.toString()); //
        }
        veiculoPatioRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "veiculosDoPatio", key = "#patioId") // Cacheia a lista de veículos de um pátio
    public Set<Veiculo> getVeiculosByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getVeiculoPatios().stream() //
                .map(VeiculoPatio::getVeiculo) //
                .collect(Collectors.toSet()); //
    }

    // --- ZonaPatio ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "zonasDoPatio"}, key = "#patioId", allEntries = true)
    public ZonaPatio associarPatioZona(Long patioId, Long zonaId) {
        Patio patio = buscarPatioPorId(patioId);
        Zona zona = zonaRepository.findById(zonaId) //
                .orElseThrow(() -> new ResourceNotFoundException("Zona", zonaId)); //
        ZonaPatioId idAssociacao = new ZonaPatioId(patioId, zonaId); //
        if (zonaPatioRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Zona", "IDs", idAssociacao.toString()); //
        }
        ZonaPatio associacao = new ZonaPatio(patio, zona); //
        return zonaPatioRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "zonasDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioZona(Long patioId, Long zonaId) {
        ZonaPatioId idAssociacao = new ZonaPatioId(patioId, zonaId); //
        if (!zonaPatioRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Zona", "IDs", idAssociacao.toString()); //
        }
        zonaPatioRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "zonasDoPatio", key = "#patioId")
    public Set<Zona> getZonasByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getZonaPatios().stream() //
                .map(ZonaPatio::getZona) //
                .collect(Collectors.toSet()); //
    }

    // --- ContatoPatio ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "contatosDoPatio"}, key = "#patioId", allEntries = true)
    public ContatoPatio associarPatioContato(Long patioId, Long contatoId) {
        Patio patio = buscarPatioPorId(patioId);
        Contato contato = contatoRepository.findById(contatoId) //
                .orElseThrow(() -> new ResourceNotFoundException("Contato", contatoId)); //
        ContatoPatioId idAssociacao = new ContatoPatioId(patioId, contatoId); //
        if (contatoPatioRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Contato", "IDs", idAssociacao.toString()); //
        }
        ContatoPatio associacao = new ContatoPatio(patio, contato); //
        return contatoPatioRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "contatosDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioContato(Long patioId, Long contatoId) {
        ContatoPatioId idAssociacao = new ContatoPatioId(patioId, contatoId); //
        if (!contatoPatioRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Contato", "IDs", idAssociacao.toString()); //
        }
        contatoPatioRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatosDoPatio", key = "#patioId")
    public Set<Contato> getContatosByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getContatoPatios().stream() //
                .map(ContatoPatio::getContato) //
                .collect(Collectors.toSet()); //
    }

    // --- EnderecoPatio ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "enderecosDoPatio"}, key = "#patioId", allEntries = true)
    public EnderecoPatio associarPatioEndereco(Long patioId, Long enderecoId) {
        Patio patio = buscarPatioPorId(patioId);
        Endereco endereco = enderecoRepository.findById(enderecoId) //
                .orElseThrow(() -> new ResourceNotFoundException("Endereço", enderecoId)); //
        EnderecoPatioId idAssociacao = new EnderecoPatioId(enderecoId, patioId); //
        if (enderecoPatioRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Endereço", "IDs", idAssociacao.toString()); //
        }
        EnderecoPatio associacao = new EnderecoPatio(endereco, patio); //
        return enderecoPatioRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "enderecosDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioEndereco(Long patioId, Long enderecoId) {
        EnderecoPatioId idAssociacao = new EnderecoPatioId(enderecoId, patioId); //
        if (!enderecoPatioRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Endereço", "IDs", idAssociacao.toString()); //
        }
        enderecoPatioRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "enderecosDoPatio", key = "#patioId")
    public Set<Endereco> getEnderecosByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getEnderecoPatios().stream() //
                .map(EnderecoPatio::getEndereco) //
                .collect(Collectors.toSet()); //
    }

    // --- PatioBox ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "boxesDoPatio"}, key = "#patioId", allEntries = true)
    public PatioBox associarPatioBox(Long patioId, Long boxId) {
        Patio patio = buscarPatioPorId(patioId);
        Box box = boxRepository.findById(boxId) //
                .orElseThrow(() -> new ResourceNotFoundException("Box", boxId)); //
        PatioBoxId idAssociacao = new PatioBoxId(patioId, boxId); //
        if (patioBoxRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Box", "IDs", idAssociacao.toString()); //
        }
        PatioBox associacao = new PatioBox(patio, box); //
        return patioBoxRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "boxesDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioBox(Long patioId, Long boxId) {
        PatioBoxId idAssociacao = new PatioBoxId(patioId, boxId); //
        if (!patioBoxRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Box", "IDs", idAssociacao.toString()); //
        }
        patioBoxRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "boxesDoPatio", key = "#patioId")
    public Set<Box> getBoxesByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getPatioBoxes().stream() //
                .map(PatioBox::getBox) //
                .collect(Collectors.toSet()); //
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\RastreamentoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: RastreamentoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.repository.RastreamentoRepository;
import br.com.fiap.mottu.exception.*;
import br.com.fiap.mottu.specification.RastreamentoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class RastreamentoService {

    private final RastreamentoRepository rastreamentoRepository;
    private final RastreamentoMapper rastreamentoMapper;

    @Autowired
    public RastreamentoService(RastreamentoRepository rastreamentoRepository,
                               RastreamentoMapper rastreamentoMapper) {
        this.rastreamentoRepository = rastreamentoRepository;
        this.rastreamentoMapper = rastreamentoMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable("rastreamentosList")
    public Page<Rastreamento> listarTodosRastreamentos(Pageable pageable) {
        return rastreamentoRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "rastreamentoPorId", key = "#id")
    public Rastreamento buscarRastreamentoPorId(Long id) {
        return rastreamentoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Rastreamento", id));
    }

    @Transactional(readOnly = true)
    public Page<Rastreamento> buscarRastreamentosPorFiltro(RastreamentoFilter filter, Pageable pageable) {
        return rastreamentoRepository.findAll(RastreamentoSpecification.withFilters(filter), pageable);
    }

    @Transactional
    @CacheEvict(value = {"rastreamentosList", "rastreamentoPorId"}, allEntries = true)
    public Rastreamento criarRastreamento(RastreamentoRequestDto dto) {
        if (dto.getIpsX() == null || dto.getIpsY() == null || dto.getIpsZ() == null ||
                dto.getGprsLatitude() == null || dto.getGprsLongitude() == null || dto.getGprsAltitude() == null) {
            throw new InvalidInputException("Todas as coordenadas (IPS_X, IPS_Y, IPS_Z, GPRS_LATITUDE, GPRS_LONGITUDE, GPRS_ALTITUDE) são obrigatórias.");
        }
        Rastreamento rastreamento = rastreamentoMapper.toEntity(dto);
        return rastreamentoRepository.save(rastreamento);
    }

    @Transactional
    @CachePut(value = "rastreamentoPorId", key = "#id")
    @CacheEvict(value = "rastreamentosList", allEntries = true)
    public Rastreamento atualizarRastreamento(Long id, RastreamentoRequestDto dto) {
        return rastreamentoRepository.findById(id)
                .map(existente -> {
                    if (dto.getIpsX() == null || dto.getIpsY() == null || dto.getIpsZ() == null ||
                            dto.getGprsLatitude() == null || dto.getGprsLongitude() == null || dto.getGprsAltitude() == null) {
                        throw new InvalidInputException("Na atualização, todas as coordenadas devem ser fornecidas se a intenção for alterá-las.");
                    }
                    rastreamentoMapper.partialUpdate(dto, existente);
                    return rastreamentoRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Rastreamento", id));
    }

    @Transactional
    @CacheEvict(value = {"rastreamentoPorId", "rastreamentosList"}, allEntries = true, key = "#id")
    public void deletarRastreamento(Long id) {
        if (!rastreamentoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Rastreamento", id);
        }
        rastreamentoRepository.deleteById(id);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\VeiculoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: VeiculoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto;
import br.com.fiap.mottu.filter.VeiculoFilter;
import br.com.fiap.mottu.mapper.VeiculoMapper;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.mapper.PatioMapper;
import br.com.fiap.mottu.mapper.ZonaMapper;
import br.com.fiap.mottu.mapper.BoxMapper;
import br.com.fiap.mottu.model.*;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.specification.VeiculoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Comparator;

@Service
public class VeiculoService {

    private final VeiculoRepository veiculoRepository;
    private final VeiculoMapper veiculoMapper;
    private final RastreamentoMapper rastreamentoMapper;
    private final PatioMapper patioMapper;
    private final ZonaMapper zonaMapper;
    private final BoxMapper boxMapper;

    @Autowired
    public VeiculoService(VeiculoRepository veiculoRepository,
                          VeiculoMapper veiculoMapper,
                          RastreamentoMapper rastreamentoMapper,
                          PatioMapper patioMapper,
                          ZonaMapper zonaMapper,
                          BoxMapper boxMapper) {
        this.veiculoRepository = veiculoRepository;
        this.veiculoMapper = veiculoMapper;
        this.rastreamentoMapper = rastreamentoMapper;
        this.patioMapper = patioMapper;
        this.zonaMapper = zonaMapper;
        this.boxMapper = boxMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable("veiculosList")
    public Page<Veiculo> listarTodosVeiculos(Pageable pageable) {
        return veiculoRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "veiculoPorId", key = "#id")
    public Veiculo buscarVeiculoPorId(Long id) {
        return veiculoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", id));
    }

    @Transactional(readOnly = true)
    public Page<Veiculo> buscarVeiculosPorFiltro(VeiculoFilter filter, Pageable pageable) {
        return veiculoRepository.findAll(VeiculoSpecification.withFilters(filter), pageable);
    }

    @Transactional
    @CacheEvict(value = {"veiculosList", "veiculoLocalizacao"}, allEntries = true)
    public Veiculo criarVeiculo(VeiculoRequestDto dto) {
        // Validações de campos únicos
        if (veiculoRepository.findByPlaca(dto.getPlaca()).isPresent()) {
            throw new DuplicatedResourceException("Veículo", "placa", dto.getPlaca());
        }
        if (veiculoRepository.findByRenavam(dto.getRenavam()).isPresent()) {
            throw new DuplicatedResourceException("Veículo", "RENAVAM", dto.getRenavam());
        }
        if (veiculoRepository.findByChassi(dto.getChassi()).isPresent()) {
            throw new DuplicatedResourceException("Veículo", "chassi", dto.getChassi());
        }
        if (dto.getTagBleId() != null && !dto.getTagBleId().isBlank()) {
            if (veiculoRepository.findByTagBleId(dto.getTagBleId()).isPresent()) {
                throw new DuplicatedResourceException("Veículo", "tagBleId", dto.getTagBleId());
            }
        }

        Veiculo veiculo = veiculoMapper.toEntity(dto);
        // A lógica da tag agora é tratada diretamente pelo mapper.
        return veiculoRepository.save(veiculo);
    }

    @Transactional
    @CachePut(value = "veiculoPorId", key = "#id")
    @CacheEvict(value = {"veiculosList", "veiculoLocalizacao"}, allEntries = true)
    public Veiculo atualizarVeiculo(Long id, VeiculoRequestDto dto) {
        Veiculo existente = veiculoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", id));

        // Validações de campos únicos
        if (dto.getPlaca() != null && !dto.getPlaca().isBlank() && !dto.getPlaca().equals(existente.getPlaca())) {
            veiculoRepository.findByPlaca(dto.getPlaca()).filter(v -> !v.getIdVeiculo().equals(id))
                    .ifPresent(v -> { throw new DuplicatedResourceException("Veículo", "placa", dto.getPlaca()); });
        }
        if (dto.getRenavam() != null && !dto.getRenavam().isBlank() && !dto.getRenavam().equals(existente.getRenavam())) {
            veiculoRepository.findByRenavam(dto.getRenavam()).filter(v -> !v.getIdVeiculo().equals(id))
                    .ifPresent(v -> { throw new DuplicatedResourceException("Veículo", "RENAVAM", dto.getRenavam()); });
        }
        if (dto.getChassi() != null && !dto.getChassi().isBlank() && !dto.getChassi().equals(existente.getChassi())) {
            veiculoRepository.findByChassi(dto.getChassi()).filter(v -> !v.getIdVeiculo().equals(id))
                    .ifPresent(v -> { throw new DuplicatedResourceException("Veículo", "chassi", dto.getChassi()); });
        }
        if (dto.getTagBleId() != null && !dto.getTagBleId().isBlank() && !dto.getTagBleId().equals(existente.getTagBleId())) {
            veiculoRepository.findByTagBleId(dto.getTagBleId()).filter(v -> !v.getIdVeiculo().equals(id))
                    .ifPresent(v -> { throw new DuplicatedResourceException("Veículo", "tagBleId", dto.getTagBleId()); });
        }

        // O mapper cuidará da atualização dos campos, incluindo tagBleId e status
        veiculoMapper.partialUpdate(dto, existente);
        return veiculoRepository.save(existente);
    }

    @Transactional
    @CacheEvict(value = {"veiculoPorId", "veiculosList", "veiculoLocalizacao"}, allEntries = true, key = "#id")
    public void deletarVeiculo(Long id) {
        if (!veiculoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Veículo", id);
        }
        veiculoRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "veiculoLocalizacao", key = "#veiculoId")
    public VeiculoLocalizacaoResponseDto getLocalizacaoVeiculo(Long veiculoId) {
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", veiculoId));

        Rastreamento ultimoRastreamento = veiculo.getVeiculoRastreamentos().stream()
                .map(VeiculoRastreamento::getRastreamento)
                .filter(r -> r != null && r.getDataHoraRegistro() != null)
                .max(Comparator.comparing(Rastreamento::getDataHoraRegistro))
                .orElse(null);

        Patio patioAssociado = veiculo.getVeiculoPatios().stream()
                .map(VeiculoPatio::getPatio)
                .findFirst()
                .orElse(null);

        Zona zonaAssociada = veiculo.getVeiculoZonas().stream()
                .map(VeiculoZona::getZona)
                .findFirst()
                .orElse(null);

        Box boxAssociado = veiculo.getVeiculoBoxes().stream()
                .map(VeiculoBox::getBox)
                .findFirst()
                .orElse(null);

        return new VeiculoLocalizacaoResponseDto(
                veiculo.getIdVeiculo(),
                veiculo.getPlaca(),
                veiculo.getModelo(),
                veiculo.getFabricante(),
                veiculo.getStatus(),
                veiculo.getTagBleId(),
                (ultimoRastreamento != null) ? rastreamentoMapper.toResponseDto(ultimoRastreamento) : null,
                (patioAssociado != null) ? patioMapper.toResponseDto(patioAssociado) : null,
                (zonaAssociada != null) ? zonaMapper.toResponseDto(zonaAssociada) : null,
                (boxAssociado != null) ? boxMapper.toResponseDto(boxAssociado) : null,
                LocalDateTime.now()
        );
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\ZonaService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: ZonaService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto; // DTO para entrada de dados de Zona
import br.com.fiap.mottu.filter.ZonaFilter; // Filtros para busca de Zonas
import br.com.fiap.mottu.mapper.ZonaMapper; // Mapper para converter entre Entidade e DTOs de Zona 
import br.com.fiap.mottu.model.Zona; // Entidade Zona 
import br.com.fiap.mottu.repository.ZonaRepository; // Repositório para Zona 
import br.com.fiap.mottu.exception.*; // Importa todas as exceções customizadas
import br.com.fiap.mottu.specification.ZonaSpecification; // Especificações para busca filtrada de Zona 
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict;    // Para invalidar cache
import org.springframework.cache.annotation.CachePut;      // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;     // Para habilitar cache em métodos
import org.springframework.data.domain.Page;          // Para resultados paginados
import org.springframework.data.domain.Pageable;        // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
// import java.util.List; // Não é mais o tipo de retorno público principal para listagens 

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class ZonaService {

    private final ZonaRepository zonaRepository; // Repositório para operações de Zona no banco
    private final ZonaMapper zonaMapper; // Mapper para Zona 

    @Autowired // Injeta as dependências automaticamente pelo Spring
    public ZonaService(ZonaRepository zonaRepository, ZonaMapper zonaMapper) {
        this.zonaRepository = zonaRepository; // 
        this.zonaMapper = zonaMapper; // 
    }

    // Método para listar todas as zonas de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("zonasList") // Armazena em cache o resultado desta listagem paginada
    public Page<Zona> listarTodasZonas(Pageable pageable) {
        return zonaRepository.findAll(pageable); // Busca todas as zonas usando paginação 
    }

    // Método para buscar uma zona por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "zonaPorId", key = "#id") // Armazena em cache a zona buscada pelo ID
    public Zona buscarZonaPorId(Long id) {
        return zonaRepository.findById(id) // Busca a zona pelo ID 
                .orElseThrow(() -> new ResourceNotFoundException("Zona", id)); // Lança exceção se não encontrada 
    }

    // Método para buscar zonas por filtro e com paginação
    @Transactional(readOnly = true)
    // @Cacheable(value = "zonasFiltradas", key = "{#filter, #pageable}") // Considere adicionar se aplicável
    public Page<Zona> buscarZonasPorFiltro(ZonaFilter filter, Pageable pageable) {
        return zonaRepository.findAll(ZonaSpecification.withFilters(filter), pageable); // Busca zonas com filtros e paginação 
    }

    // Método para criar uma nova zona
    @Transactional // Transação de escrita
    @CacheEvict(value = {"zonasList", "zonaPorId"}, allEntries = true) // Invalida caches relevantes
    public Zona criarZona(ZonaRequestDto dto) { // 
        String nome = dto.getNome(); // 
        // Verifica se já existe uma zona com o mesmo nome (ignorando maiúsculas/minúsculas)
        if (zonaRepository.findByNomeIgnoreCase(nome).isPresent()) { // 
            throw new DuplicatedResourceException("Zona", "nome", nome); // Lança exceção se nome duplicado 
        }
        Zona zona = zonaMapper.toEntity(dto); // Mapeia DTO para entidade 
        return zonaRepository.save(zona); // Salva a nova zona 
    }

    // Método para atualizar uma zona existente
    @Transactional
    @CachePut(value = "zonaPorId", key = "#id") // Atualiza o cache 'zonaPorId' com a zona modificada
    @CacheEvict(value = "zonasList", allEntries = true) // Invalida o cache de listagem
    public Zona atualizarZona(Long id, ZonaRequestDto dto) { // 
        return zonaRepository.findById(id) // Busca a zona existente 
                .map(existente -> { // Se encontrada, atualiza
                    String novoNome = dto.getNome(); // 
                    // Verifica se o novo nome (se fornecido e diferente do atual) já existe em outra zona
                    if (novoNome != null && !novoNome.isBlank() && !novoNome.equalsIgnoreCase(existente.getNome())) { // 
                        if (zonaRepository.findByNomeIgnoreCase(novoNome) // 
                                .filter(z -> !z.getIdZona().equals(id)) // Exclui a própria zona da checagem
                                .isPresent()) {
                            throw new DuplicatedResourceException("Zona", "nome", novoNome); // Lança exceção se duplicado 
                        }
                    }
                    zonaMapper.partialUpdate(dto, existente); // Atualiza a entidade com dados do DTO 
                    return zonaRepository.save(existente); // Salva as alterações
                })
                .orElseThrow(() -> new ResourceNotFoundException("Zona", id)); // Lança exceção se não encontrada para atualização 
    }

    // Método para deletar uma zona
    @Transactional
    @CacheEvict(value = {"zonaPorId", "zonasList"}, allEntries = true, key = "#id") // Remove a zona dos caches relevantes
    public void deletarZona(Long id) {
        if (!zonaRepository.existsById(id)) { // Verifica se a zona existe 
            throw new ResourceNotFoundException("Zona", id); // Lança exceção se não encontrada 
        }
        // A exclusão em cascata das associações (VeiculoZona, ZonaBox, ZonaPatio) é geralmente tratada pelo JPA
        // se 'orphanRemoval = true' e 'cascade = CascadeType.ALL' estiverem nas coleções da entidade Zona.
        zonaRepository.deleteById(id); // Deleta a zona 
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\BoxService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: BoxService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.box.BoxRequestDto; // DTO para entrada de dados de Box
import br.com.fiap.mottu.filter.BoxFilter; // Filtros para busca de Boxes
import br.com.fiap.mottu.mapper.BoxMapper; // Mapper para converter entre Entidade e DTOs de Box
import br.com.fiap.mottu.model.Box; // Entidade Box
import br.com.fiap.mottu.repository.BoxRepository; // Repositório para Box
import br.com.fiap.mottu.exception.DuplicatedResourceException; // Exceção para recursos duplicados
import br.com.fiap.mottu.exception.ResourceNotFoundException; // Exceção para recursos não encontrados
import br.com.fiap.mottu.specification.BoxSpecification; // Especificações para busca filtrada de Box
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict; // Para remover entradas do cache
import org.springframework.cache.annotation.CachePut; // Para atualizar entradas no cache
import org.springframework.cache.annotation.Cacheable; // Para armazenar resultados de métodos em cache
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para informações de paginação e ordenação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
import java.util.List; // Usado internamente, mas os métodos públicos retornarão Page

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class BoxService {

    private final BoxRepository boxRepository; // Repositório para operações de Box no banco
    private final BoxMapper boxMapper; // Mapper para converter entre DTOs e Entidade Box 

    @Autowired // Injeta as dependências automaticamente pelo Spring
    public BoxService(BoxRepository boxRepository, BoxMapper boxMapper) {
        this.boxRepository = boxRepository; // 
        this.boxMapper = boxMapper; // 
    }

    // Método para listar todos os boxes de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("boxesList") // Armazena em cache o resultado desta listagem paginada
    public Page<Box> listarTodosBoxes(Pageable pageable) {
        return boxRepository.findAll(pageable); // Busca todos os boxes usando paginação
    }

    // Método para buscar um box por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "boxPorId", key = "#id") // Armazena em cache o box buscado pelo ID
    public Box buscarBoxPorId(Long id) {
        return boxRepository.findById(id) // Busca o box pelo ID 
                .orElseThrow(() -> new ResourceNotFoundException("Box", id)); // Lança exceção se não encontrado 
    }

    // Método para buscar boxes por filtro e com paginação
    @Transactional(readOnly = true)
    public Page<Box> buscarBoxesPorFiltro(BoxFilter filter, Pageable pageable) {
        return boxRepository.findAll(BoxSpecification.withFilters(filter), pageable); // Busca boxes com filtros e paginação 
    }

    // Método para criar um novo box
    @Transactional // Transação de escrita
    @CacheEvict(value = {"boxesList", "boxPorId"}, allEntries = true) // Remove todas as entradas dos caches 'boxesList' e 'boxPorId' após criar um novo box
    public Box criarBox(BoxRequestDto boxRequestDto) {
        String nome = boxRequestDto.getNome(); // 
        // Verifica se já existe um box com o mesmo nome (ignorando maiúsculas/minúsculas)
        if (boxRepository.findByNomeIgnoreCase(nome).isPresent()) { // 
            throw new DuplicatedResourceException("Box", "nome", nome); // Lança exceção se nome duplicado 
        }
        Box box = boxMapper.toEntity(boxRequestDto); // Mapeia DTO para entidade 
        return boxRepository.save(box); // Salva o novo box 
    }

    // Método para atualizar um box existente
    @Transactional
    @CachePut(value = "boxPorId", key = "#id") // Atualiza o cache 'boxPorId' com o box modificado
    @CacheEvict(value = "boxesList", allEntries = true) // Invalida o cache de listagem
    public Box atualizarBox(Long id, BoxRequestDto boxRequestDto) {
        return boxRepository.findById(id) // Busca o box existente 
                .map(boxExistente -> { // Se encontrado, atualiza
                    String novoNome = boxRequestDto.getNome(); // 
                    // Verifica se o novo nome (se fornecido e diferente do atual) já existe em outro box
                    if (novoNome != null && !novoNome.isBlank() && !novoNome.equalsIgnoreCase(boxExistente.getNome())) {
                        if (boxRepository.findByNomeIgnoreCase(novoNome) // 
                                .filter(b -> !b.getIdBox().equals(id)) // Exclui o próprio box da checagem
                                .isPresent()) {
                            throw new DuplicatedResourceException("Box", "nome", novoNome); // Lança exceção se duplicado 
                        }
                    }
                    boxMapper.partialUpdate(boxRequestDto, boxExistente); // Atualiza a entidade com dados do DTO 
                    return boxRepository.save(boxExistente); // Salva as alterações
                })
                .orElseThrow(() -> new ResourceNotFoundException("Box", id)); // Lança exceção se não encontrado para atualização 
    }

    // Método para deletar um box
    @Transactional
    @CacheEvict(value = {"boxPorId", "boxesList"}, allEntries = true, key = "#id") // Remove o box dos caches relevantes
    public void deletarBox(Long id) {
        if (!boxRepository.existsById(id)) { // Verifica se o box existe 
            throw new ResourceNotFoundException("Box", id); // Lança exceção se não encontrado 
        }
        boxRepository.deleteById(id); // Deleta o box 
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ClienteService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// java\br\com\fiap\mottu\service\ClienteService.java   |   package br.com.fiap.mottu.service   |   class ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto; // DTO para entrada de dados de Cliente
// import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto; // Não usado diretamente aqui, mas sim dentro do ClienteRequestDto
// import br.com.fiap.mottu.dto.contato.ContatoRequestDto; // Não usado diretamente aqui, mas sim dentro do ClienteRequestDto
import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.filter.ClienteFilter; // Filtros para busca de Clientes
import br.com.fiap.mottu.model.Cliente; // Entidade Cliente
import br.com.fiap.mottu.model.Contato; // Entidade Contato
import br.com.fiap.mottu.model.Endereco; // Entidade Endereco
import br.com.fiap.mottu.model.Veiculo; // Entidade Veiculo
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo; // Entidade de junção Cliente-Veiculo
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId; // ID composto para ClienteVeiculo
import br.com.fiap.mottu.repository.ClienteRepository; // Repositório para Cliente
import br.com.fiap.mottu.repository.relacionamento.ClienteVeiculoRepository; // Repositório para ClienteVeiculo
import br.com.fiap.mottu.repository.ContatoRepository; // Repositório para Contato
import br.com.fiap.mottu.repository.EnderecoRepository; // Repositório para Endereco
import br.com.fiap.mottu.repository.VeiculoRepository; // Repositório para Veiculo
import br.com.fiap.mottu.specification.ClienteSpecification; // Especificações para busca filtrada de Cliente
import br.com.fiap.mottu.exception.ResourceNotFoundException; // Exceção para recursos não encontrados
import br.com.fiap.mottu.exception.DuplicatedResourceException; // Exceção para recursos duplicados
import br.com.fiap.mottu.exception.InvalidInputException; // Exceção para entrada inválida
import br.com.fiap.mottu.mapper.ClienteMapper; // Mapper para Cliente
import br.com.fiap.mottu.mapper.ContatoMapper; // Mapper para Contato
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict; // Para invalidar cache
import org.springframework.cache.annotation.CachePut;   // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;  // Para habilitar cache em métodos
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
import reactor.core.publisher.Mono; // Para programação reativa (usado em criar/atualizar devido ao ViaCEP)

import java.util.Set; // Para coleções como Set de Veículos
import java.util.stream.Collectors; // Para operações com streams

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class ClienteService {

    private final ClienteRepository clienteRepository; // Repositório para Cliente
    private final EnderecoRepository enderecoRepository; // Repositório para Endereco
    private final ContatoRepository contatoRepository; // Repositório para Contato
    private final VeiculoRepository veiculoRepository; // Repositório para Veiculo
    private final ClienteVeiculoRepository clienteVeiculoRepository; // Repositório para a relação Cliente-Veiculo
    private final EnderecoService enderecoService; // Serviço de Endereco (para criar/atualizar endereço com ViaCEP)
    private final ClienteMapper clienteMapper; // Mapper para Cliente
    private final ContatoMapper contatoMapper; // Mapper para Contato

    @Autowired // Construtor para injeção de dependências
    public ClienteService(
            ClienteRepository clienteRepository,
            EnderecoRepository enderecoRepository,
            ContatoRepository contatoRepository,
            VeiculoRepository veiculoRepository,
            ClienteVeiculoRepository clienteVeiculoRepository,
            EnderecoService enderecoService, //
            ClienteMapper clienteMapper,
            ContatoMapper contatoMapper //
    ) {
        this.clienteRepository = clienteRepository;
        this.enderecoRepository = enderecoRepository; //
        this.contatoRepository = contatoRepository; //
        this.veiculoRepository = veiculoRepository; //
        this.clienteVeiculoRepository = clienteVeiculoRepository; //
        this.enderecoService = enderecoService; //
        this.clienteMapper = clienteMapper; //
        this.contatoMapper = contatoMapper; //
    }

    // Método para listar todos os clientes de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("clientesList") // Armazena em cache o resultado desta listagem paginada
    public Page<Cliente> listarTodosClientes(Pageable pageable) {
        return clienteRepository.findAll(pageable); // Busca todos os clientes usando paginação
    }

    // Método para buscar um cliente por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "clientePorId", key = "#id") // Armazena em cache o cliente buscado pelo ID
    public Cliente buscarClientePorId(Long id) {
        return clienteRepository.findById(id) // Busca o cliente pelo ID
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", id)); // Lança exceção se não encontrado
    }

    // Método para buscar clientes por filtro e com paginação
    @Transactional(readOnly = true)
    // Considerar adicionar caching aqui também se os filtros forem usados frequentemente com os mesmos parâmetros
    // Ex: @Cacheable(value = "clientesFiltrados", key = "{#filter, #pageable}")
    public Page<Cliente> buscarClientesPorFiltro(ClienteFilter filter, Pageable pageable) {
        return clienteRepository.findAll(ClienteSpecification.withFilters(filter), pageable); // Busca clientes com filtros e paginação
    }

    // Método para criar um novo cliente (reativo devido à chamada ao ViaCEP)
    @Transactional
    @CacheEvict(value = {"clientesList", "clientePorId", "veiculosDoCliente"}, allEntries = true) // Invalida caches relevantes
    public Mono<Cliente> criarCliente(ClienteRequestDto dto) { //
        // Verifica se já existe um cliente com o mesmo CPF
        if (clienteRepository.findByCpf(dto.getCpf()).isPresent()) { //
            return Mono.error(new DuplicatedResourceException("Cliente", "CPF", dto.getCpf())); //
        }

        // Lógica para obter ou criar Endereço (reativa)
        Mono<Endereco> enderecoMono = (dto.getEnderecoRequestDto().getIdEndereco() != null) //
                ? Mono.justOrEmpty(enderecoRepository.findById(dto.getEnderecoRequestDto().getIdEndereco())) //
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Endereço", dto.getEnderecoRequestDto().getIdEndereco()))) //
                : enderecoService.criarEndereco(dto.getEnderecoRequestDto()); // Chama o serviço de endereço (reativo)

        // Lógica para obter ou criar Contato (síncrona, mas envolvida no fluxo reativo)
        Mono<Contato> contatoMono = Mono.defer(() -> { // Envolve a lógica síncrona em Mono.defer para integrá-la corretamente ao fluxo reativo
            ContatoRequestDto contatoDto = dto.getContatoRequestDto(); //
            if (contatoDto.getIdContato() != null) { //
                return Mono.justOrEmpty(contatoRepository.findById(contatoDto.getIdContato())) //
                        .switchIfEmpty(Mono.error(new ResourceNotFoundException("Contato", contatoDto.getIdContato()))); //
            } else {
                // Checagem de duplicação de e-mail para novos contatos
                if (contatoDto.getEmail() != null && contatoRepository.findByEmail(contatoDto.getEmail()).isPresent()) { //
                    return Mono.error(new DuplicatedResourceException("Contato", "email", contatoDto.getEmail()));
                }
                return Mono.just(contatoRepository.save(contatoMapper.toEntity(contatoDto))); //
            }
        });

        // Combina os resultados reativos de endereço e contato para criar o cliente
        return Mono.zip(enderecoMono, contatoMono) //
                .flatMap(tuple -> {
                    Cliente cliente = clienteMapper.toEntity(dto); // Mapeia DTO para entidade
                    cliente.setEndereco(tuple.getT1()); // Associa o endereço
                    cliente.setContato(tuple.getT2()); // Associa o contato
                    return Mono.just(clienteRepository.save(cliente)); // Salva o cliente
                })
                .onErrorResume(e -> { // Tratamento de erro para o fluxo reativo
                    if (e instanceof ResourceNotFoundException || e instanceof DuplicatedResourceException || e instanceof InvalidInputException) { //
                        return Mono.error(e); // Repassa exceções conhecidas
                    }
                    // Para outras exceções, encapsula em InvalidInputException
                    return Mono.error(new InvalidInputException("Erro inesperado ao criar cliente: " + e.getMessage())); //
                });
    }

    // Método para atualizar um cliente existente (reativo)
    @Transactional
    @CacheEvict(value = {"clientesList", "veiculosDoCliente"}, allEntries = true) // Invalida caches de listagem
    @CachePut(value = "clientePorId", key = "#id") // Atualiza o cache específico do cliente
    public Mono<Cliente> atualizarCliente(Long id, ClienteRequestDto dto) { //
        return Mono.justOrEmpty(clienteRepository.findById(id)) // Busca o cliente existente
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Cliente", id))) // Se não encontrar, lança erro
                .flatMap(clienteExistente -> {
                    // Verifica duplicação de CPF se estiver sendo alterado
                    if (dto.getCpf() != null && !dto.getCpf().equals(clienteExistente.getCpf()) && clienteRepository.findByCpf(dto.getCpf()).isPresent()) { //
                        return Mono.error(new DuplicatedResourceException("Cliente", "CPF", dto.getCpf())); //
                    }

                    clienteMapper.partialUpdate(dto, clienteExistente); // Atualiza campos básicos do cliente

                    // Lógica para atualizar ou criar Endereço (reativa)
                    Mono<Endereco> enderecoMono;
                    if (dto.getEnderecoRequestDto() != null) { //
                        if (dto.getEnderecoRequestDto().getIdEndereco() != null) { //
                            // Atualiza endereço existente
                            enderecoMono = enderecoService.atualizarEndereco(dto.getEnderecoRequestDto().getIdEndereco(), dto.getEnderecoRequestDto()); //
                        } else {
                            // Cria novo endereço
                            enderecoMono = enderecoService.criarEndereco(dto.getEnderecoRequestDto()); //
                        }
                        enderecoMono = enderecoMono.doOnNext(clienteExistente::setEndereco); // Associa o endereço atualizado/criado ao cliente
                    } else {
                        enderecoMono = Mono.just(clienteExistente.getEndereco()); // Mantém o endereço existente se não houver DTO de endereço
                    }

                    // Lógica para atualizar ou criar Contato (reativa)
                    Mono<Contato> contatoMono;
                    if (dto.getContatoRequestDto() != null) { //
                        ContatoRequestDto contatoDto = dto.getContatoRequestDto();
                        if (contatoDto.getIdContato() != null) { //
                            // Atualiza contato existente
                            contatoMono = Mono.justOrEmpty(contatoRepository.findById(contatoDto.getIdContato())) //
                                    .switchIfEmpty(Mono.error(new ResourceNotFoundException("Contato", contatoDto.getIdContato()))) //
                                    .flatMap(contatoExistente -> {
                                        // Checagem de duplicação de e-mail se estiver sendo alterado para um e-mail que já existe em outro contato
                                        if (contatoDto.getEmail() != null && !contatoDto.getEmail().equals(contatoExistente.getEmail()) &&
                                                contatoRepository.findByEmail(contatoDto.getEmail()).filter(c -> !c.getIdContato().equals(contatoExistente.getIdContato())).isPresent()) { //
                                            return Mono.error(new DuplicatedResourceException("Contato", "email", contatoDto.getEmail()));
                                        }
                                        contatoMapper.partialUpdate(contatoDto, contatoExistente); //
                                        return Mono.just(contatoRepository.save(contatoExistente)); //
                                    });
                        } else {
                            // Cria novo contato
                            // Checagem de duplicação de e-mail para novos contatos
                            if (contatoDto.getEmail() != null && contatoRepository.findByEmail(contatoDto.getEmail()).isPresent()) { //
                                return Mono.error(new DuplicatedResourceException("Contato", "email", contatoDto.getEmail()));
                            }
                            contatoMono = Mono.just(contatoRepository.save(contatoMapper.toEntity(contatoDto))); //
                        }
                        contatoMono = contatoMono.doOnNext(clienteExistente::setContato); // Associa o contato atualizado/criado ao cliente
                    } else {
                        contatoMono = Mono.just(clienteExistente.getContato()); // Mantém o contato existente
                    }

                    // Espera a conclusão das operações de endereço e contato, depois salva o cliente
                    return Mono.when(enderecoMono, contatoMono).then(Mono.fromCallable(() -> clienteRepository.save(clienteExistente)));
                })
                .onErrorResume(e -> { // Tratamento de erro para o fluxo reativo
                    if (e instanceof ResourceNotFoundException || e instanceof DuplicatedResourceException || e instanceof InvalidInputException) { //
                        return Mono.error(e);
                    }
                    return Mono.error(new InvalidInputException("Erro inesperado ao atualizar cliente: " + e.getMessage())); //
                });
    }

    // Método para deletar um cliente
    @Transactional
    @CacheEvict(value = {"clientesList", "clientePorId", "veiculosDoCliente"}, allEntries = true, key = "#id") // Remove o cliente de todos os caches relevantes
    public void deletarCliente(Long id) {
        if (!clienteRepository.existsById(id)) { // Verifica se o cliente existe
            throw new ResourceNotFoundException("Cliente", id); // Lança exceção se não encontrado
        }
        // Considerar a lógica de desassociação ou o que acontece com Endereco e Contato se forem exclusivos deste cliente
        // Atualmente, Endereco e Contato não são excluídos automaticamente aqui, apenas o Cliente e suas associações diretas (ClienteVeiculo).
        clienteRepository.deleteById(id); // Deleta o cliente
    }

    // Método para associar um veículo a um cliente
    @Transactional
    @CacheEvict(value = {"clientePorId", "veiculosDoCliente"}, key = "#clienteId", allEntries = true) // Invalida caches do cliente específico
    public ClienteVeiculo associarClienteVeiculo(Long clienteId, Long enderecoId, Long contatoId, Long veiculoId) {
        // Busca o cliente ou lança exceção
        Cliente cliente = clienteRepository.findById(clienteId) //
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", clienteId)); //
        // Busca o veículo ou lança exceção
        Veiculo veiculo = veiculoRepository.findById(veiculoId) //
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", veiculoId)); //

        // Valida se os IDs de endereço e contato no ClienteVeiculoId correspondem aos do Cliente buscado
        if (!cliente.getEndereco().getIdEndereco().equals(enderecoId)) {
            throw new InvalidInputException("ID do endereço fornecido (" + enderecoId + ") não corresponde ao endereço associado ao cliente (" + cliente.getEndereco().getIdEndereco() + ").");
        }
        if (!cliente.getContato().getIdContato().equals(contatoId)) {
            throw new InvalidInputException("ID do contato fornecido (" + contatoId + ") não corresponde ao contato associado ao cliente (" + cliente.getContato().getIdContato() + ").");
        }

        ClienteVeiculoId id = new ClienteVeiculoId(clienteId, enderecoId, contatoId, veiculoId); // Cria o ID composto
        if (clienteVeiculoRepository.existsById(id)) { // Verifica se a associação já existe
            throw new DuplicatedResourceException("Associação Cliente-Veículo", "IDs", id.toString()); //
        }
        ClienteVeiculo associacao = new ClienteVeiculo(cliente, veiculo); // Cria a entidade de relacionamento
        return clienteVeiculoRepository.save(associacao); // Salva a associação
    }

    // Método para desassociar um veículo de um cliente
    @Transactional
    @CacheEvict(value = {"clientePorId", "veiculosDoCliente"}, key = "#clienteId", allEntries = true) // Invalida caches do cliente
    public void desassociarClienteVeiculo(Long clienteId, Long enderecoId, Long contatoId, Long veiculoId) { //
        ClienteVeiculoId id = new ClienteVeiculoId(clienteId, enderecoId, contatoId, veiculoId); // Cria o ID composto
        if (!clienteVeiculoRepository.existsById(id)) { // Verifica se a associação existe para ser removida
            throw new ResourceNotFoundException("Associação Cliente-Veículo", "IDs", id.toString()); //
        }
        clienteVeiculoRepository.deleteById(id); // Remove a associação
    }

    // Método para listar os veículos de um cliente
    @Transactional(readOnly = true)
    @Cacheable(value = "veiculosDoCliente", key = "#clienteId") // Armazena em cache a lista de veículos do cliente
    public Set<Veiculo> getVeiculosByClienteId(Long clienteId) {
        Cliente cliente = clienteRepository.findById(clienteId) // Busca o cliente
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", clienteId)); // Lança exceção se não encontrado
        // Mapeia as associações ClienteVeiculo para obter apenas as entidades Veiculo
        return cliente.getClienteVeiculos().stream() //
                .map(ClienteVeiculo::getVeiculo) //
                .collect(Collectors.toSet()); //
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ContatoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: ContatoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto; // DTO para entrada de dados de Contato
import br.com.fiap.mottu.filter.ContatoFilter; // Filtros para busca de Contatos
import br.com.fiap.mottu.mapper.ContatoMapper; // Mapper para converter entre Entidade e DTOs de Contato 
import br.com.fiap.mottu.model.Contato; // Entidade Contato 
import br.com.fiap.mottu.repository.ContatoRepository; // Repositório para Contato 
import br.com.fiap.mottu.exception.*; // Importa todas as exceções customizadas (DuplicatedResourceException, ResourceNotFoundException, etc.)
import br.com.fiap.mottu.specification.ContatoSpecification; // Especificações para busca filtrada de Contato 
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict; // Para invalidar cache
import org.springframework.cache.annotation.CachePut;   // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;  // Para habilitar cache em métodos
import org.springframework.data.domain.Page; // Para resultados paginados
import org.springframework.data.domain.Pageable; // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
// import java.util.List; // Não será mais o tipo de retorno público principal para listagens

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class ContatoService {

    private final ContatoRepository contatoRepository; // Repositório para operações de Contato no banco
    private final ContatoMapper contatoMapper; // Mapper para Contato 

    @Autowired // Injeta as dependências automaticamente pelo Spring
    public ContatoService(ContatoRepository contatoRepository, ContatoMapper contatoMapper) {
        this.contatoRepository = contatoRepository; // 
        this.contatoMapper = contatoMapper; // 
    }

    // Método para listar todos os contatos de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("contatosList") // Armazena em cache o resultado desta listagem paginada
    public Page<Contato> listarTodosContatos(Pageable pageable) {
        return contatoRepository.findAll(pageable); // Busca todos os contatos usando paginação
    }

    // Método para buscar um contato por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "contatoPorId", key = "#id") // Armazena em cache o contato buscado pelo ID
    public Contato buscarContatoPorId(Long id) {
        return contatoRepository.findById(id) // Busca o contato pelo ID 
                .orElseThrow(() -> new ResourceNotFoundException("Contato", id)); // Lança exceção se não encontrado 
    }

    // Método para buscar contatos por filtro e com paginação
    @Transactional(readOnly = true)
    // @Cacheable(value = "contatosFiltrados", key = "{#filter, #pageable}") // Considere adicionar se aplicável
    public Page<Contato> buscarContatosPorFiltro(ContatoFilter filter, Pageable pageable) {
        return contatoRepository.findAll(ContatoSpecification.withFilters(filter), pageable); // Busca contatos com filtros e paginação 
    }

    // Método para criar um novo contato
    @Transactional // Transação de escrita
    @CacheEvict(value = {"contatosList", "contatoPorId"}, allEntries = true) // Invalida caches relevantes
    public Contato criarContato(ContatoRequestDto dto) { // 
        String email = dto.getEmail(); // 
        // Verifica se já existe um contato com o mesmo e-mail
        if (contatoRepository.findByEmail(email).isPresent()) { // 
            throw new DuplicatedResourceException("Contato", "email", email); // Lança exceção se e-mail duplicado 
        }
        Contato contato = contatoMapper.toEntity(dto); // Mapeia DTO para entidade 
        return contatoRepository.save(contato); // Salva o novo contato 
    }

    // Método para atualizar um contato existente
    @Transactional
    @CachePut(value = "contatoPorId", key = "#id") // Atualiza o cache 'contatoPorId' com o contato modificado
    @CacheEvict(value = "contatosList", allEntries = true) // Invalida o cache de listagem
    public Contato atualizarContato(Long id, ContatoRequestDto dto) { // 
        return contatoRepository.findById(id) // Busca o contato existente 
                .map(existente -> { // Se encontrado, atualiza
                    String novoEmail = dto.getEmail(); // 
                    // Verifica se o novo e-mail (se fornecido e diferente do atual) já existe em outro contato
                    if (novoEmail != null && !novoEmail.isBlank() && !novoEmail.equalsIgnoreCase(existente.getEmail())) {
                        if (contatoRepository.findByEmail(novoEmail) // 
                                .filter(c -> !c.getIdContato().equals(id)) // Exclui o próprio contato da checagem
                                .isPresent()) {
                            throw new DuplicatedResourceException("Contato", "email", novoEmail); // Lança exceção se duplicado 
                        }
                    }
                    contatoMapper.partialUpdate(dto, existente); // Atualiza a entidade com dados do DTO 
                    return contatoRepository.save(existente); // Salva as alterações
                })
                .orElseThrow(() -> new ResourceNotFoundException("Contato", id)); // Lança exceção se não encontrado para atualização 
    }

    // Método para deletar um contato
    @Transactional
    @CacheEvict(value = {"contatoPorId", "contatosList"}, allEntries = true, key = "#id") // Remove o contato dos caches relevantes
    public void deletarContato(Long id) {
        if (!contatoRepository.existsById(id)) { // Verifica se o contato existe 
            throw new ResourceNotFoundException("Contato", id); // Lança exceção se não encontrado 
        }
        contatoRepository.deleteById(id); // Deleta o contato 
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\DashboardService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: DashboardService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.dashboard.OcupacaoDiaDto;
import br.com.fiap.mottu.dto.dashboard.ResumoOcupacaoDto;
import br.com.fiap.mottu.repository.DashboardStatsRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;

@Service
@Transactional(readOnly = true)
public class DashboardService {

    private final DashboardStatsRepository repo;

    public DashboardService(DashboardStatsRepository repo) {
        this.repo = repo;
    }

    public ResumoOcupacaoDto getResumoAtual() {
        long total  = repo.countBoxes();
        long ocup   = repo.countBoxesOcupados();
        long livres = repo.countBoxesLivres(); // ou total - ocup
        return new ResumoOcupacaoDto(total, ocup, livres);
    }

    public List<OcupacaoDiaDto> getOcupacaoPorDia(LocalDate ini, LocalDate fim) {
        return repo.ocupacaoPorDia(ini, fim);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\EnderecoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: EnderecoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto; // DTO para entrada de dados de Endereço
import br.com.fiap.mottu.external.viacep.ViaCepService; // Serviço para consulta ao ViaCEP
import br.com.fiap.mottu.model.Endereco; // Entidade Endereço
import br.com.fiap.mottu.mapper.EnderecoMapper; // Mapper para Endereço
import br.com.fiap.mottu.repository.EnderecoRepository; // Repositório para Endereço
import br.com.fiap.mottu.exception.ResourceNotFoundException; // Exceção para recursos não encontrados
import br.com.fiap.mottu.exception.InvalidInputException; // Exceção para entrada inválida
import br.com.fiap.mottu.filter.EnderecoFilter; // Filtros para busca de Endereços
import br.com.fiap.mottu.specification.EnderecoSpecification; // Especificações para busca filtrada de Endereços
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict;    // Para invalidar cache
import org.springframework.cache.annotation.CachePut;      // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;     // Para habilitar cache em métodos
import org.springframework.data.domain.Page;          // Para resultados paginados
import org.springframework.data.domain.Pageable;        // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
import reactor.core.publisher.Mono; // Para programação reativa (ViaCEP)
// import java.util.List; // Não é mais o tipo de retorno público principal para listagens

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class EnderecoService {

    private final EnderecoRepository enderecoRepository; // Repositório para Endereço
    private final EnderecoMapper enderecoMapper; // Mapper para Endereço
    private final ViaCepService viaCepService; // Serviço para consulta ao ViaCEP

    @Autowired // Construtor para injeção de dependências
    public EnderecoService(EnderecoRepository enderecoRepository,
                           EnderecoMapper enderecoMapper,
                           ViaCepService viaCepService) { //
        this.enderecoRepository = enderecoRepository;
        this.enderecoMapper = enderecoMapper; //
        this.viaCepService = viaCepService; //
    }

    // Método para listar todos os endereços de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("enderecosList") // Armazena em cache o resultado desta listagem paginada
    public Page<Endereco> listarTodosEnderecos(Pageable pageable) {
        return enderecoRepository.findAll(pageable); // Busca todos os endereços usando paginação
    }

    // Método para buscar um endereço por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "enderecoPorId", key = "#id") // Armazena em cache o endereço buscado pelo ID
    public Endereco buscarEnderecoPorId(Long id) {
        return enderecoRepository.findById(id) // Busca o endereço pelo ID
                .orElseThrow(() -> new ResourceNotFoundException("Endereço", id)); // Lança exceção se não encontrado
    }

    // NOVO: Método para buscar endereços por filtro e com paginação
    @Transactional(readOnly = true)
    // @Cacheable(value = "enderecosFiltrados", key = "{#filter, #pageable}") // Considere adicionar se aplicável
    public Page<Endereco> buscarEnderecosPorFiltro(EnderecoFilter filter, Pageable pageable) {
        return enderecoRepository.findAll(EnderecoSpecification.withFilters(filter), pageable); // Busca endereços com filtros e paginação
    }

    // Método para criar um novo endereço (reativo devido à chamada ao ViaCEP)
    @Transactional
    // Invalidar caches de listagem ao criar um novo endereço. O cache individual não faz sentido para criar.
    @CacheEvict(value = {"enderecosList", "enderecoPorId", "enderecosFiltrados"}, allEntries = true)
    public Mono<Endereco> criarEndereco(EnderecoRequestDto dto) { //
        // Validação básica do CEP
        if (dto.getCep() == null || dto.getCep().isBlank()) { //
            return Mono.error(new InvalidInputException("CEP não pode ser nulo ou vazio.")); //
        }

        // Consulta o ViaCEP de forma reativa
        return viaCepService.buscarEnderecoPorCep(dto.getCep()) //
                .flatMap(viaCepResponse -> { // Se o CEP for encontrado no ViaCEP
                    Endereco endereco = enderecoMapper.toEntity(dto); // Mapeia o DTO para a entidade Endereco
                    // Preenche os campos do endereço com os dados retornados pelo ViaCEP
                    endereco.setLogradouro(viaCepResponse.getLogradouro()); //
                    endereco.setBairro(viaCepResponse.getBairro()); //
                    endereco.setCidade(viaCepResponse.getLocalidade()); //
                    endereco.setEstado(viaCepResponse.getUf()); //
                    endereco.setPais("Brasil"); // Define o país como Brasil (ViaCEP é nacional)
                    // Salva o endereço preenchido no banco de dados
                    return Mono.just(enderecoRepository.save(endereco)); //
                })
                // Se o CEP não for encontrado no ViaCEP (switchIfEmpty é acionado se o Mono anterior estiver vazio)
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Dados de CEP", "cep", dto.getCep()))) //
                .onErrorResume(e -> { // Trata erros que podem ocorrer durante o processo
                    // Se for uma exceção já conhecida (ResourceNotFoundException ou InvalidInputException), repassa
                    if (e instanceof ResourceNotFoundException || e instanceof InvalidInputException) { //
                        return Mono.error(e);
                    }
                    // Para outras exceções, encapsula em InvalidInputException
                    return Mono.error(new InvalidInputException("Erro ao consultar ViaCEP ou salvar endereço: " + e.getMessage())); //
                });
    }


    // Método para atualizar um endereço existente (reativo)
    @Transactional
    @CacheEvict(value = {"enderecosList", "enderecosFiltrados"}, allEntries = true) // Invalida caches de listagem
    @CachePut(value = "enderecoPorId", key = "#id") // Atualiza o cache específico do endereço
    public Mono<Endereco> atualizarEndereco(Long id, EnderecoRequestDto dto) { //
        return Mono.justOrEmpty(enderecoRepository.findById(id)) // Busca o endereço existente
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Endereço", id))) // Se não encontrar, lança erro
                .flatMap(enderecoExistente -> {
                    // Se um novo CEP foi fornecido no DTO, consulta o ViaCEP para atualizar os dados
                    if (dto.getCep() != null && !dto.getCep().isBlank() && !dto.getCep().equals(enderecoExistente.getCep())) { //
                        return viaCepService.buscarEnderecoPorCep(dto.getCep()) //
                                .flatMap(viaCepResponse -> {
                                    enderecoMapper.partialUpdate(dto, enderecoExistente); // Atualiza campos básicos do DTO
                                    // Preenche com os novos dados do ViaCEP
                                    enderecoExistente.setLogradouro(viaCepResponse.getLogradouro()); //
                                    enderecoExistente.setBairro(viaCepResponse.getBairro()); //
                                    enderecoExistente.setCidade(viaCepResponse.getLocalidade()); //
                                    enderecoExistente.setEstado(viaCepResponse.getUf()); //
                                    enderecoExistente.setPais("Brasil"); //
                                    return Mono.just(enderecoRepository.save(enderecoExistente)); // Salva o endereço atualizado
                                })
                                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Dados de CEP para atualização", "CEP", dto.getCep()))); //
                    } else {
                        // Se o CEP não mudou ou não foi fornecido, apenas atualiza os outros campos do DTO
                        enderecoMapper.partialUpdate(dto, enderecoExistente); //
                        return Mono.just(enderecoRepository.save(enderecoExistente)); // Salva o endereço atualizado
                    }
                })
                .onErrorResume(e -> { // Tratamento de erro
                    if (e instanceof ResourceNotFoundException || e instanceof InvalidInputException) { //
                        return Mono.error(e);
                    }
                    return Mono.error(new InvalidInputException("Erro inesperado ao atualizar endereço: " + e.getMessage())); //
                });
    }

    // Método para deletar um endereço
    @Transactional
    @CacheEvict(value = {"enderecoPorId", "enderecosList", "enderecosFiltrados"}, allEntries = true, key = "#id") // Remove o endereço dos caches relevantes
    public void deletarEndereco(Long id) {
        if (!enderecoRepository.existsById(id)) { // Verifica se o endereço existe
            throw new ResourceNotFoundException("Endereço", id); // Lança exceção se não encontrado
        }
        enderecoRepository.deleteById(id); // Deleta o endereço
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\EstacionamentoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: EstacionamentoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.exception.InvalidInputException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.repository.BoxRepository;
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.repository.relacionamento.VeiculoBoxRepository;
import br.com.fiap.mottu.service.ocr.PlateUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class EstacionamentoService {

    private final VeiculoRepository veiculoRepository;
    private final BoxRepository boxRepository;
    private final VeiculoBoxRepository veiculoBoxRepository;

    @Autowired
    public EstacionamentoService(VeiculoRepository veiculoRepository,
                                 BoxRepository boxRepository,
                                 VeiculoBoxRepository veiculoBoxRepository) {
        this.veiculoRepository = veiculoRepository;
        this.boxRepository = boxRepository;
        this.veiculoBoxRepository = veiculoBoxRepository;
    }

    @Transactional
    public Box parkMoto(String placa) {
        // 1) normaliza a placa recebida (corrige O↔0, I↔1, etc.) e usa UPPERCASE
        String normalized = PlateUtils.normalizeMercosul(placa);
        if (normalized.isEmpty()) {
            throw new InvalidInputException("Placa inválida.");
        }

        // 2) tenta match exato primeiro
        Optional<Veiculo> opt = veiculoRepository.findByPlaca(normalized);

        // 3) se não achou, faz fuzzy contra todas as placas cadastradas (normalizadas)
        Veiculo veiculo = opt.orElseGet(() -> {
            List<Veiculo> all = veiculoRepository.findAll();
            if (all.isEmpty()) throw new ResourceNotFoundException("Nenhum veículo cadastrado.");
            // Lista normalizada
            List<VeiculoNormalized> norm = all.stream()
                    .map(v -> new VeiculoNormalized(v, PlateUtils.normalizeMercosul(v.getPlaca())))
                    .collect(Collectors.toList());
            String bestPlate = PlateUtils.bestCandidate(
                    norm.stream().map(VeiculoNormalized::normalized).collect(Collectors.toList()),
                    normalized,
                    1 // tolera 1 erro; ajuste p/ 2 se necessário
            );
            if (bestPlate == null) {
                throw new ResourceNotFoundException("Veículo com placa " + placa + " não cadastrado.");
            }
            return norm.stream()
                    .min(Comparator.comparingInt(vn -> PlateUtils.levenshtein(vn.normalized(), normalized)))
                    .filter(vn -> PlateUtils.levenshtein(vn.normalized(), normalized) <= 1)
                    .map(VeiculoNormalized::entity)
                    .orElseThrow(() -> new ResourceNotFoundException("Veículo com placa " + placa + " não cadastrado."));
        });

        // 4) já estacionado?
        if (veiculo.getVeiculoBoxes() != null && !veiculo.getVeiculoBoxes().isEmpty()) {
            throw new InvalidInputException("Veículo de placa " + veiculo.getPlaca() + " já está estacionado.");
        }

        // 5) encontra primeira vaga livre
        Box vagaLivre = boxRepository.findAll().stream()
                .filter(box -> "L".equals(box.getStatus()))
                .findFirst()
                .orElseThrow(() -> new ResourceNotFoundException("Nenhuma vaga livre encontrada."));

        vagaLivre.setStatus("O");
        boxRepository.save(vagaLivre);

        VeiculoBox associacao = new VeiculoBox(veiculo, vagaLivre);
        veiculoBoxRepository.save(associacao);

        return vagaLivre;
    }

    @Transactional
    public void releaseSpot(String placa) {
        String normalized = PlateUtils.normalizeMercosul(placa);
        if (normalized.isEmpty()) {
            throw new InvalidInputException("Placa inválida.");
        }

        Veiculo veiculo = veiculoRepository.findByPlaca(normalized)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo com placa " + placa + " não encontrado."));

        VeiculoBox associacao = veiculo.getVeiculoBoxes().stream()
                .findFirst()
                .orElseThrow(() -> new ResourceNotFoundException("Veículo com placa " + placa + " não está estacionado em nenhum box."));

        Box boxOcupado = associacao.getBox();
        boxOcupado.setStatus("L");
        boxRepository.save(boxOcupado);

        veiculoBoxRepository.deleteById(associacao.getId());
    }

    /** Par auxiliar para manter a entidade + sua placa normalizada. */
    private record VeiculoNormalized(Veiculo entity, String normalized) {}
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\PatioService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: PatioService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.patio.PatioRequestDto; // DTO para entrada de dados de Pátio
import br.com.fiap.mottu.filter.PatioFilter; // Filtros para busca de Pátios
import br.com.fiap.mottu.mapper.PatioMapper; // Mapper para Pátio
import br.com.fiap.mottu.model.Patio; // Entidade Pátio
import br.com.fiap.mottu.model.Veiculo; // Entidade Veículo
import br.com.fiap.mottu.model.Zona; // Entidade Zona
import br.com.fiap.mottu.model.Box; // Entidade Box
import br.com.fiap.mottu.model.Contato; // Entidade Contato
import br.com.fiap.mottu.model.Endereco; // Entidade Endereço
// Entidades de Relacionamento e IDs
import br.com.fiap.mottu.model.relacionamento.*; // Importa todas as entidades de relacionamento
import br.com.fiap.mottu.repository.PatioRepository; // Repositório para Pátio
import br.com.fiap.mottu.repository.VeiculoRepository; // Repositório para Veículo
import br.com.fiap.mottu.repository.ZonaRepository; // Repositório para Zona
import br.com.fiap.mottu.repository.BoxRepository;          // Repositório para Box
import br.com.fiap.mottu.repository.ContatoRepository; // Repositório para Contato
import br.com.fiap.mottu.repository.EnderecoRepository; // Repositório para Endereço
// Repositórios de Relacionamento
import br.com.fiap.mottu.repository.relacionamento.*; // Importa todos os repositórios de relacionamento
import br.com.fiap.mottu.exception.DuplicatedResourceException; // Exceção para recursos duplicados
import br.com.fiap.mottu.exception.ResourceNotFoundException; // Exceção para recursos não encontrados
import br.com.fiap.mottu.specification.PatioSpecification; // Especificações para busca filtrada de Pátios
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict;    // Para invalidar cache
import org.springframework.cache.annotation.CachePut;      // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;     // Para habilitar cache em métodos
import org.springframework.data.domain.Page;          // Para resultados paginados
import org.springframework.data.domain.Pageable;        // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
import java.util.Set; // Para coleções
import java.util.stream.Collectors; // Para operações com streams

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class PatioService {

    private final PatioRepository patioRepository; // Repositório para Pátio
    private final PatioMapper patioMapper; // Mapper para Pátio
    private final VeiculoRepository veiculoRepository; // Repositório para Veículo
    private final ZonaRepository zonaRepository; // Repositório para Zona
    private final BoxRepository boxRepository; // Repositório para Box
    private final ContatoRepository contatoRepository; // Repositório para Contato
    private final EnderecoRepository enderecoRepository; // Repositório para Endereço
    // Repositórios das tabelas de junção
    private final VeiculoPatioRepository veiculoPatioRepository; //
    private final ZonaPatioRepository zonaPatioRepository; //
    private final ContatoPatioRepository contatoPatioRepository; //
    private final EnderecoPatioRepository enderecoPatioRepository; //
    private final PatioBoxRepository patioBoxRepository; //


    @Autowired // Construtor para injeção de dependências
    public PatioService(PatioRepository patioRepository, PatioMapper patioMapper,
                        VeiculoRepository veiculoRepository, ZonaRepository zonaRepository,
                        ContatoRepository contatoRepository, EnderecoRepository enderecoRepository,
                        VeiculoPatioRepository veiculoPatioRepository, ZonaPatioRepository zonaPatioRepository,
                        ContatoPatioRepository contatoPatioRepository, EnderecoPatioRepository enderecoPatioRepository,
                        BoxRepository boxRepository, PatioBoxRepository patioBoxRepository) { //
        this.patioRepository = patioRepository;
        this.patioMapper = patioMapper; //
        this.veiculoRepository = veiculoRepository;
        this.zonaRepository = zonaRepository;
        this.boxRepository = boxRepository; //
        this.contatoRepository = contatoRepository;
        this.enderecoRepository = enderecoRepository;
        this.veiculoPatioRepository = veiculoPatioRepository;
        this.zonaPatioRepository = zonaPatioRepository; //
        this.contatoPatioRepository = contatoPatioRepository;
        this.enderecoPatioRepository = enderecoPatioRepository;
        this.patioBoxRepository = patioBoxRepository; //
    }

    // Método para listar todos os pátios de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("patiosList") // Armazena em cache o resultado desta listagem paginada
    public Page<Patio> listarTodosPatios(Pageable pageable) {
        return patioRepository.findAll(pageable); // Busca todos os pátios usando paginação
    }

    // Método para buscar um pátio por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "patioPorId", key = "#id") // Armazena em cache o pátio buscado pelo ID
    public Patio buscarPatioPorId(Long id) {
        return patioRepository.findById(id) // Busca o pátio pelo ID
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", id)); // Lança exceção se não encontrado
    }

    // Método para buscar pátios por filtro e com paginação
    @Transactional(readOnly = true)
    // @Cacheable(value = "patiosFiltrados", key = "{#filter, #pageable}") // Considere adicionar se aplicável
    public Page<Patio> buscarPatiosPorFiltro(PatioFilter filter, Pageable pageable) {
        return patioRepository.findAll(PatioSpecification.withFilters(filter), pageable); // Busca pátios com filtros e paginação
    }

    // Método para criar um novo pátio
    @Transactional // Transação de escrita
    @CacheEvict(value = {"patiosList", "patioPorId"}, allEntries = true) // Invalida caches relevantes
    public Patio criarPatio(PatioRequestDto dto) { //
        String nome = dto.getNomePatio(); //
        // Verifica se já existe um pátio com o mesmo nome (ignorando maiúsculas/minúsculas)
        if (patioRepository.findByNomePatioIgnoreCase(nome).isPresent()) { //
            throw new DuplicatedResourceException("Pátio", "nomePátio", nome); // Lança exceção se nome duplicado
        }
        Patio patio = patioMapper.toEntity(dto); // Mapeia DTO para entidade
        return patioRepository.save(patio); // Salva o novo pátio
    }

    // Método para atualizar um pátio existente
    @Transactional
    @CachePut(value = "patioPorId", key = "#id") // Atualiza o cache 'patioPorId' com o pátio modificado
    @CacheEvict(value = "patiosList", allEntries = true) // Invalida o cache de listagem
    public Patio atualizarPatio(Long id, PatioRequestDto dto) { //
        return patioRepository.findById(id) // Busca o pátio existente
                .map(existente -> { // Se encontrado, atualiza
                    String novoNome = dto.getNomePatio(); //
                    // Verifica se o novo nome (se fornecido e diferente do atual) já existe em outro pátio
                    if (novoNome != null && !novoNome.isBlank() && !novoNome.equalsIgnoreCase(existente.getNomePatio())) { //
                        if (patioRepository.findByNomePatioIgnoreCase(novoNome) //
                                .filter(p -> !p.getIdPatio().equals(id)) // Exclui o próprio pátio da checagem
                                .isPresent()) {
                            throw new DuplicatedResourceException("Pátio", "nomePátio", novoNome); // Lança exceção se duplicado
                        }
                    }
                    patioMapper.partialUpdate(dto, existente); // Atualiza a entidade com dados do DTO
                    return patioRepository.save(existente); // Salva as alterações
                })
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", id)); // Lança exceção se não encontrado para atualização
    }

    // Método para deletar um pátio
    @Transactional
    @CacheEvict(value = {"patioPorId", "patiosList", "veiculosDoPatio", "zonasDoPatio", "contatosDoPatio", "enderecosDoPatio", "boxesDoPatio"}, allEntries = true, key = "#id")
    public void deletarPatio(Long id) {
        if (!patioRepository.existsById(id)) { // Verifica se o pátio existe
            throw new ResourceNotFoundException("Pátio", id); // Lança exceção se não encontrado
        }
        // A exclusão em cascata das associações (VeiculoPatio, ZonaPatio, etc.) é geralmente tratada pelo JPA
        // se 'orphanRemoval = true' e 'cascade = CascadeType.ALL' estiverem nas coleções da entidade Patio.
        patioRepository.deleteById(id); // Deleta o pátio
    }

    // --- Métodos de Associação ---
    // A invalidação de cache aqui é importante para dados derivados, como listas de veículos/zonas/etc. por pátio.

    // --- VeiculoPatio ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "veiculosDoPatio"}, key = "#patioId", allEntries = true) // Invalida cache do pátio e da lista de veículos dele
    public VeiculoPatio associarPatioVeiculo(Long patioId, Long veiculoId) {
        Patio patio = buscarPatioPorId(patioId); // Reutiliza o método que já lança exceção e usa cache
        Veiculo veiculo = veiculoRepository.findById(veiculoId) //
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", veiculoId)); //
        VeiculoPatioId idAssociacao = new VeiculoPatioId(veiculoId, patioId); //
        if (veiculoPatioRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Veículo", "IDs", idAssociacao.toString()); //
        }
        VeiculoPatio associacao = new VeiculoPatio(veiculo, patio); //
        return veiculoPatioRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "veiculosDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioVeiculo(Long patioId, Long veiculoId) {
        VeiculoPatioId idAssociacao = new VeiculoPatioId(veiculoId, patioId); //
        if (!veiculoPatioRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Veículo", "IDs", idAssociacao.toString()); //
        }
        veiculoPatioRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "veiculosDoPatio", key = "#patioId") // Cacheia a lista de veículos de um pátio
    public Set<Veiculo> getVeiculosByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getVeiculoPatios().stream() //
                .map(VeiculoPatio::getVeiculo) //
                .collect(Collectors.toSet()); //
    }

    // --- ZonaPatio ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "zonasDoPatio"}, key = "#patioId", allEntries = true)
    public ZonaPatio associarPatioZona(Long patioId, Long zonaId) {
        Patio patio = buscarPatioPorId(patioId);
        Zona zona = zonaRepository.findById(zonaId) //
                .orElseThrow(() -> new ResourceNotFoundException("Zona", zonaId)); //
        ZonaPatioId idAssociacao = new ZonaPatioId(patioId, zonaId); //
        if (zonaPatioRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Zona", "IDs", idAssociacao.toString()); //
        }
        ZonaPatio associacao = new ZonaPatio(patio, zona); //
        return zonaPatioRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "zonasDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioZona(Long patioId, Long zonaId) {
        ZonaPatioId idAssociacao = new ZonaPatioId(patioId, zonaId); //
        if (!zonaPatioRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Zona", "IDs", idAssociacao.toString()); //
        }
        zonaPatioRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "zonasDoPatio", key = "#patioId")
    public Set<Zona> getZonasByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getZonaPatios().stream() //
                .map(ZonaPatio::getZona) //
                .collect(Collectors.toSet()); //
    }

    // --- ContatoPatio ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "contatosDoPatio"}, key = "#patioId", allEntries = true)
    public ContatoPatio associarPatioContato(Long patioId, Long contatoId) {
        Patio patio = buscarPatioPorId(patioId);
        Contato contato = contatoRepository.findById(contatoId) //
                .orElseThrow(() -> new ResourceNotFoundException("Contato", contatoId)); //
        ContatoPatioId idAssociacao = new ContatoPatioId(patioId, contatoId); //
        if (contatoPatioRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Contato", "IDs", idAssociacao.toString()); //
        }
        ContatoPatio associacao = new ContatoPatio(patio, contato); //
        return contatoPatioRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "contatosDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioContato(Long patioId, Long contatoId) {
        ContatoPatioId idAssociacao = new ContatoPatioId(patioId, contatoId); //
        if (!contatoPatioRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Contato", "IDs", idAssociacao.toString()); //
        }
        contatoPatioRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatosDoPatio", key = "#patioId")
    public Set<Contato> getContatosByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getContatoPatios().stream() //
                .map(ContatoPatio::getContato) //
                .collect(Collectors.toSet()); //
    }

    // --- EnderecoPatio ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "enderecosDoPatio"}, key = "#patioId", allEntries = true)
    public EnderecoPatio associarPatioEndereco(Long patioId, Long enderecoId) {
        Patio patio = buscarPatioPorId(patioId);
        Endereco endereco = enderecoRepository.findById(enderecoId) //
                .orElseThrow(() -> new ResourceNotFoundException("Endereço", enderecoId)); //
        EnderecoPatioId idAssociacao = new EnderecoPatioId(enderecoId, patioId); //
        if (enderecoPatioRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Endereço", "IDs", idAssociacao.toString()); //
        }
        EnderecoPatio associacao = new EnderecoPatio(endereco, patio); //
        return enderecoPatioRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "enderecosDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioEndereco(Long patioId, Long enderecoId) {
        EnderecoPatioId idAssociacao = new EnderecoPatioId(enderecoId, patioId); //
        if (!enderecoPatioRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Endereço", "IDs", idAssociacao.toString()); //
        }
        enderecoPatioRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "enderecosDoPatio", key = "#patioId")
    public Set<Endereco> getEnderecosByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getEnderecoPatios().stream() //
                .map(EnderecoPatio::getEndereco) //
                .collect(Collectors.toSet()); //
    }

    // --- PatioBox ---
    @Transactional
    @CacheEvict(value = {"patioPorId", "boxesDoPatio"}, key = "#patioId", allEntries = true)
    public PatioBox associarPatioBox(Long patioId, Long boxId) {
        Patio patio = buscarPatioPorId(patioId);
        Box box = boxRepository.findById(boxId) //
                .orElseThrow(() -> new ResourceNotFoundException("Box", boxId)); //
        PatioBoxId idAssociacao = new PatioBoxId(patioId, boxId); //
        if (patioBoxRepository.existsById(idAssociacao)) {
            throw new DuplicatedResourceException("Associação Pátio-Box", "IDs", idAssociacao.toString()); //
        }
        PatioBox associacao = new PatioBox(patio, box); //
        return patioBoxRepository.save(associacao); //
    }

    @Transactional
    @CacheEvict(value = {"patioPorId", "boxesDoPatio"}, key = "#patioId", allEntries = true)
    public void desassociarPatioBox(Long patioId, Long boxId) {
        PatioBoxId idAssociacao = new PatioBoxId(patioId, boxId); //
        if (!patioBoxRepository.existsById(idAssociacao)) {
            throw new ResourceNotFoundException("Associação Pátio-Box", "IDs", idAssociacao.toString()); //
        }
        patioBoxRepository.deleteById(idAssociacao); //
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "boxesDoPatio", key = "#patioId")
    public Set<Box> getBoxesByPatioId(Long patioId) {
        Patio patio = buscarPatioPorId(patioId); //
        return patio.getPatioBoxes().stream() //
                .map(PatioBox::getBox) //
                .collect(Collectors.toSet()); //
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\RastreamentoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: RastreamentoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.repository.RastreamentoRepository;
import br.com.fiap.mottu.exception.*;
import br.com.fiap.mottu.specification.RastreamentoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class RastreamentoService {

    private final RastreamentoRepository rastreamentoRepository;
    private final RastreamentoMapper rastreamentoMapper;

    @Autowired
    public RastreamentoService(RastreamentoRepository rastreamentoRepository,
                               RastreamentoMapper rastreamentoMapper) {
        this.rastreamentoRepository = rastreamentoRepository;
        this.rastreamentoMapper = rastreamentoMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable("rastreamentosList")
    public Page<Rastreamento> listarTodosRastreamentos(Pageable pageable) {
        return rastreamentoRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "rastreamentoPorId", key = "#id")
    public Rastreamento buscarRastreamentoPorId(Long id) {
        return rastreamentoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Rastreamento", id));
    }

    @Transactional(readOnly = true)
    public Page<Rastreamento> buscarRastreamentosPorFiltro(RastreamentoFilter filter, Pageable pageable) {
        return rastreamentoRepository.findAll(RastreamentoSpecification.withFilters(filter), pageable);
    }

    @Transactional
    @CacheEvict(value = {"rastreamentosList", "rastreamentoPorId"}, allEntries = true)
    public Rastreamento criarRastreamento(RastreamentoRequestDto dto) {
        if (dto.getIpsX() == null || dto.getIpsY() == null || dto.getIpsZ() == null ||
                dto.getGprsLatitude() == null || dto.getGprsLongitude() == null || dto.getGprsAltitude() == null) {
            throw new InvalidInputException("Todas as coordenadas (IPS_X, IPS_Y, IPS_Z, GPRS_LATITUDE, GPRS_LONGITUDE, GPRS_ALTITUDE) são obrigatórias.");
        }
        Rastreamento rastreamento = rastreamentoMapper.toEntity(dto);
        return rastreamentoRepository.save(rastreamento);
    }

    @Transactional
    @CachePut(value = "rastreamentoPorId", key = "#id")
    @CacheEvict(value = "rastreamentosList", allEntries = true)
    public Rastreamento atualizarRastreamento(Long id, RastreamentoRequestDto dto) {
        return rastreamentoRepository.findById(id)
                .map(existente -> {
                    if (dto.getIpsX() == null || dto.getIpsY() == null || dto.getIpsZ() == null ||
                            dto.getGprsLatitude() == null || dto.getGprsLongitude() == null || dto.getGprsAltitude() == null) {
                        throw new InvalidInputException("Na atualização, todas as coordenadas devem ser fornecidas se a intenção for alterá-las.");
                    }
                    rastreamentoMapper.partialUpdate(dto, existente);
                    return rastreamentoRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Rastreamento", id));
    }

    @Transactional
    @CacheEvict(value = {"rastreamentoPorId", "rastreamentosList"}, allEntries = true, key = "#id")
    public void deletarRastreamento(Long id) {
        if (!rastreamentoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Rastreamento", id);
        }
        rastreamentoRepository.deleteById(id);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\VeiculoService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: VeiculoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto;
import br.com.fiap.mottu.filter.VeiculoFilter;
import br.com.fiap.mottu.mapper.VeiculoMapper;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.mapper.PatioMapper;
import br.com.fiap.mottu.mapper.ZonaMapper;
import br.com.fiap.mottu.mapper.BoxMapper;
import br.com.fiap.mottu.model.*;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.specification.VeiculoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Comparator;

@Service
public class VeiculoService {

    private final VeiculoRepository veiculoRepository;
    private final VeiculoMapper veiculoMapper;
    private final RastreamentoMapper rastreamentoMapper;
    private final PatioMapper patioMapper;
    private final ZonaMapper zonaMapper;
    private final BoxMapper boxMapper;

    @Autowired
    public VeiculoService(VeiculoRepository veiculoRepository,
                          VeiculoMapper veiculoMapper,
                          RastreamentoMapper rastreamentoMapper,
                          PatioMapper patioMapper,
                          ZonaMapper zonaMapper,
                          BoxMapper boxMapper) {
        this.veiculoRepository = veiculoRepository;
        this.veiculoMapper = veiculoMapper;
        this.rastreamentoMapper = rastreamentoMapper;
        this.patioMapper = patioMapper;
        this.zonaMapper = zonaMapper;
        this.boxMapper = boxMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable("veiculosList")
    public Page<Veiculo> listarTodosVeiculos(Pageable pageable) {
        return veiculoRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "veiculoPorId", key = "#id")
    public Veiculo buscarVeiculoPorId(Long id) {
        return veiculoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", id));
    }

    @Transactional(readOnly = true)
    public Page<Veiculo> buscarVeiculosPorFiltro(VeiculoFilter filter, Pageable pageable) {
        return veiculoRepository.findAll(VeiculoSpecification.withFilters(filter), pageable);
    }

    @Transactional
    @CacheEvict(value = {"veiculosList", "veiculoLocalizacao"}, allEntries = true)
    public Veiculo criarVeiculo(VeiculoRequestDto dto) {
        // Validações de campos únicos
        if (veiculoRepository.findByPlaca(dto.getPlaca()).isPresent()) {
            throw new DuplicatedResourceException("Veículo", "placa", dto.getPlaca());
        }
        if (veiculoRepository.findByRenavam(dto.getRenavam()).isPresent()) {
            throw new DuplicatedResourceException("Veículo", "RENAVAM", dto.getRenavam());
        }
        if (veiculoRepository.findByChassi(dto.getChassi()).isPresent()) {
            throw new DuplicatedResourceException("Veículo", "chassi", dto.getChassi());
        }
        if (dto.getTagBleId() != null && !dto.getTagBleId().isBlank()) {
            if (veiculoRepository.findByTagBleId(dto.getTagBleId()).isPresent()) {
                throw new DuplicatedResourceException("Veículo", "tagBleId", dto.getTagBleId());
            }
        }

        Veiculo veiculo = veiculoMapper.toEntity(dto);
        // A lógica da tag agora é tratada diretamente pelo mapper.
        return veiculoRepository.save(veiculo);
    }

    @Transactional
    @CachePut(value = "veiculoPorId", key = "#id")
    @CacheEvict(value = {"veiculosList", "veiculoLocalizacao"}, allEntries = true)
    public Veiculo atualizarVeiculo(Long id, VeiculoRequestDto dto) {
        Veiculo existente = veiculoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", id));

        // Validações de campos únicos
        if (dto.getPlaca() != null && !dto.getPlaca().isBlank() && !dto.getPlaca().equals(existente.getPlaca())) {
            veiculoRepository.findByPlaca(dto.getPlaca()).filter(v -> !v.getIdVeiculo().equals(id))
                    .ifPresent(v -> { throw new DuplicatedResourceException("Veículo", "placa", dto.getPlaca()); });
        }
        if (dto.getRenavam() != null && !dto.getRenavam().isBlank() && !dto.getRenavam().equals(existente.getRenavam())) {
            veiculoRepository.findByRenavam(dto.getRenavam()).filter(v -> !v.getIdVeiculo().equals(id))
                    .ifPresent(v -> { throw new DuplicatedResourceException("Veículo", "RENAVAM", dto.getRenavam()); });
        }
        if (dto.getChassi() != null && !dto.getChassi().isBlank() && !dto.getChassi().equals(existente.getChassi())) {
            veiculoRepository.findByChassi(dto.getChassi()).filter(v -> !v.getIdVeiculo().equals(id))
                    .ifPresent(v -> { throw new DuplicatedResourceException("Veículo", "chassi", dto.getChassi()); });
        }
        if (dto.getTagBleId() != null && !dto.getTagBleId().isBlank() && !dto.getTagBleId().equals(existente.getTagBleId())) {
            veiculoRepository.findByTagBleId(dto.getTagBleId()).filter(v -> !v.getIdVeiculo().equals(id))
                    .ifPresent(v -> { throw new DuplicatedResourceException("Veículo", "tagBleId", dto.getTagBleId()); });
        }

        // O mapper cuidará da atualização dos campos, incluindo tagBleId e status
        veiculoMapper.partialUpdate(dto, existente);
        return veiculoRepository.save(existente);
    }

    @Transactional
    @CacheEvict(value = {"veiculoPorId", "veiculosList", "veiculoLocalizacao"}, allEntries = true, key = "#id")
    public void deletarVeiculo(Long id) {
        if (!veiculoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Veículo", id);
        }
        veiculoRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "veiculoLocalizacao", key = "#veiculoId")
    public VeiculoLocalizacaoResponseDto getLocalizacaoVeiculo(Long veiculoId) {
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", veiculoId));

        Rastreamento ultimoRastreamento = veiculo.getVeiculoRastreamentos().stream()
                .map(VeiculoRastreamento::getRastreamento)
                .filter(r -> r != null && r.getDataHoraRegistro() != null)
                .max(Comparator.comparing(Rastreamento::getDataHoraRegistro))
                .orElse(null);

        Patio patioAssociado = veiculo.getVeiculoPatios().stream()
                .map(VeiculoPatio::getPatio)
                .findFirst()
                .orElse(null);

        Zona zonaAssociada = veiculo.getVeiculoZonas().stream()
                .map(VeiculoZona::getZona)
                .findFirst()
                .orElse(null);

        Box boxAssociado = veiculo.getVeiculoBoxes().stream()
                .map(VeiculoBox::getBox)
                .findFirst()
                .orElse(null);

        return new VeiculoLocalizacaoResponseDto(
                veiculo.getIdVeiculo(),
                veiculo.getPlaca(),
                veiculo.getModelo(),
                veiculo.getFabricante(),
                veiculo.getStatus(),
                veiculo.getTagBleId(),
                (ultimoRastreamento != null) ? rastreamentoMapper.toResponseDto(ultimoRastreamento) : null,
                (patioAssociado != null) ? patioMapper.toResponseDto(patioAssociado) : null,
                (zonaAssociada != null) ? zonaMapper.toResponseDto(zonaAssociada) : null,
                (boxAssociado != null) ? boxMapper.toResponseDto(boxAssociado) : null,
                LocalDateTime.now()
        );
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ZonaService.java   |   PACOTE: br.com.fiap.mottu.service   |   CLASSE: ZonaService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto; // DTO para entrada de dados de Zona
import br.com.fiap.mottu.filter.ZonaFilter; // Filtros para busca de Zonas
import br.com.fiap.mottu.mapper.ZonaMapper; // Mapper para converter entre Entidade e DTOs de Zona 
import br.com.fiap.mottu.model.Zona; // Entidade Zona 
import br.com.fiap.mottu.repository.ZonaRepository; // Repositório para Zona 
import br.com.fiap.mottu.exception.*; // Importa todas as exceções customizadas
import br.com.fiap.mottu.specification.ZonaSpecification; // Especificações para busca filtrada de Zona 
import org.springframework.beans.factory.annotation.Autowired; // Para injeção de dependência
import org.springframework.cache.annotation.CacheEvict;    // Para invalidar cache
import org.springframework.cache.annotation.CachePut;      // Para atualizar cache
import org.springframework.cache.annotation.Cacheable;     // Para habilitar cache em métodos
import org.springframework.data.domain.Page;          // Para resultados paginados
import org.springframework.data.domain.Pageable;        // Para informações de paginação
import org.springframework.stereotype.Service; // Marca a classe como um serviço do Spring
import org.springframework.transaction.annotation.Transactional; // Para gerenciamento de transações
// import java.util.List; // Não é mais o tipo de retorno público principal para listagens 

@Service // Indica que esta classe é um componente de serviço gerenciado pelo Spring
public class ZonaService {

    private final ZonaRepository zonaRepository; // Repositório para operações de Zona no banco
    private final ZonaMapper zonaMapper; // Mapper para Zona 

    @Autowired // Injeta as dependências automaticamente pelo Spring
    public ZonaService(ZonaRepository zonaRepository, ZonaMapper zonaMapper) {
        this.zonaRepository = zonaRepository; // 
        this.zonaMapper = zonaMapper; // 
    }

    // Método para listar todas as zonas de forma paginada
    @Transactional(readOnly = true) // Transação apenas de leitura
    @Cacheable("zonasList") // Armazena em cache o resultado desta listagem paginada
    public Page<Zona> listarTodasZonas(Pageable pageable) {
        return zonaRepository.findAll(pageable); // Busca todas as zonas usando paginação 
    }

    // Método para buscar uma zona por ID
    @Transactional(readOnly = true)
    @Cacheable(value = "zonaPorId", key = "#id") // Armazena em cache a zona buscada pelo ID
    public Zona buscarZonaPorId(Long id) {
        return zonaRepository.findById(id) // Busca a zona pelo ID 
                .orElseThrow(() -> new ResourceNotFoundException("Zona", id)); // Lança exceção se não encontrada 
    }

    // Método para buscar zonas por filtro e com paginação
    @Transactional(readOnly = true)
    // @Cacheable(value = "zonasFiltradas", key = "{#filter, #pageable}") // Considere adicionar se aplicável
    public Page<Zona> buscarZonasPorFiltro(ZonaFilter filter, Pageable pageable) {
        return zonaRepository.findAll(ZonaSpecification.withFilters(filter), pageable); // Busca zonas com filtros e paginação 
    }

    // Método para criar uma nova zona
    @Transactional // Transação de escrita
    @CacheEvict(value = {"zonasList", "zonaPorId"}, allEntries = true) // Invalida caches relevantes
    public Zona criarZona(ZonaRequestDto dto) { // 
        String nome = dto.getNome(); // 
        // Verifica se já existe uma zona com o mesmo nome (ignorando maiúsculas/minúsculas)
        if (zonaRepository.findByNomeIgnoreCase(nome).isPresent()) { // 
            throw new DuplicatedResourceException("Zona", "nome", nome); // Lança exceção se nome duplicado 
        }
        Zona zona = zonaMapper.toEntity(dto); // Mapeia DTO para entidade 
        return zonaRepository.save(zona); // Salva a nova zona 
    }

    // Método para atualizar uma zona existente
    @Transactional
    @CachePut(value = "zonaPorId", key = "#id") // Atualiza o cache 'zonaPorId' com a zona modificada
    @CacheEvict(value = "zonasList", allEntries = true) // Invalida o cache de listagem
    public Zona atualizarZona(Long id, ZonaRequestDto dto) { // 
        return zonaRepository.findById(id) // Busca a zona existente 
                .map(existente -> { // Se encontrada, atualiza
                    String novoNome = dto.getNome(); // 
                    // Verifica se o novo nome (se fornecido e diferente do atual) já existe em outra zona
                    if (novoNome != null && !novoNome.isBlank() && !novoNome.equalsIgnoreCase(existente.getNome())) { // 
                        if (zonaRepository.findByNomeIgnoreCase(novoNome) // 
                                .filter(z -> !z.getIdZona().equals(id)) // Exclui a própria zona da checagem
                                .isPresent()) {
                            throw new DuplicatedResourceException("Zona", "nome", novoNome); // Lança exceção se duplicado 
                        }
                    }
                    zonaMapper.partialUpdate(dto, existente); // Atualiza a entidade com dados do DTO 
                    return zonaRepository.save(existente); // Salva as alterações
                })
                .orElseThrow(() -> new ResourceNotFoundException("Zona", id)); // Lança exceção se não encontrada para atualização 
    }

    // Método para deletar uma zona
    @Transactional
    @CacheEvict(value = {"zonaPorId", "zonasList"}, allEntries = true, key = "#id") // Remove a zona dos caches relevantes
    public void deletarZona(Long id) {
        if (!zonaRepository.existsById(id)) { // Verifica se a zona existe 
            throw new ResourceNotFoundException("Zona", id); // Lança exceção se não encontrada 
        }
        // A exclusão em cascata das associações (VeiculoZona, ZonaBox, ZonaPatio) é geralmente tratada pelo JPA
        // se 'orphanRemoval = true' e 'cascade = CascadeType.ALL' estiverem nas coleções da entidade Zona.
        zonaRepository.deleteById(id); // Deleta a zona 
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.service.ocr
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\ImageCVUtils.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: ImageCVUtils
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service.ocr;

import org.opencv.core.CvType;
import org.opencv.core.Mat;

import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;

/**
 * Utilitários mínimos para converter entre BufferedImage e Mat.
 * Mantém BGR de forma compatível com o OpenCV.
 */
public final class ImageCVUtils {

    private ImageCVUtils() {}

    public static Mat bufferedToMat(BufferedImage bi) {
        // garante formato 3 canais
        BufferedImage img = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_3BYTE_BGR);
        img.getGraphics().drawImage(bi, 0, 0, null);

        byte[] data = ((DataBufferByte) img.getRaster().getDataBuffer()).getData();
        Mat mat = new Mat(img.getHeight(), img.getWidth(), CvType.CV_8UC3);
        mat.put(0, 0, data);
        return mat;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\OcrSession.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: OcrSession
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// mottu-gradle/src/main/java/br/com/fiap/mottu/service/ocr/OcrSession.java

package br.com.fiap.mottu.service.ocr;

import lombok.Data;

@Data
public class OcrSession {
    public enum Status {
        PENDING, // Aguardando a imagem do celular
        PROCESSING, // Processando a imagem no backend
        COMPLETED, // Placa reconhecida com sucesso
        ERROR // Ocorreu um erro
    }

    private final String id;
    private Status status = Status.PENDING;
    private String recognizedPlate;
    private String errorMessage;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\OcrSessionManager.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: OcrSessionManager
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// mottu-gradle/src/main/java/br/com/fiap/mottu/service/ocr/OcrSessionManager.java

package br.com.fiap.mottu.service.ocr;

import org.springframework.stereotype.Component;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class OcrSessionManager {
    private final ConcurrentHashMap<String, OcrSession> sessions = new ConcurrentHashMap<>();

    public OcrSession createSession() {
        String sessionId = UUID.randomUUID().toString();
        OcrSession session = new OcrSession(sessionId);
        sessions.put(sessionId, session);
        return session;
    }

    public Optional<OcrSession> getSession(String sessionId) {
        return Optional.ofNullable(sessions.get(sessionId));
    }

    public void updateSessionSuccess(String sessionId, String plate) {
        Optional.ofNullable(sessions.get(sessionId)).ifPresent(session -> {
            session.setStatus(OcrSession.Status.COMPLETED);
            session.setRecognizedPlate(plate);
        });
    }

    public void updateSessionError(String sessionId, String errorMessage) {
        Optional.ofNullable(sessions.get(sessionId)).ifPresent(session -> {
            session.setStatus(OcrSession.Status.ERROR);
            session.setErrorMessage(errorMessage);
        });
    }

    public void setSessionProcessing(String sessionId) {
        Optional.ofNullable(sessions.get(sessionId)).ifPresent(session -> {
            session.setStatus(OcrSession.Status.PROCESSING);
        });
    }

    public void removeSession(String sessionId) {
        sessions.remove(sessionId);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\PlateUtils.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: PlateUtils
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service.ocr;

import java.text.Normalizer;
import java.util.Collection;
import java.util.Comparator;
import java.util.Objects;

/**
 * Utilitários para limpeza, normalização (padrão Mercosul) e "fuzzy match" de placas.
 * Mantido no pacote service.ocr, seguindo o padrão do projeto.
 */
public final class PlateUtils {

    private PlateUtils() {}

    /** Remove acentos, espaços, traços e qualquer caractere não [A-Za-z0-9], e coloca em UPPERCASE. */
    public static String cleanRaw(String s) {
        if (s == null) return "";
        String nfd = Normalizer.normalize(s, Normalizer.Form.NFD);
        String noMarks = nfd.replaceAll("\\p{M}", "");
        return noMarks.replaceAll("[^A-Za-z0-9]", "").toUpperCase();
    }

    /**
     * Normaliza para o formato Mercosul (LLLNLNN – 7 chars).
     * Faz mapeamento heurístico letra↔número por posição para corrigir confusões comuns do OCR.
     */
    public static String normalizeMercosul(String raw) {
        String s = cleanRaw(raw);
        if (s.length() < 7) return s; // retorna o que tiver; o chamador decide se aceita

        char[] a = s.toCharArray();
        // Posições: 0..2 (letras), 3 (número), 4 (letra), 5..6 (números)
        fixAsLetter(a, 0);
        fixAsLetter(a, 1);
        fixAsLetter(a, 2);
        fixAsDigit(a, 3);
        fixAsLetter(a, 4);
        fixAsDigit(a, 5);
        fixAsDigit(a, 6);

        String out = new String(a);
        return out.substring(0, 7);
    }

    private static void fixAsLetter(char[] a, int i) {
        if (i >= a.length) return;
        char c = a[i];
        // Se veio dígito parecido com letra, converte
        switch (c) {
            case '0': a[i] = 'O'; break;
            case '1': a[i] = 'I'; break; // ou 'L', preferimos I
            case '2': a[i] = 'Z'; break;
            case '5': a[i] = 'S'; break;
            case '6': a[i] = 'G'; break;
            case '8': a[i] = 'B'; break;
            case '4': a[i] = 'A'; break;
            case '7': a[i] = 'T'; break;
            default: a[i] = Character.toUpperCase(c);
        }
    }

    private static void fixAsDigit(char[] a, int i) {
        if (i >= a.length) return;
        char c = Character.toUpperCase(a[i]);
        switch (c) {
            case 'O': case 'Q': case 'D': a[i] = '0'; break;
            case 'I': case 'L': a[i] = '1'; break;
            case 'Z': a[i] = '2'; break;
            case 'S': a[i] = '5'; break;
            case 'B': a[i] = '8'; break;
            case 'G': a[i] = '6'; break;
            case 'A': a[i] = '4'; break; // menos comum, mas ajuda
            case 'T': a[i] = '7'; break;
            default: a[i] = c;
        }
        if (!Character.isDigit(a[i])) {
            // fallback: se ainda ficou letra, força para 0
            a[i] = '0';
        }
    }

    /** Distância de Levenshtein iterativa. */
    public static int levenshtein(String a, String b) {
        if (Objects.equals(a, b)) return 0;
        if (a == null || a.isEmpty()) return b == null ? 0 : b.length();
        if (b == null || b.isEmpty()) return a.length();

        int[] prev = new int[b.length() + 1];
        int[] curr = new int[b.length() + 1];

        for (int j = 0; j <= b.length(); j++) prev[j] = j;

        for (int i = 1; i <= a.length(); i++) {
            curr[0] = i;
            char ca = a.charAt(i - 1);
            for (int j = 1; j <= b.length(); j++) {
                int cost = (ca == b.charAt(j - 1)) ? 0 : 1;
                curr[j] = Math.min(
                        Math.min(curr[j - 1] + 1, prev[j] + 1),
                        prev[j - 1] + cost
                );
            }
            int[] tmp = prev; prev = curr; curr = tmp;
        }
        return prev[b.length()];
    }

    /**
     * Retorna o melhor match (menor distância) até maxDistance ou null.
     * A coleção pode ser a lista de placas do repositório já normalizadas.
     */
    public static String bestCandidate(Collection<String> knownPlates, String candidate, int maxDistance) {
        if (candidate == null) return null;
        return knownPlates.stream()
                .min(Comparator.comparingInt(p -> levenshtein(p, candidate)))
                .filter(best -> levenshtein(best, candidate) <= maxDistance)
                .orElse(null);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\TesseractService.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: TesseractService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service.ocr;

import br.com.fiap.mottu.exception.InvalidInputException;
import jakarta.annotation.PostConstruct;
import net.sourceforge.tess4j.ITesseract;
import net.sourceforge.tess4j.Tesseract;
import net.sourceforge.tess4j.TesseractException;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.*;
import java.util.List;

@Service
public class TesseractService {

    private static final Logger log = LoggerFactory.getLogger(TesseractService.class);

    // --- DECLARAÇÃO DAS VARIÁVEIS DE CLASSE (ESTA PARTE ESTAVA FALTANDO) ---
    @Value("${mottu.ocr.lang:por+eng}")
    private String configuredLang;

    @Value("${mottu.ocr.tessdata-path:}")
    private String configuredTessdataPath;

    private File tessdataDirResolved;
    private final OcrSessionManager sessionManager;
    private final Path runtimeRootDir; // <-- A VARIÁVEL QUE FALTAVA
    private final Path runtimeTessdataDir;
    // --- FIM DAS DECLARAÇÕES ---

    public TesseractService(OcrSessionManager sessionManager) {
        this.sessionManager = sessionManager;
        ImageIO.setUseCache(false);

        try {
            // Inicialização das variáveis
            this.runtimeRootDir = Files.createTempDirectory("mottu-ocr-" + Instant.now().toEpochMilli());
            this.runtimeTessdataDir = Files.createDirectories(this.runtimeRootDir.resolve("tessdata"));
            copyTessdataFromClasspath();
            log.info("TesseractService inicializado. Diretório de trabalho: {}", runtimeRootDir);
        } catch (IOException e) {
            throw new UncheckedIOException("Falha crítica ao preparar diretório de trabalho do OCR", e);
        }
    }

    @PostConstruct
    public void init() {
        resolveTessdataPath();
        log.info("Idiomas de OCR configurados='{}'", configuredLang);
    }

    private void resolveTessdataPath() {
        List<String> triedPaths = new ArrayList<>();
        if (configuredTessdataPath != null && !configuredTessdataPath.isBlank()) {
            File f = new File(configuredTessdataPath);
            triedPaths.add("propriedade 'mottu.ocr.tessdata-path': " + f.getAbsolutePath());
            if (f.isDirectory()) {
                tessdataDirResolved = f;
            }
        }
        if (tessdataDirResolved == null) {
            String envPath = System.getenv("TESSDATA_PREFIX");
            if (envPath != null && !envPath.isBlank()) {
                File f = new File(envPath);
                triedPaths.add("variável de ambiente 'TESSDATA_PREFIX': " + f.getAbsolutePath());
                if (f.isDirectory()) {
                    tessdataDirResolved = f;
                }
            }
        }
        if (tessdataDirResolved == null) {
            tessdataDirResolved = this.runtimeTessdataDir.toFile();
            triedPaths.add("extração do classpath para: " + tessdataDirResolved.getAbsolutePath());
        }

        if (tessdataDirResolved != null && tessdataDirResolved.listFiles((dir, name) -> name.endsWith(".traineddata")).length > 0) {
            log.info("✅ Tesseract 'tessdata' localizado com sucesso em: {}", tessdataDirResolved.getAbsolutePath());
        } else {
            log.error("❌ FALHA CRÍTICA: Não foi possível resolver a pasta 'tessdata'. Tentativas: {}", triedPaths);
        }
    }

    private void copyTessdataFromClasspath() throws IOException {
        String[] entries = {"eng.traineddata", "por.traineddata", "osd.traineddata"};
        for (String entry : entries) {
            String resourcePath = "/tessdata/" + entry;
            try (InputStream in = getClass().getResourceAsStream(resourcePath)) {
                if (in == null) {
                    log.warn("Recurso de OCR não encontrado no classpath: {}", resourcePath);
                    continue;
                }
                Files.copy(in, this.runtimeTessdataDir.resolve(entry));
                log.info("Recurso de OCR copiado: {}", entry);
            }
        }
    }

    public void extractPlate(String sessionId, byte[] imageBytes) {
        sessionManager.setSessionProcessing(sessionId);
        try {
            if (imageBytes == null || imageBytes.length == 0) {
                throw new InvalidInputException("Arquivo de imagem está vazio ou corrompido.");
            }
            BufferedImage sourceImage = readImageStrict(imageBytes);
            BufferedImage processedImage = preprocessImageForOcr(sourceImage);
            Path pngTempFile = writePngTemp(processedImage);
            String ocrResult = runTesseractOcr(pngTempFile);
            String normalizedPlate = PlateUtils.normalizeMercosul(ocrResult);

            if (normalizedPlate == null || normalizedPlate.length() < 7) {
                throw new InvalidInputException("Não foi possível reconhecer uma placa válida na imagem.");
            }
            log.info("Sessão {}: Placa reconhecida e normalizada: {}", sessionId, normalizedPlate);
            sessionManager.updateSessionSuccess(sessionId, normalizedPlate);
        } catch (Throwable ex) {
            log.error("Sessão {}: Falha no processo de OCR: {}", sessionId, ex.getMessage(), ex);
            String errorMessage = (ex instanceof InvalidInputException) ? ex.getMessage() : "Erro interno ao processar a imagem.";
            sessionManager.updateSessionError(sessionId, errorMessage);
        }
    }

    private String runTesseractOcr(Path imageFile) throws TesseractException {
        if (tessdataDirResolved == null || !tessdataDirResolved.isDirectory()) {
            throw new TesseractException("Diretório 'tessdata' não foi inicializado.");
        }
        ITesseract tesseract = new Tesseract();
        tesseract.setDatapath(tessdataDirResolved.getParentFile().getAbsolutePath());
        String langToUse = chooseLanguage(configuredLang);
        tesseract.setLanguage(langToUse);
        tesseract.setTessVariable("user_defined_dpi", "300");
        long startTime = System.currentTimeMillis();
        String result = tesseract.doOCR(imageFile.toFile());
        long duration = System.currentTimeMillis() - startTime;
        log.info("Tess4J executado em {} ms com o idioma '{}'", duration, langToUse);
        return result != null ? result.trim() : "";
    }

    private String chooseLanguage(String requested) {
        Set<String> availableLangs = listAvailableLanguages();
        if (availableLangs.isEmpty()) {
            log.error("Nenhum arquivo .traineddata encontrado em {}", tessdataDirResolved);
            return "eng";
        }
        List<String> langsToUse = new ArrayList<>();
        for (String lang : requested.split("\\+")) {
            if (availableLangs.contains(lang.trim())) {
                langsToUse.add(lang.trim());
            }
        }
        if (langsToUse.isEmpty()) {
            if (availableLangs.contains("eng")) {
                log.warn("Idiomas requisitados '{}' não encontrados. Usando fallback 'eng'.", requested);
                return "eng";
            } else {
                String fallback = availableLangs.iterator().next();
                log.warn("Idiomas requisitados '{}' e 'eng' não encontrados. Usando fallback: '{}'", requested, fallback);
                return fallback;
            }
        }
        return String.join("+", langsToUse);
    }

    private Set<String> listAvailableLanguages() {
        Set<String> languages = new HashSet<>();
        if (tessdataDirResolved == null || !tessdataDirResolved.isDirectory()) return languages;
        File[] files = tessdataDirResolved.listFiles((dir, name) -> name.toLowerCase().endsWith(".traineddata"));
        if (files != null) {
            for (File f : files) {
                languages.add(f.getName().replace(".traineddata", ""));
            }
        }
        return languages;
    }

    private BufferedImage readImageStrict(byte[] bytes) throws IOException {
        try (ImageInputStream iis = ImageIO.createImageInputStream(new ByteArrayInputStream(bytes))) {
            if (iis == null) throw new IOException("Não foi possível criar ImageInputStream.");
            Iterator<ImageReader> readers = ImageIO.getImageReaders(iis);
            if (!readers.hasNext()) throw new IOException("Formato de imagem não suportado.");
            ImageReader reader = readers.next();
            try {
                reader.setInput(iis, true, true);
                BufferedImage img = reader.read(0);
                if (img == null) throw new IOException("Falha ao decodificar a imagem.");
                return ensureBufferedRgb(img);
            } finally {
                reader.dispose();
            }
        }
    }

    private BufferedImage ensureBufferedRgb(BufferedImage img) {
        if (img.getType() == BufferedImage.TYPE_INT_RGB) return img;
        BufferedImage copy = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_INT_RGB);
        Graphics2D g = copy.createGraphics();
        try { g.drawImage(img, 0, 0, null); } finally { g.dispose(); }
        return copy;
    }

    private Path writePngTemp(BufferedImage img) throws IOException {
        Path tmp = Files.createTempFile(this.runtimeRootDir, "ocr-processed-", ".png");
        ImageIO.write(img, "png", tmp.toFile());
        return tmp;
    }

    private BufferedImage preprocessImageForOcr(BufferedImage image) throws IOException {
        Mat mat = bufferedImageToMat(image);
        Mat grayMat = new Mat();
        Imgproc.cvtColor(mat, grayMat, Imgproc.COLOR_BGR2GRAY);
        Mat blurredMat = new Mat();
        Imgproc.GaussianBlur(grayMat, blurredMat, new Size(3, 3), 0);
        Mat threshMat = new Mat();
        Imgproc.adaptiveThreshold(blurredMat, threshMat, 255, Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C, Imgproc.THRESH_BINARY, 11, 2);
        log.info("Pré-processamento da imagem concluído.");
        return matToBufferedImage(threshMat);
    }

    private Mat bufferedImageToMat(BufferedImage bi) {
        BufferedImage bgrImage = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_3BYTE_BGR);
        bgrImage.getGraphics().drawImage(bi, 0, 0, null);
        byte[] data = ((java.awt.image.DataBufferByte) bgrImage.getRaster().getDataBuffer()).getData();
        Mat mat = new Mat(bi.getHeight(), bi.getWidth(), org.opencv.core.CvType.CV_8UC3);
        mat.put(0, 0, data);
        return mat;
    }

    private BufferedImage matToBufferedImage(Mat mat) throws IOException {
        Path tmp = Files.createTempFile(this.runtimeRootDir, "mat-to-img-", ".png");
        Imgcodecs.imwrite(tmp.toString(), mat);
        BufferedImage image = ImageIO.read(tmp.toFile());
        Files.delete(tmp);
        return image;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\ImageCVUtils.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: ImageCVUtils
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service.ocr;

import org.opencv.core.CvType;
import org.opencv.core.Mat;

import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;

/**
 * Utilitários mínimos para converter entre BufferedImage e Mat.
 * Mantém BGR de forma compatível com o OpenCV.
 */
public final class ImageCVUtils {

    private ImageCVUtils() {}

    public static Mat bufferedToMat(BufferedImage bi) {
        // garante formato 3 canais
        BufferedImage img = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_3BYTE_BGR);
        img.getGraphics().drawImage(bi, 0, 0, null);

        byte[] data = ((DataBufferByte) img.getRaster().getDataBuffer()).getData();
        Mat mat = new Mat(img.getHeight(), img.getWidth(), CvType.CV_8UC3);
        mat.put(0, 0, data);
        return mat;
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\OcrSession.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: OcrSession
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// mottu-gradle/src/main/java/br/com/fiap/mottu/service/ocr/OcrSession.java

package br.com.fiap.mottu.service.ocr;

import lombok.Data;

@Data
public class OcrSession {
    public enum Status {
        PENDING, // Aguardando a imagem do celular
        PROCESSING, // Processando a imagem no backend
        COMPLETED, // Placa reconhecida com sucesso
        ERROR // Ocorreu um erro
    }

    private final String id;
    private Status status = Status.PENDING;
    private String recognizedPlate;
    private String errorMessage;
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\OcrSessionManager.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: OcrSessionManager
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// mottu-gradle/src/main/java/br/com/fiap/mottu/service/ocr/OcrSessionManager.java

package br.com.fiap.mottu.service.ocr;

import org.springframework.stereotype.Component;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class OcrSessionManager {
    private final ConcurrentHashMap<String, OcrSession> sessions = new ConcurrentHashMap<>();

    public OcrSession createSession() {
        String sessionId = UUID.randomUUID().toString();
        OcrSession session = new OcrSession(sessionId);
        sessions.put(sessionId, session);
        return session;
    }

    public Optional<OcrSession> getSession(String sessionId) {
        return Optional.ofNullable(sessions.get(sessionId));
    }

    public void updateSessionSuccess(String sessionId, String plate) {
        Optional.ofNullable(sessions.get(sessionId)).ifPresent(session -> {
            session.setStatus(OcrSession.Status.COMPLETED);
            session.setRecognizedPlate(plate);
        });
    }

    public void updateSessionError(String sessionId, String errorMessage) {
        Optional.ofNullable(sessions.get(sessionId)).ifPresent(session -> {
            session.setStatus(OcrSession.Status.ERROR);
            session.setErrorMessage(errorMessage);
        });
    }

    public void setSessionProcessing(String sessionId) {
        Optional.ofNullable(sessions.get(sessionId)).ifPresent(session -> {
            session.setStatus(OcrSession.Status.PROCESSING);
        });
    }

    public void removeSession(String sessionId) {
        sessions.remove(sessionId);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\OpenAlprService.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: OpenAlprService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service.ocr;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

@Service
@Primary
public class OpenAlprService implements PlateRecognizer {

    private static final Logger log = LoggerFactory.getLogger(OpenAlprService.class);
    private final ObjectMapper om = new ObjectMapper();
    private final OcrSessionManager sessionManager;

    public OpenAlprService(OcrSessionManager sessionManager) {
        this.sessionManager = sessionManager;
    }

    @Value("${mottu.ocr.alpr.command:alpr}")
    private String alprCommand;

    @Value("${mottu.ocr.alpr.region:eu}")
    private String region;

    @Value("${mottu.ocr.alpr.topn:10}")
    private int topN;

    @Value("${mottu.ocr.alpr.minConfidence:80}")
    private double minConfidence;

    @Value("${mottu.ocr.alpr.timeoutMs:15000}")
    private long timeoutMs;

    @Value("${mottu.ocr.alpr.debugOutputDir:logs}")
    private String debugOutputDir;

    @Override
    public void extractPlate(String sessionId, byte[] imageBytes) {
        sessionManager.setSessionProcessing(sessionId);
        CompletableFuture.runAsync(() -> runWithFallback(sessionId, imageBytes));
    }

    private void runWithFallback(String sessionId, byte[] imageBytes) {
        File tmp = null;
        try {
            tmp = Files.createTempFile("mottu-plate-", ".jpg").toFile();
            try (FileOutputStream fos = new FileOutputStream(tmp)) {
                fos.write(imageBytes);
            }
            log.info("[OCR:{}] Temp image: {}", sessionId, tmp.getAbsolutePath());

            // 1) tenta com a região configurada
            Result r = runOnce(sessionId, tmp, region);
            if (r.ok() && r.normalizedPlate() != null) {
                sessionManager.updateSessionSuccess(sessionId, r.normalizedPlate());
                return;
            }

            // 2) se foi erro típico de perfil ausente (ex.: br.xml), tenta 'eu'
            if (needsEuFallback(r.stderrOrMixed())) {
                log.warn("[OCR:{}] Região '{}' falhou. Tentando fallback 'eu'…", sessionId, region);
                Result r2 = runOnce(sessionId, tmp, "eu");
                if (r2.ok() && r2.normalizedPlate() != null) {
                    sessionManager.updateSessionSuccess(sessionId, r2.normalizedPlate());
                    return;
                }
                sessionManager.updateSessionError(sessionId, r2.messageForUser());
                return;
            }

            // 3) sem fallback aplicável
            sessionManager.updateSessionError(sessionId, r.messageForUser());

        } catch (Throwable t) {
            log.error("[OCR:{}] Erro no OpenALPR", sessionId, t);
            sessionManager.updateSessionError(sessionId, "Erro interno no reconhecimento.");
        } finally {
            if (tmp != null) try { Files.deleteIfExists(tmp.toPath()); } catch (IOException ignored) {}
        }
    }

    private Result runOnce(String sessionId, File imageFile, String cfgRegion) {
        try {
            List<String> cmd = new ArrayList<>();
            cmd.add(alprCommand);
            cmd.add("-j");
            cmd.add("-c"); cmd.add(cfgRegion);
            cmd.add("-n"); cmd.add(String.valueOf(topN));
            cmd.add(imageFile.getAbsolutePath());

            log.info("[OCR:{}] Executando ({}): {}", sessionId, cfgRegion, String.join(" ", cmd));

            ProcessBuilder pb = new ProcessBuilder(cmd);
            pb.redirectErrorStream(true);
            Process p = pb.start();

            boolean finished = p.waitFor(timeoutMs, TimeUnit.MILLISECONDS);
            if (!finished) {
                p.destroyForcibly();
                return Result.error("Timeout executando o OpenALPR (" + cfgRegion + ").", null);
            }

            String mixedOut = readAll(p.getInputStream());
            int exit = p.exitValue();

            // dump debug
            dumpJsonDebug(mixedOut, cfgRegion);

            if (exit != 0) {
                return Result.error("OpenALPR retornou código " + exit + " (" + cfgRegion + ").", mixedOut);
            }

            // corta somente o JSON (ignora ruídos antes/depois)
            String json = extractJson(mixedOut);
            if (json == null) {
                return Result.error("Saída inválida do OpenALPR (" + cfgRegion + ").", mixedOut);
            }

            Optional<String> best = pickBest(json);
            if (best.isEmpty()) {
                return Result.error("Nenhuma placa encontrada (" + cfgRegion + ").", json);
            }

            String normalized = PlateUtils.normalizeMercosul(best.get());
            if (normalized == null || normalized.isBlank()) {
                return Result.error("Falha ao normalizar a placa.", json);
            }

            return Result.success(normalized, mixedOut);

        } catch (IOException | InterruptedException e) {
            return Result.error("Falha ao executar o OpenALPR (" + cfgRegion + ").", e.toString());
        }
    }

    /** detecta mensagens clássicas de perfil ausente/ruído do opencv */
    private boolean needsEuFallback(String mixed) {
        if (mixed == null) return false;
        String s = mixed.toLowerCase();
        return s.contains("cpu classifier") || s.contains("error loading")
                || s.contains("missing config for the country") || s.contains("br.xml");
    }

    /** extrai apenas o JSON (do primeiro '{' ao último '}') */
    private String extractJson(String mixed) {
        if (mixed == null) return null;
        int start = mixed.indexOf('{');
        int end = mixed.lastIndexOf('}');
        if (start < 0 || end < 0 || end <= start) return null;
        return mixed.substring(start, end + 1);
    }

    private Optional<String> pickBest(String json) {
        try {
            JsonNode root = om.readTree(json);
            JsonNode results = root.get("results");
            if (results == null || !results.isArray() || results.isEmpty()) return Optional.empty();

            double bestScore = -1.0;
            String bestPlate = null;

            for (JsonNode r : results) {
                if (r.hasNonNull("plate") && r.hasNonNull("confidence")) {
                    String p = r.get("plate").asText("");
                    double c = r.get("confidence").asDouble(0.0);
                    if (c >= minConfidence && c > bestScore) { bestScore = c; bestPlate = p; }
                }
                JsonNode cs = r.get("candidates");
                if (cs != null && cs.isArray()) {
                    for (JsonNode cand : cs) {
                        String p = cand.hasNonNull("plate") ? cand.get("plate").asText("") : "";
                        double c = cand.hasNonNull("confidence") ? cand.get("confidence").asDouble(0.0) : 0.0;
                        boolean matches = cand.hasNonNull("matches_template") && cand.get("matches_template").asInt(0) == 1;
                        double score = c + (matches ? 2.0 : 0.0);
                        if (c >= minConfidence && score > bestScore) { bestScore = score; bestPlate = p; }
                    }
                }
            }
            return Optional.ofNullable(bestPlate);
        } catch (IOException e) {
            log.warn("Falha ao parsear JSON do OpenALPR", e);
            return Optional.empty();
        }
    }

    private void dumpJsonDebug(String mixedOut, String cfgRegion) {
        try {
            Path dir = Path.of(debugOutputDir);
            Files.createDirectories(dir);
            Files.writeString(dir.resolve("ultima-saida-alpr-cfg-" + cfgRegion + ".json"), mixedOut);
            String ts = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss"));
            Files.writeString(dir.resolve("saida-" + cfgRegion + "-" + ts + ".json"), mixedOut);
        } catch (IOException e) {
            log.debug("Não foi possível salvar JSON de debug: {}", e.toString());
        }
    }

    private static String readAll(InputStream in) throws IOException {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(in))) {
            StringBuilder sb = new StringBuilder();
            String s;
            while ((s = br.readLine()) != null) sb.append(s).append('\n');
            return sb.toString();
        }
    }

    // ---------------- Result helper ----------------
    /** record privado; accessors públicos gerados automaticamente (ok(), normalizedPlate(), stderrOrMixed(), userMsg()) */
    private record Result(boolean ok, String normalizedPlate, String stderrOrMixed, String userMsg) {
        static Result success(String plate, String mixed) { return new Result(true, plate, mixed, null); }
        static Result error(String msg, String mixed)    { return new Result(false, null, mixed, msg); }
        String messageForUser() { return userMsg != null ? userMsg : "Falha no reconhecimento."; }
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\PlateRecognizer.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: PlateRecognizer
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service.ocr;

/**
 * Contrato simples para reconhecedores de placa.
 * Implementações devem:
 *  - Marcar a sessão como PROCESSING ao iniciar
 *  - Atualizar a sessão com COMPLETED + plate OU ERROR + mensagem
 *  - Executar o processamento de forma assíncrona (não bloquear o controller)
 */
public interface PlateRecognizer {

    /**
     * Dispara o reconhecimento da placa para a sessão informada.
     * A implementação deve retornar imediatamente e processar em background.
     *
     * @param sessionId  ID da sessão (gerenciado por OcrSessionManager)
     * @param imageBytes bytes da imagem enviada (JPEG/PNG, etc.)
     */
    void extractPlate(String sessionId, byte[] imageBytes);
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\PlateUtils.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: PlateUtils
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service.ocr;

import java.text.Normalizer;
import java.util.Collection;
import java.util.Comparator;
import java.util.Objects;

/**
 * Utilitários para limpeza, normalização (padrão Mercosul) e "fuzzy match" de placas.
 * Mantido no pacote service.ocr, seguindo o padrão do projeto.
 */
public final class PlateUtils {

    private PlateUtils() {}

    /** Remove acentos, espaços, traços e qualquer caractere não [A-Za-z0-9], e coloca em UPPERCASE. */
    public static String cleanRaw(String s) {
        if (s == null) return "";
        String nfd = Normalizer.normalize(s, Normalizer.Form.NFD);
        String noMarks = nfd.replaceAll("\\p{M}", "");
        return noMarks.replaceAll("[^A-Za-z0-9]", "").toUpperCase();
    }

    /**
     * Normaliza para o formato Mercosul (LLLNLNN – 7 chars).
     * Faz mapeamento heurístico letra↔número por posição para corrigir confusões comuns do OCR.
     */
    public static String normalizeMercosul(String raw) {
        String s = cleanRaw(raw);
        if (s.length() < 7) return s; // retorna o que tiver; o chamador decide se aceita

        char[] a = s.toCharArray();
        // Posições: 0..2 (letras), 3 (número), 4 (letra), 5..6 (números)
        fixAsLetter(a, 0);
        fixAsLetter(a, 1);
        fixAsLetter(a, 2);
        fixAsDigit(a, 3);
        fixAsLetter(a, 4);
        fixAsDigit(a, 5);
        fixAsDigit(a, 6);

        String out = new String(a);
        return out.substring(0, 7);
    }

    private static void fixAsLetter(char[] a, int i) {
        if (i >= a.length) return;
        char c = a[i];
        // Se veio dígito parecido com letra, converte
        switch (c) {
            case '0': a[i] = 'O'; break;
            case '1': a[i] = 'I'; break; // ou 'L', preferimos I
            case '2': a[i] = 'Z'; break;
            case '5': a[i] = 'S'; break;
            case '6': a[i] = 'G'; break;
            case '8': a[i] = 'B'; break;
            case '4': a[i] = 'A'; break;
            case '7': a[i] = 'T'; break;
            default: a[i] = Character.toUpperCase(c);
        }
    }

    private static void fixAsDigit(char[] a, int i) {
        if (i >= a.length) return;
        char c = Character.toUpperCase(a[i]);
        switch (c) {
            case 'O': case 'Q': case 'D': a[i] = '0'; break;
            case 'I': case 'L': a[i] = '1'; break;
            case 'Z': a[i] = '2'; break;
            case 'S': a[i] = '5'; break;
            case 'B': a[i] = '8'; break;
            case 'G': a[i] = '6'; break;
            case 'A': a[i] = '4'; break; // menos comum, mas ajuda
            case 'T': a[i] = '7'; break;
            default: a[i] = c;
        }
        if (!Character.isDigit(a[i])) {
            // fallback: se ainda ficou letra, força para 0
            a[i] = '0';
        }
    }

    /** Distância de Levenshtein iterativa. */
    public static int levenshtein(String a, String b) {
        if (Objects.equals(a, b)) return 0;
        if (a == null || a.isEmpty()) return b == null ? 0 : b.length();
        if (b == null || b.isEmpty()) return a.length();

        int[] prev = new int[b.length() + 1];
        int[] curr = new int[b.length() + 1];

        for (int j = 0; j <= b.length(); j++) prev[j] = j;

        for (int i = 1; i <= a.length(); i++) {
            curr[0] = i;
            char ca = a.charAt(i - 1);
            for (int j = 1; j <= b.length(); j++) {
                int cost = (ca == b.charAt(j - 1)) ? 0 : 1;
                curr[j] = Math.min(
                        Math.min(curr[j - 1] + 1, prev[j] + 1),
                        prev[j - 1] + cost
                );
            }
            int[] tmp = prev; prev = curr; curr = tmp;
        }
        return prev[b.length()];
    }

    /**
     * Retorna o melhor match (menor distância) até maxDistance ou null.
     * A coleção pode ser a lista de placas do repositório já normalizadas.
     */
    public static String bestCandidate(Collection<String> knownPlates, String candidate, int maxDistance) {
        if (candidate == null) return null;
        return knownPlates.stream()
                .min(Comparator.comparingInt(p -> levenshtein(p, candidate)))
                .filter(best -> levenshtein(best, candidate) <= maxDistance)
                .orElse(null);
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\ocr\TesseractService.java   |   PACOTE: br.com.fiap.mottu.service.ocr   |   CLASSE: TesseractService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service.ocr;

import br.com.fiap.mottu.exception.InvalidInputException;
import jakarta.annotation.PostConstruct;
import net.sourceforge.tess4j.ITesseract;
import net.sourceforge.tess4j.Tesseract;
import net.sourceforge.tess4j.TesseractException;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.*;
import java.util.List;

@Service
public class TesseractService {

    private static final Logger log = LoggerFactory.getLogger(TesseractService.class);

    // --- DECLARAÇÃO DAS VARIÁVEIS DE CLASSE (ESTA PARTE ESTAVA FALTANDO) ---
    @Value("${mottu.ocr.lang:por+eng}")
    private String configuredLang;

    @Value("${mottu.ocr.tessdata-path:}")
    private String configuredTessdataPath;

    private File tessdataDirResolved;
    private final OcrSessionManager sessionManager;
    private final Path runtimeRootDir; // <-- A VARIÁVEL QUE FALTAVA
    private final Path runtimeTessdataDir;
    // --- FIM DAS DECLARAÇÕES ---

    public TesseractService(OcrSessionManager sessionManager) {
        this.sessionManager = sessionManager;
        ImageIO.setUseCache(false);

        try {
            // Inicialização das variáveis
            this.runtimeRootDir = Files.createTempDirectory("mottu-ocr-" + Instant.now().toEpochMilli());
            this.runtimeTessdataDir = Files.createDirectories(this.runtimeRootDir.resolve("tessdata"));
            copyTessdataFromClasspath();
            log.info("TesseractService inicializado. Diretório de trabalho: {}", runtimeRootDir);
        } catch (IOException e) {
            throw new UncheckedIOException("Falha crítica ao preparar diretório de trabalho do OCR", e);
        }
    }

    @PostConstruct
    public void init() {
        resolveTessdataPath();
        log.info("Idiomas de OCR configurados='{}'", configuredLang);
    }

    private void resolveTessdataPath() {
        List<String> triedPaths = new ArrayList<>();
        if (configuredTessdataPath != null && !configuredTessdataPath.isBlank()) {
            File f = new File(configuredTessdataPath);
            triedPaths.add("propriedade 'mottu.ocr.tessdata-path': " + f.getAbsolutePath());
            if (f.isDirectory()) {
                tessdataDirResolved = f;
            }
        }
        if (tessdataDirResolved == null) {
            String envPath = System.getenv("TESSDATA_PREFIX");
            if (envPath != null && !envPath.isBlank()) {
                File f = new File(envPath);
                triedPaths.add("variável de ambiente 'TESSDATA_PREFIX': " + f.getAbsolutePath());
                if (f.isDirectory()) {
                    tessdataDirResolved = f;
                }
            }
        }
        if (tessdataDirResolved == null) {
            tessdataDirResolved = this.runtimeTessdataDir.toFile();
            triedPaths.add("extração do classpath para: " + tessdataDirResolved.getAbsolutePath());
        }

        if (tessdataDirResolved != null && tessdataDirResolved.listFiles((dir, name) -> name.endsWith(".traineddata")).length > 0) {
            log.info("✅ Tesseract 'tessdata' localizado com sucesso em: {}", tessdataDirResolved.getAbsolutePath());
        } else {
            log.error("❌ FALHA CRÍTICA: Não foi possível resolver a pasta 'tessdata'. Tentativas: {}", triedPaths);
        }
    }

    private void copyTessdataFromClasspath() throws IOException {
        String[] entries = {"eng.traineddata", "por.traineddata", "osd.traineddata"};
        for (String entry : entries) {
            String resourcePath = "/tessdata/" + entry;
            try (InputStream in = getClass().getResourceAsStream(resourcePath)) {
                if (in == null) {
                    log.warn("Recurso de OCR não encontrado no classpath: {}", resourcePath);
                    continue;
                }
                Files.copy(in, this.runtimeTessdataDir.resolve(entry));
                log.info("Recurso de OCR copiado: {}", entry);
            }
        }
    }

    public void extractPlate(String sessionId, byte[] imageBytes) {
        sessionManager.setSessionProcessing(sessionId);
        try {
            if (imageBytes == null || imageBytes.length == 0) {
                throw new InvalidInputException("Arquivo de imagem está vazio ou corrompido.");
            }
            BufferedImage sourceImage = readImageStrict(imageBytes);
            BufferedImage processedImage = preprocessImageForOcr(sourceImage);
            Path pngTempFile = writePngTemp(processedImage);
            String ocrResult = runTesseractOcr(pngTempFile);
            String normalizedPlate = PlateUtils.normalizeMercosul(ocrResult);

            if (normalizedPlate == null || normalizedPlate.length() < 7) {
                throw new InvalidInputException("Não foi possível reconhecer uma placa válida na imagem.");
            }
            log.info("Sessão {}: Placa reconhecida e normalizada: {}", sessionId, normalizedPlate);
            sessionManager.updateSessionSuccess(sessionId, normalizedPlate);
        } catch (Throwable ex) {
            log.error("Sessão {}: Falha no processo de OCR: {}", sessionId, ex.getMessage(), ex);
            String errorMessage = (ex instanceof InvalidInputException) ? ex.getMessage() : "Erro interno ao processar a imagem.";
            sessionManager.updateSessionError(sessionId, errorMessage);
        }
    }

    private String runTesseractOcr(Path imageFile) throws TesseractException {
        if (tessdataDirResolved == null || !tessdataDirResolved.isDirectory()) {
            throw new TesseractException("Diretório 'tessdata' não foi inicializado.");
        }
        ITesseract tesseract = new Tesseract();
        tesseract.setDatapath(tessdataDirResolved.getParentFile().getAbsolutePath());
        String langToUse = chooseLanguage(configuredLang);
        tesseract.setLanguage(langToUse);
        tesseract.setTessVariable("user_defined_dpi", "300");
        long startTime = System.currentTimeMillis();
        String result = tesseract.doOCR(imageFile.toFile());
        long duration = System.currentTimeMillis() - startTime;
        log.info("Tess4J executado em {} ms com o idioma '{}'", duration, langToUse);
        return result != null ? result.trim() : "";
    }

    private String chooseLanguage(String requested) {
        Set<String> availableLangs = listAvailableLanguages();
        if (availableLangs.isEmpty()) {
            log.error("Nenhum arquivo .traineddata encontrado em {}", tessdataDirResolved);
            return "eng";
        }
        List<String> langsToUse = new ArrayList<>();
        for (String lang : requested.split("\\+")) {
            if (availableLangs.contains(lang.trim())) {
                langsToUse.add(lang.trim());
            }
        }
        if (langsToUse.isEmpty()) {
            if (availableLangs.contains("eng")) {
                log.warn("Idiomas requisitados '{}' não encontrados. Usando fallback 'eng'.", requested);
                return "eng";
            } else {
                String fallback = availableLangs.iterator().next();
                log.warn("Idiomas requisitados '{}' e 'eng' não encontrados. Usando fallback: '{}'", requested, fallback);
                return fallback;
            }
        }
        return String.join("+", langsToUse);
    }

    private Set<String> listAvailableLanguages() {
        Set<String> languages = new HashSet<>();
        if (tessdataDirResolved == null || !tessdataDirResolved.isDirectory()) return languages;
        File[] files = tessdataDirResolved.listFiles((dir, name) -> name.toLowerCase().endsWith(".traineddata"));
        if (files != null) {
            for (File f : files) {
                languages.add(f.getName().replace(".traineddata", ""));
            }
        }
        return languages;
    }

    private BufferedImage readImageStrict(byte[] bytes) throws IOException {
        try (ImageInputStream iis = ImageIO.createImageInputStream(new ByteArrayInputStream(bytes))) {
            if (iis == null) throw new IOException("Não foi possível criar ImageInputStream.");
            Iterator<ImageReader> readers = ImageIO.getImageReaders(iis);
            if (!readers.hasNext()) throw new IOException("Formato de imagem não suportado.");
            ImageReader reader = readers.next();
            try {
                reader.setInput(iis, true, true);
                BufferedImage img = reader.read(0);
                if (img == null) throw new IOException("Falha ao decodificar a imagem.");
                return ensureBufferedRgb(img);
            } finally {
                reader.dispose();
            }
        }
    }

    private BufferedImage ensureBufferedRgb(BufferedImage img) {
        if (img.getType() == BufferedImage.TYPE_INT_RGB) return img;
        BufferedImage copy = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_INT_RGB);
        Graphics2D g = copy.createGraphics();
        try { g.drawImage(img, 0, 0, null); } finally { g.dispose(); }
        return copy;
    }

    private Path writePngTemp(BufferedImage img) throws IOException {
        Path tmp = Files.createTempFile(this.runtimeRootDir, "ocr-processed-", ".png");
        ImageIO.write(img, "png", tmp.toFile());
        return tmp;
    }

    private BufferedImage preprocessImageForOcr(BufferedImage image) throws IOException {
        Mat mat = bufferedImageToMat(image);
        Mat grayMat = new Mat();
        Imgproc.cvtColor(mat, grayMat, Imgproc.COLOR_BGR2GRAY);
        Mat blurredMat = new Mat();
        Imgproc.GaussianBlur(grayMat, blurredMat, new Size(3, 3), 0);
        Mat threshMat = new Mat();
        Imgproc.adaptiveThreshold(blurredMat, threshMat, 255, Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C, Imgproc.THRESH_BINARY, 11, 2);
        log.info("Pré-processamento da imagem concluído.");
        return matToBufferedImage(threshMat);
    }

    private Mat bufferedImageToMat(BufferedImage bi) {
        BufferedImage bgrImage = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_3BYTE_BGR);
        bgrImage.getGraphics().drawImage(bi, 0, 0, null);
        byte[] data = ((java.awt.image.DataBufferByte) bgrImage.getRaster().getDataBuffer()).getData();
        Mat mat = new Mat(bi.getHeight(), bi.getWidth(), org.opencv.core.CvType.CV_8UC3);
        mat.put(0, 0, data);
        return mat;
    }

    private BufferedImage matToBufferedImage(Mat mat) throws IOException {
        Path tmp = Files.createTempFile(this.runtimeRootDir, "mat-to-img-", ".png");
        Imgcodecs.imwrite(tmp.toString(), mat);
        BufferedImage image = ImageIO.read(tmp.toFile());
        Files.delete(tmp);
        return image;
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.service.vaga
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\service\VagaOracleService.java   |   PACOTE: br.com.fiap.mottu.service.vaga   |   CLASSE: VagaOracleService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service.vaga;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.util.*;

@Service
public class VagaOracleService {

    private final JdbcTemplate jdbc;

    public VagaOracleService(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }

    @Transactional(readOnly = true)
    public List<BoxRow> listarBoxesComPlaca() {
        String sql = """
            SELECT b.ID_BOX, b.NOME, b.STATUS, b.DATA_ENTRADA, b.DATA_SAIDA, b.OBSERVACAO,
                   v.PLACA
              FROM TB_BOX b
              LEFT JOIN TB_VEICULOBOX vb ON vb.TB_BOX_ID_BOX = b.ID_BOX
              LEFT JOIN TB_VEICULO v ON v.ID_VEICULO = vb.TB_VEICULO_ID_VEICULO
              ORDER BY b.ID_BOX
            """;
        return jdbc.query(sql, (rs, i) -> new BoxRow(
                rs.getLong("ID_BOX"),
                rs.getString("NOME"),
                rs.getString("STATUS"),
                rs.getDate("DATA_ENTRADA") == null ? null : rs.getDate("DATA_ENTRADA").toLocalDate(),
                rs.getDate("DATA_SAIDA") == null ? null : rs.getDate("DATA_SAIDA").toLocalDate(),
                rs.getString("OBSERVACAO"),
                rs.getString("PLACA")
        ));
    }

    @Transactional(readOnly = true)
    public Optional<Long> findVeiculoIdByPlaca(String placa) {
        String sql = "SELECT ID_VEICULO FROM TB_VEICULO WHERE UPPER(PLACA) = ?";
        List<Long> ids = jdbc.query(sql, ps -> ps.setString(1, placa.toUpperCase()),
                (rs, i) -> rs.getLong("ID_VEICULO"));
        return ids.isEmpty() ? Optional.empty() : Optional.of(ids.getFirst());
    }

    @Transactional
    public Long createVeiculoComPlaca(String placa) {
        String sql = "INSERT INTO TB_VEICULO (PLACA) VALUES (?)";
        KeyHolder kh = new GeneratedKeyHolder();
        jdbc.update(con -> {
            PreparedStatement ps = con.prepareStatement(sql, new String[]{"ID_VEICULO"});
            ps.setString(1, placa.toUpperCase());
            return ps;
        }, kh);
        Number key = kh.getKey();
        if (key == null) {
            throw new IllegalStateException("Não foi possível obter ID do veículo criado.");
        }
        return key.longValue();
    }

    @Transactional(readOnly = true)
    public Optional<Long> firstBoxLivreId() {
        String sql = """
            SELECT b.ID_BOX
              FROM TB_BOX b
              LEFT JOIN TB_VEICULOBOX vb ON vb.TB_BOX_ID_BOX = b.ID_BOX
             WHERE b.STATUS = 'L'
               AND vb.TB_BOX_ID_BOX IS NULL
             ORDER BY b.ID_BOX
            """;
        List<Long> ids = jdbc.query(sql, (rs, i) -> rs.getLong(1));
        return ids.isEmpty() ? Optional.empty() : Optional.of(ids.getFirst());
    }

    @Transactional
    public void ocuparBox(Long boxId) {
        jdbc.update("UPDATE TB_BOX SET STATUS = 'O', DATA_ENTRADA = SYSDATE, DATA_SAIDA = NULL WHERE ID_BOX = ?", boxId);
    }

    @Transactional
    public void vincularVeiculoBox(Long veiculoId, Long boxId) {
        jdbc.update("INSERT INTO TB_VEICULOBOX (TB_VEICULO_ID_VEICULO, TB_BOX_ID_BOX) VALUES (?, ?)", veiculoId, boxId);
    }

    @Transactional
    public void liberarBox(Long boxId) {
        jdbc.update("DELETE FROM TB_VEICULOBOX WHERE TB_BOX_ID_BOX = ?", boxId);
        jdbc.update("UPDATE TB_BOX SET STATUS = 'L', DATA_SAIDA = SYSDATE WHERE ID_BOX = ?", boxId);
    }

    @Transactional
    public AlocacaoResult alocarPlaca(String placa, Long preferidoBoxId) {
        String p = placa == null ? "" : placa.trim().toUpperCase();
        if (p.isEmpty()) throw new IllegalArgumentException("Placa é obrigatória.");

        Long veiculoId = findVeiculoIdByPlaca(p).orElseGet(() -> createVeiculoComPlaca(p));

        // já alocada?
        Optional<BuscaBox> ja = buscarBoxPorPlaca(p);
        if (ja.isPresent()) {
            throw new IllegalStateException("Placa já alocada no box " + ja.get().idBox() + " (" + ja.get().nomeBox() + ")");
        }

        Long boxId = (preferidoBoxId != null) ? preferidoBoxId
                : firstBoxLivreId().orElseThrow(() -> new IllegalStateException("Não há boxes livres."));

        int ocupados = jdbc.queryForObject(
                "SELECT COUNT(1) FROM TB_VEICULOBOX WHERE TB_BOX_ID_BOX = ?",
                Integer.class, boxId
        );
        if (ocupados > 0) throw new IllegalStateException("Box já ocupado: " + boxId);

        ocuparBox(boxId);
        vincularVeiculoBox(veiculoId, boxId);

        return new AlocacaoResult(veiculoId, boxId, p);
    }

    /** NOVO: retorna o box atual da placa, se houver (id e nome do box). */
    @Transactional(readOnly = true)
    public Optional<BuscaBox> buscarBoxPorPlaca(String placa) {
        String sql = """
            SELECT b.ID_BOX, b.NOME, b.STATUS
              FROM TB_VEICULO v
              JOIN TB_VEICULOBOX vb ON vb.TB_VEICULO_ID_VEICULO = v.ID_VEICULO
              JOIN TB_BOX b        ON b.ID_BOX = vb.TB_BOX_ID_BOX
             WHERE UPPER(v.PLACA) = ?
            """;
        List<BuscaBox> list = jdbc.query(sql,
                ps -> ps.setString(1, placa.toUpperCase()),
                (rs, i) -> new BuscaBox(rs.getLong("ID_BOX"), rs.getString("NOME"), rs.getString("STATUS")));
        return list.isEmpty() ? Optional.empty() : Optional.of(list.getFirst());
    }

    // ---------- tipos auxiliares ----------
    public record BoxRow(Long idBox, String nome, String status,
                         java.time.LocalDate dataEntrada, java.time.LocalDate dataSaida,
                         String observacao, String placa) {}

    public record AlocacaoResult(Long veiculoId, Long boxId, String placa) {}

    public record BuscaBox(Long idBox, String nomeBox, String status) {}
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.specification
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\specification\BoxSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: BoxSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\BoxSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.BoxFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Box;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class BoxSpecification {

    public static Specification<Box> withFilters(BoxFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.status() != null && !filter.status().isBlank()) {
                predicates.add(cb.equal(root.get("status"), filter.status()));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\specification\ClienteSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: ClienteSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\ClienteSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ClienteFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ClienteSpecification {

    public static Specification<Cliente> withFilters(ClienteFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.sobrenome() != null && !filter.sobrenome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("sobrenome")), "%" + filter.sobrenome().toLowerCase() + "%"));
            }
            if (filter.cpf() != null && !filter.cpf().isBlank()) {
                predicates.add(cb.equal(root.get("cpf"), filter.cpf()));
            }
            if (filter.sexo() != null && !filter.sexo().isBlank()) {
                predicates.add(cb.equal(root.get("sexo"), filter.sexo()));
            }
            if (filter.profissao() != null && !filter.profissao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("profissao")), "%" + filter.profissao().toLowerCase() + "%"));
            }
            if (filter.estadoCivil() != null && !filter.estadoCivil().isBlank()) {
                predicates.add(cb.equal(root.get("estadoCivil"), filter.estadoCivil()));
            }
            if (filter.dataCadastroInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataCadastro"), filter.dataCadastroInicio()));
            }
            if (filter.dataCadastroFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataCadastro"), filter.dataCadastroFim()));
            }
            if (filter.dataNascimentoInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataNascimento"), filter.dataNascimentoInicio()));
            }
            if (filter.dataNascimentoFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataNascimento"), filter.dataNascimentoFim()));
            }

            // Filtro por relacionamento ManyToOne (Endereco)
            if (filter.enderecoCidade() != null && !filter.enderecoCidade().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("endereco").get("cidade")), "%" + filter.enderecoCidade().toLowerCase() + "%"));
            }
            if (filter.enderecoEstado() != null && !filter.enderecoEstado().isBlank()) {
                predicates.add(cb.equal(root.get("endereco").get("estado"), filter.enderecoEstado()));
            }

            // Filtro por relacionamento ManyToOne (Contato)
            if (filter.contatoEmail() != null && !filter.contatoEmail().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("contato").get("email")), "%" + filter.contatoEmail().toLowerCase() + "%"));
            }
            if (filter.contatoCelular() != null && !filter.contatoCelular().isBlank()) {
                predicates.add(cb.like(root.get("contato").get("celular"), "%" + filter.contatoCelular() + "%"));
            }

            // Filtro por relacionamento OneToMany (ClienteVeiculo) para propriedade de Veiculo
            // Isso envolve fazer um JOIN com a tabela de junção e depois com a entidade Veiculo
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Cliente, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.equal(clienteVeiculoJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }
            if (filter.veiculoModelo() != null && !filter.veiculoModelo().isBlank()) {
                Join<Cliente, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.like(cb.lower(clienteVeiculoJoin.get("veiculo").get("modelo")), "%" + filter.veiculoModelo().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados ao usar joins para coleções

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\specification\ContatoSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: ContatoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\ContatoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ContatoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Contato;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Join;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ContatoSpecification {

    public static Specification<Contato> withFilters(ContatoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.email() != null && !filter.email().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("email")), "%" + filter.email().toLowerCase() + "%"));
            }
            if (filter.ddd() != null) {
                predicates.add(cb.equal(root.get("ddd"), filter.ddd()));
            }
            if (filter.ddi() != null) {
                predicates.add(cb.equal(root.get("ddi"), filter.ddi()));
            }
            if (filter.telefone1() != null && !filter.telefone1().isBlank()) {
                predicates.add(cb.like(root.get("telefone1"), "%" + filter.telefone1() + "%"));
            }
            if (filter.celular() != null && !filter.celular().isBlank()) {
                predicates.add(cb.like(root.get("celular"), "%" + filter.celular() + "%"));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento OneToMany (Cliente)
            if (filter.clienteNome() != null && !filter.clienteNome().isBlank()) {
                Join<Contato, br.com.fiap.mottu.model.Cliente> clienteJoin = root.join("clienteContatos"); // Mapeia para o nome da coleção em Contato
                predicates.add(cb.like(cb.lower(clienteJoin.get("nome")), "%" + filter.clienteNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\specification\EnderecoSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: EnderecoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\EnderecoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.EnderecoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Endereco;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Join;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class EnderecoSpecification {

    public static Specification<Endereco> withFilters(EnderecoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.cep() != null && !filter.cep().isBlank()) {
                predicates.add(cb.equal(root.get("cep"), filter.cep()));
            }
            if (filter.numero() != null) {
                predicates.add(cb.equal(root.get("numero"), filter.numero()));
            }
            if (filter.logradouro() != null && !filter.logradouro().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("logradouro")), "%" + filter.logradouro().toLowerCase() + "%"));
            }
            if (filter.bairro() != null && !filter.bairro().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("bairro")), "%" + filter.bairro().toLowerCase() + "%"));
            }
            if (filter.cidade() != null && !filter.cidade().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("cidade")), "%" + filter.cidade().toLowerCase() + "%"));
            }
            if (filter.estado() != null && !filter.estado().isBlank()) {
                predicates.add(cb.equal(root.get("estado"), filter.estado()));
            }
            if (filter.pais() != null && !filter.pais().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("pais")), "%" + filter.pais().toLowerCase() + "%"));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento OneToMany (Cliente)
            if (filter.clienteNome() != null && !filter.clienteNome().isBlank()) {
                Join<Endereco, br.com.fiap.mottu.model.Cliente> clienteJoin = root.join("clienteEnderecos"); // Mapeia para o nome da coleção em Endereco
                predicates.add(cb.like(cb.lower(clienteJoin.get("nome")), "%" + filter.clienteNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\specification\PatioSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: PatioSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\PatioSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.PatioFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio; // Exemplo de junção
import br.com.fiap.mottu.model.relacionamento.EnderecoPatio; // Exemplo de junção
import br.com.fiap.mottu.model.relacionamento.ContatoPatio; // Exemplo de junção
import br.com.fiap.mottu.model.relacionamento.ZonaPatio; // Exemplo de junção
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class PatioSpecification {

    public static Specification<Patio> withFilters(PatioFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nomePatio() != null && !filter.nomePatio().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nomePatio")), "%" + filter.nomePatio().toLowerCase() + "%"));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoPatio)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Patio, VeiculoPatio> veiculoPatioJoin = root.join("veiculoPatios");
                predicates.add(cb.equal(veiculoPatioJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            // Filtro por relacionamento ManyToMany (EnderecoPatio)
            if (filter.enderecoCidade() != null && !filter.enderecoCidade().isBlank()) {
                Join<Patio, EnderecoPatio> enderecoPatioJoin = root.join("enderecoPatios");
                predicates.add(cb.like(cb.lower(enderecoPatioJoin.get("endereco").get("cidade")), "%" + filter.enderecoCidade().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ContatoPatio)
            if (filter.contatoEmail() != null && !filter.contatoEmail().isBlank()) {
                Join<Patio, ContatoPatio> contatoPatioJoin = root.join("contatoPatios");
                predicates.add(cb.like(cb.lower(contatoPatioJoin.get("contato").get("email")), "%" + filter.contatoEmail().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ZonaPatio)
            if (filter.zonaNome() != null && !filter.zonaNome().isBlank()) {
                Join<Patio, ZonaPatio> zonaPatioJoin = root.join("zonaPatios");
                predicates.add(cb.like(cb.lower(zonaPatioJoin.get("zona").get("nome")), "%" + filter.zonaNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\specification\RastreamentoSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: RastreamentoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;
import java.math.BigDecimal; // Importe BigDecimal!

public class RastreamentoSpecification {

    public static Specification<Rastreamento> withFilters(RastreamentoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            // Filtros para IPS
            if (filter.ipsX() != null) {
                predicates.add(cb.equal(root.get("ipsX"), filter.ipsX()));
            }
            if (filter.ipsY() != null) {
                predicates.add(cb.equal(root.get("ipsY"), filter.ipsY()));
            }
            if (filter.ipsZ() != null) {
                predicates.add(cb.equal(root.get("ipsZ"), filter.ipsZ()));
            }

            // Filtros para GPRS
            if (filter.gprsLatitude() != null) {
                predicates.add(cb.equal(root.get("gprsLatitude"), filter.gprsLatitude()));
            }
            if (filter.gprsLongitude() != null) {
                predicates.add(cb.equal(root.get("gprsLongitude"), filter.gprsLongitude()));
            }
            if (filter.gprsAltitude() != null) {
                predicates.add(cb.equal(root.get("gprsAltitude"), filter.gprsAltitude()));
            }

            // Filtro por relacionamento ManyToMany (VeiculoRastreamento)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Rastreamento, VeiculoRastreamento> veiculoRastreamentoJoin = root.join("veiculoRastreamentos");
                predicates.add(cb.equal(veiculoRastreamentoJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\specification\VeiculoSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: VeiculoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\VeiculoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.VeiculoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class VeiculoSpecification {

    public static Specification<Veiculo> withFilters(VeiculoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.placa() != null && !filter.placa().isBlank()) {
                predicates.add(cb.equal(root.get("placa"), filter.placa()));
            }
            if (filter.renavam() != null && !filter.renavam().isBlank()) {
                predicates.add(cb.equal(root.get("renavam"), filter.renavam()));
            }
            if (filter.chassi() != null && !filter.chassi().isBlank()) {
                predicates.add(cb.equal(root.get("chassi"), filter.chassi()));
            }
            if (filter.fabricante() != null && !filter.fabricante().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("fabricante")), "%" + filter.fabricante().toLowerCase() + "%"));
            }
            if (filter.modelo() != null && !filter.modelo().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("modelo")), "%" + filter.modelo().toLowerCase() + "%"));
            }
            if (filter.motor() != null && !filter.motor().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("motor")), "%" + filter.motor().toLowerCase() + "%"));
            }
            if (filter.ano() != null) {
                predicates.add(cb.equal(root.get("ano"), filter.ano()));
            }
            if (filter.combustivel() != null && !filter.combustivel().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("combustivel")), "%" + filter.combustivel().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ClienteVeiculo)
            if (filter.clienteCpf() != null && !filter.clienteCpf().isBlank()) {
                Join<Veiculo, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.equal(clienteVeiculoJoin.get("cliente").get("cpf"), filter.clienteCpf()));
            }

            // Filtro por relacionamento ManyToMany (VeiculoBox)
            if (filter.boxNome() != null && !filter.boxNome().isBlank()) {
                Join<Veiculo, VeiculoBox> veiculoBoxJoin = root.join("veiculoBoxes");
                predicates.add(cb.like(cb.lower(veiculoBoxJoin.get("box").get("nome")), "%" + filter.boxNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoPatio)
            if (filter.patioNome() != null && !filter.patioNome().isBlank()) {
                Join<Veiculo, VeiculoPatio> veiculoPatioJoin = root.join("veiculoPatios");
                predicates.add(cb.like(cb.lower(veiculoPatioJoin.get("patio").get("nomePatio")), "%" + filter.patioNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoZona)
            if (filter.zonaNome() != null && !filter.zonaNome().isBlank()) {
                Join<Veiculo, VeiculoZona> veiculoZonaJoin = root.join("veiculoZonas");
                predicates.add(cb.like(cb.lower(veiculoZonaJoin.get("zona").get("nome")), "%" + filter.zonaNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\specification\ZonaSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: ZonaSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\ZonaSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ZonaFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Zona;
import br.com.fiap.mottu.model.relacionamento.ZonaBox;
import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ZonaSpecification {

    public static Specification<Zona> withFilters(ZonaFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ZonaBox)
            if (filter.boxNome() != null && !filter.boxNome().isBlank()) {
                Join<Zona, ZonaBox> zonaBoxJoin = root.join("zonaBoxes");
                predicates.add(cb.like(cb.lower(zonaBoxJoin.get("box").get("nome")), "%" + filter.boxNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoZona)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Zona, VeiculoZona> veiculoZonaJoin = root.join("veiculoZonas");
                predicates.add(cb.equal(veiculoZonaJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            // Filtro por relacionamento ManyToMany (ZonaPatio)
            if (filter.patioNome() != null && !filter.patioNome().isBlank()) {
                Join<Zona, ZonaPatio> zonaPatioJoin = root.join("zonaPatios");
                predicates.add(cb.like(cb.lower(zonaPatioJoin.get("patio").get("nomePatio")), "%" + filter.patioNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\specification\BoxSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: BoxSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\BoxSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.BoxFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Box;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class BoxSpecification {

    public static Specification<Box> withFilters(BoxFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.status() != null && !filter.status().isBlank()) {
                predicates.add(cb.equal(root.get("status"), filter.status()));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\specification\ClienteSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: ClienteSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\ClienteSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ClienteFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ClienteSpecification {

    public static Specification<Cliente> withFilters(ClienteFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.sobrenome() != null && !filter.sobrenome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("sobrenome")), "%" + filter.sobrenome().toLowerCase() + "%"));
            }
            if (filter.cpf() != null && !filter.cpf().isBlank()) {
                predicates.add(cb.equal(root.get("cpf"), filter.cpf()));
            }
            if (filter.sexo() != null && !filter.sexo().isBlank()) {
                predicates.add(cb.equal(root.get("sexo"), filter.sexo()));
            }
            if (filter.profissao() != null && !filter.profissao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("profissao")), "%" + filter.profissao().toLowerCase() + "%"));
            }
            if (filter.estadoCivil() != null && !filter.estadoCivil().isBlank()) {
                predicates.add(cb.equal(root.get("estadoCivil"), filter.estadoCivil()));
            }
            if (filter.dataCadastroInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataCadastro"), filter.dataCadastroInicio()));
            }
            if (filter.dataCadastroFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataCadastro"), filter.dataCadastroFim()));
            }
            if (filter.dataNascimentoInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataNascimento"), filter.dataNascimentoInicio()));
            }
            if (filter.dataNascimentoFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataNascimento"), filter.dataNascimentoFim()));
            }

            // Filtro por relacionamento ManyToOne (Endereco)
            if (filter.enderecoCidade() != null && !filter.enderecoCidade().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("endereco").get("cidade")), "%" + filter.enderecoCidade().toLowerCase() + "%"));
            }
            if (filter.enderecoEstado() != null && !filter.enderecoEstado().isBlank()) {
                predicates.add(cb.equal(root.get("endereco").get("estado"), filter.enderecoEstado()));
            }

            // Filtro por relacionamento ManyToOne (Contato)
            if (filter.contatoEmail() != null && !filter.contatoEmail().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("contato").get("email")), "%" + filter.contatoEmail().toLowerCase() + "%"));
            }
            if (filter.contatoCelular() != null && !filter.contatoCelular().isBlank()) {
                predicates.add(cb.like(root.get("contato").get("celular"), "%" + filter.contatoCelular() + "%"));
            }

            // Filtro por relacionamento OneToMany (ClienteVeiculo) para propriedade de Veiculo
            // Isso envolve fazer um JOIN com a tabela de junção e depois com a entidade Veiculo
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Cliente, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.equal(clienteVeiculoJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }
            if (filter.veiculoModelo() != null && !filter.veiculoModelo().isBlank()) {
                Join<Cliente, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.like(cb.lower(clienteVeiculoJoin.get("veiculo").get("modelo")), "%" + filter.veiculoModelo().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados ao usar joins para coleções

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\specification\ContatoSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: ContatoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\ContatoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ContatoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Contato;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Join;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ContatoSpecification {

    public static Specification<Contato> withFilters(ContatoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.email() != null && !filter.email().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("email")), "%" + filter.email().toLowerCase() + "%"));
            }
            if (filter.ddd() != null) {
                predicates.add(cb.equal(root.get("ddd"), filter.ddd()));
            }
            if (filter.ddi() != null) {
                predicates.add(cb.equal(root.get("ddi"), filter.ddi()));
            }
            if (filter.telefone1() != null && !filter.telefone1().isBlank()) {
                predicates.add(cb.like(root.get("telefone1"), "%" + filter.telefone1() + "%"));
            }
            if (filter.celular() != null && !filter.celular().isBlank()) {
                predicates.add(cb.like(root.get("celular"), "%" + filter.celular() + "%"));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento OneToMany (Cliente)
            if (filter.clienteNome() != null && !filter.clienteNome().isBlank()) {
                Join<Contato, br.com.fiap.mottu.model.Cliente> clienteJoin = root.join("clienteContatos"); // Mapeia para o nome da coleção em Contato
                predicates.add(cb.like(cb.lower(clienteJoin.get("nome")), "%" + filter.clienteNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\specification\EnderecoSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: EnderecoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\EnderecoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.EnderecoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Endereco;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Join;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class EnderecoSpecification {

    public static Specification<Endereco> withFilters(EnderecoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.cep() != null && !filter.cep().isBlank()) {
                predicates.add(cb.equal(root.get("cep"), filter.cep()));
            }
            if (filter.numero() != null) {
                predicates.add(cb.equal(root.get("numero"), filter.numero()));
            }
            if (filter.logradouro() != null && !filter.logradouro().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("logradouro")), "%" + filter.logradouro().toLowerCase() + "%"));
            }
            if (filter.bairro() != null && !filter.bairro().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("bairro")), "%" + filter.bairro().toLowerCase() + "%"));
            }
            if (filter.cidade() != null && !filter.cidade().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("cidade")), "%" + filter.cidade().toLowerCase() + "%"));
            }
            if (filter.estado() != null && !filter.estado().isBlank()) {
                predicates.add(cb.equal(root.get("estado"), filter.estado()));
            }
            if (filter.pais() != null && !filter.pais().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("pais")), "%" + filter.pais().toLowerCase() + "%"));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento OneToMany (Cliente)
            if (filter.clienteNome() != null && !filter.clienteNome().isBlank()) {
                Join<Endereco, br.com.fiap.mottu.model.Cliente> clienteJoin = root.join("clienteEnderecos"); // Mapeia para o nome da coleção em Endereco
                predicates.add(cb.like(cb.lower(clienteJoin.get("nome")), "%" + filter.clienteNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\specification\PatioSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: PatioSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\PatioSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.PatioFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio; // Exemplo de junção
import br.com.fiap.mottu.model.relacionamento.EnderecoPatio; // Exemplo de junção
import br.com.fiap.mottu.model.relacionamento.ContatoPatio; // Exemplo de junção
import br.com.fiap.mottu.model.relacionamento.ZonaPatio; // Exemplo de junção
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class PatioSpecification {

    public static Specification<Patio> withFilters(PatioFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nomePatio() != null && !filter.nomePatio().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nomePatio")), "%" + filter.nomePatio().toLowerCase() + "%"));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoPatio)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Patio, VeiculoPatio> veiculoPatioJoin = root.join("veiculoPatios");
                predicates.add(cb.equal(veiculoPatioJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            // Filtro por relacionamento ManyToMany (EnderecoPatio)
            if (filter.enderecoCidade() != null && !filter.enderecoCidade().isBlank()) {
                Join<Patio, EnderecoPatio> enderecoPatioJoin = root.join("enderecoPatios");
                predicates.add(cb.like(cb.lower(enderecoPatioJoin.get("endereco").get("cidade")), "%" + filter.enderecoCidade().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ContatoPatio)
            if (filter.contatoEmail() != null && !filter.contatoEmail().isBlank()) {
                Join<Patio, ContatoPatio> contatoPatioJoin = root.join("contatoPatios");
                predicates.add(cb.like(cb.lower(contatoPatioJoin.get("contato").get("email")), "%" + filter.contatoEmail().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ZonaPatio)
            if (filter.zonaNome() != null && !filter.zonaNome().isBlank()) {
                Join<Patio, ZonaPatio> zonaPatioJoin = root.join("zonaPatios");
                predicates.add(cb.like(cb.lower(zonaPatioJoin.get("zona").get("nome")), "%" + filter.zonaNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\specification\RastreamentoSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: RastreamentoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;
import java.math.BigDecimal; // Importe BigDecimal!

public class RastreamentoSpecification {

    public static Specification<Rastreamento> withFilters(RastreamentoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            // Filtros para IPS
            if (filter.ipsX() != null) {
                predicates.add(cb.equal(root.get("ipsX"), filter.ipsX()));
            }
            if (filter.ipsY() != null) {
                predicates.add(cb.equal(root.get("ipsY"), filter.ipsY()));
            }
            if (filter.ipsZ() != null) {
                predicates.add(cb.equal(root.get("ipsZ"), filter.ipsZ()));
            }

            // Filtros para GPRS
            if (filter.gprsLatitude() != null) {
                predicates.add(cb.equal(root.get("gprsLatitude"), filter.gprsLatitude()));
            }
            if (filter.gprsLongitude() != null) {
                predicates.add(cb.equal(root.get("gprsLongitude"), filter.gprsLongitude()));
            }
            if (filter.gprsAltitude() != null) {
                predicates.add(cb.equal(root.get("gprsAltitude"), filter.gprsAltitude()));
            }

            // Filtro por relacionamento ManyToMany (VeiculoRastreamento)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Rastreamento, VeiculoRastreamento> veiculoRastreamentoJoin = root.join("veiculoRastreamentos");
                predicates.add(cb.equal(veiculoRastreamentoJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\specification\VeiculoSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: VeiculoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\VeiculoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.VeiculoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class VeiculoSpecification {

    public static Specification<Veiculo> withFilters(VeiculoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.placa() != null && !filter.placa().isBlank()) {
                predicates.add(cb.equal(root.get("placa"), filter.placa()));
            }
            if (filter.renavam() != null && !filter.renavam().isBlank()) {
                predicates.add(cb.equal(root.get("renavam"), filter.renavam()));
            }
            if (filter.chassi() != null && !filter.chassi().isBlank()) {
                predicates.add(cb.equal(root.get("chassi"), filter.chassi()));
            }
            if (filter.fabricante() != null && !filter.fabricante().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("fabricante")), "%" + filter.fabricante().toLowerCase() + "%"));
            }
            if (filter.modelo() != null && !filter.modelo().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("modelo")), "%" + filter.modelo().toLowerCase() + "%"));
            }
            if (filter.motor() != null && !filter.motor().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("motor")), "%" + filter.motor().toLowerCase() + "%"));
            }
            if (filter.ano() != null) {
                predicates.add(cb.equal(root.get("ano"), filter.ano()));
            }
            if (filter.combustivel() != null && !filter.combustivel().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("combustivel")), "%" + filter.combustivel().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ClienteVeiculo)
            if (filter.clienteCpf() != null && !filter.clienteCpf().isBlank()) {
                Join<Veiculo, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.equal(clienteVeiculoJoin.get("cliente").get("cpf"), filter.clienteCpf()));
            }

            // Filtro por relacionamento ManyToMany (VeiculoBox)
            if (filter.boxNome() != null && !filter.boxNome().isBlank()) {
                Join<Veiculo, VeiculoBox> veiculoBoxJoin = root.join("veiculoBoxes");
                predicates.add(cb.like(cb.lower(veiculoBoxJoin.get("box").get("nome")), "%" + filter.boxNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoPatio)
            if (filter.patioNome() != null && !filter.patioNome().isBlank()) {
                Join<Veiculo, VeiculoPatio> veiculoPatioJoin = root.join("veiculoPatios");
                predicates.add(cb.like(cb.lower(veiculoPatioJoin.get("patio").get("nomePatio")), "%" + filter.patioNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoZona)
            if (filter.zonaNome() != null && !filter.zonaNome().isBlank()) {
                Join<Veiculo, VeiculoZona> veiculoZonaJoin = root.join("veiculoZonas");
                predicates.add(cb.like(cb.lower(veiculoZonaJoin.get("zona").get("nome")), "%" + filter.zonaNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\specification\ZonaSpecification.java   |   PACOTE: br.com.fiap.mottu.specification   |   CLASSE: ZonaSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\ZonaSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ZonaFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Zona;
import br.com.fiap.mottu.model.relacionamento.ZonaBox;
import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ZonaSpecification {

    public static Specification<Zona> withFilters(ZonaFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ZonaBox)
            if (filter.boxNome() != null && !filter.boxNome().isBlank()) {
                Join<Zona, ZonaBox> zonaBoxJoin = root.join("zonaBoxes");
                predicates.add(cb.like(cb.lower(zonaBoxJoin.get("box").get("nome")), "%" + filter.boxNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoZona)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Zona, VeiculoZona> veiculoZonaJoin = root.join("veiculoZonas");
                predicates.add(cb.equal(veiculoZonaJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            // Filtro por relacionamento ManyToMany (ZonaPatio)
            if (filter.patioNome() != null && !filter.patioNome().isBlank()) {
                Join<Zona, ZonaPatio> zonaPatioJoin = root.join("zonaPatios");
                predicates.add(cb.like(cb.lower(zonaPatioJoin.get("patio").get("nomePatio")), "%" + filter.patioNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PACOTE: br.com.fiap.mottu.validation
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: backup\mottu-gradle\src\main\java\br\com\fiap\mottu\validation\ValidationGroups.java   |   PACOTE: br.com.fiap.mottu.validation   |   CLASSE: ValidationGroups
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.validation;

/**
 * Interfaces de grupos de validação para Bean Validation.
 * Servem para diferenciar regras de criação e atualização.
 */
public interface ValidationGroups {

    interface Create {}
    interface Update {}
}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// ARQUIVO: mottu-gradle\src\main\java\br\com\fiap\mottu\validation\ValidationGroups.java   |   PACOTE: br.com.fiap.mottu.validation   |   CLASSE: ValidationGroups
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.validation;

/**
 * Interfaces de grupos de validação para Bean Validation.
 * Servem para diferenciar regras de criação e atualização.
 */
public interface ValidationGroups {

    interface Create {}
    interface Update {}
}


